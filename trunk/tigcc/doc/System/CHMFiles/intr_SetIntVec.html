<HTML>
<HEAD>
<TITLE>SetIntVec</TITLE>
<LINK REL="STYLESHEET" TYPE="TEXT/CSS" HREF="style.css">
</HEAD>
<BODY BGCOLOR="#FFFFF8">
<TABLE CLASS="INVTABLE" WIDTH="100%">
<TR>
<TD CLASS="NOBORDER" WIDTH="40"><IMG SRC="function.gif" WIDTH="32" HEIGHT="32" BORDER="0"></TD>
<TD CLASS="TITLE">SetIntVec</TD>
<TD CLASS="DESCRIPTION">Function (Macro)</TD>
</TR>
</TABLE>
<HR>
<TABLE CLASS="NOBORDER" WIDTH="100%"><TR>
<TD CLASS="HEADER" ALIGN="RIGHT"><A HREF="intr.html">intr.h</A>
</TD>
</TR></TABLE>
<P><TABLE CLASS="DEFTABLE"><TR><TD CLASS="DEFINITION"><B><A HREF="keywords_void.html">void</A></B> SetIntVec (<B><A HREF="keywords_short.html">long</A></B> IntVec, <A HREF="intr_INT_HANDLER.html">INT_HANDLER</A> Handler);</TD></TR></TABLE>
<P CLASS="ITEMDESC"><B>Sets an interrupt vector.</B>
<P>SetIntVec sets the interrupt vector located at the absolute address
<I>IntVec</I> to the interrupt handler pointed to by
<I>Handler</I>. <I>Handler</I> should be either a value returned from
<A HREF="intr_GetIntVec.html">GetIntVec</A>, or the address of a user-defined interrupt
handler defined using <A HREF="intr_DEFINE_INT_HANDLER.html">DEFINE_INT_HANDLER</A>.
Note that <I>Handler</I> may not be the address of an ordinary C function.
<BR><BR>
Typical values of <I>IntVec</I> are given in the following table as enumerated
in the <A HREF="intr_IntVecs.html">IntVecs</A> enum:
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR>
<TD><B>Address</B></TD><TD><B>Associated Constant</B></TD><TD><B>Triggered On</B></TD>
</TR>
<TR>
<TD>0x04</TD><TD>INT_VEC_RESET</TD><TD>Reset (contains pointer to OS entry point)</TD>
</TR>
<TR>
<TD>0x08</TD><TD>INT_VEC_BUS_ERROR</TD><TD>Bus error</TD>
</TR>
<TR>
<TD>0x0C</TD><TD>INT_VEC_ADDRESS_ERROR</TD><TD>Address error (accessing a short or long at an odd address)</TD>
</TR>
<TR>
<TD>0x10</TD><TD>INT_VEC_ILLEGAL_INSTRUCTION</TD><TD>Illegal instruction</TD>
</TR>
<TR>
<TD>0x14</TD><TD>INT_VEC_ZERO_DIVIDE</TD><TD>Division by zero</TD>
</TR>
<TR>
<TD>0x18</TD><TD>INT_VEC_CHK_INS</TD><TD>CHK instruction</TD>
</TR>
<TR>
<TD>0x1C</TD><TD>INT_VEC_TRAPV_INS</TD><TD>TRAPV instruction</TD>
</TR>
<TR>
<TD>0x20</TD><TD>INT_VEC_PRIVILEGE_VIOLATION</TD><TD>Privilege violation</TD>
</TR>
<TR>
<TD>0x24</TD><TD>INT_VEC_TRACE</TD><TD>Code Tracing</TD>
</TR>
<TR>
<TD>0x28</TD><TD>INT_VEC_LINE_1010</TD><TD>Special instructions generated by <A HREF="error_ER_throw.html">ER_throw</A> (0xA???)</TD>
</TR>
<TR>
<TD>0x2C</TD><TD>INT_VEC_LINE_1111</TD><TD><A HREF="httigcc_advanced_flinerom.html">F-Line</A> instructions (0xF???)</TD>
</TR>
<TR>
<TD>0x3C</TD><TD>INT_VEC_UNINITIALIZED_INT</TD><TD>Uninitialized interrupt vector</TD>
</TR>
<TR>
<TD>0x60</TD><TD>INT_VEC_SPURIOUS_INT</TD><TD>Spurious interrupt</TD>
</TR>
<TR>
<TD>0x64</TD><TD>AUTO_INT_1</TD><TD>Main timer hardware interrupt running at approximately 350 Hz</TD>
</TR>
<TR>
<TD>0x68</TD><TD>AUTO_INT_2<BR>INT_VEC_KEY_PRESS</TD><TD>Key press (triggered periodically while key(s) other than 'ON' are held down; the rate depends both on battery strength and on which keys are being held down, and is usually in the ballpark of about 600 Hz)</TD>
</TR>
<TR>
<TD>0x6C</TD><TD>AUTO_INT_3</TD><TD>On most calculators, triggers once per second if enabled using a certain instruction</TD>
</TR>
<TR>
<TD>0x70</TD><TD>AUTO_INT_4<BR>INT_VEC_LINK</TD><TD>Link port activity</TD>
</TR>
<TR>
<TD>0x74</TD><TD>AUTO_INT_5</TD><TD>System timer running at approximately 18 Hz (see <A HREF="intr_PRG_setRate.html">PRG_setRate</A>, <A HREF="intr_PRG_setStart.html">PRG_setStart</A>)</TD>
</TR>
<TR>
<TD>0x78</TD><TD>AUTO_INT_6<BR>INT_VEC_ON_KEY_PRESS</TD><TD>'ON' key press</TD>
</TR>
<TR>
<TD>0x7C</TD><TD>AUTO_INT_7<BR>INT_VEC_STACK_OVERFLOW</TD><TD>Stack overflow (actually results in Protected Memory Violation)</TD>
</TR>
</TABLE>
<BR>
All traps may be triggered manually using the TRAP assembler instruction.
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR>
<TD><B>Address</B></TD><TD><B>Associated Constant</B></TD><TD><B>Default Behavior</B></TD>
</TR>
<TR>
<TD>0x80</TD><TD>TRAP_0</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x84</TD><TD>TRAP_1<BR>INT_VEC_INT_MASK</TD><TD>Change interrupt mask (bits 8-10 of %sr) to %d0.w, output old mask in %d0.l</TD>
</TR>
<TR>
<TD>0x88</TD><TD>TRAP_2<BR>INT_VEC_MANUAL_RESET</TD><TD>Reset calculator</TD>
</TR>
<TR>
<TD>0x8C</TD><TD>TRAP_3</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x90</TD><TD>TRAP_4<BR>INT_VEC_OFF</TD><TD>Turn the calculator off and wait for 'ON' key press</TD>
</TR>
<TR>
<TD>0x94</TD><TD>TRAP_5</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x98</TD><TD>TRAP_6</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x9C</TD><TD>TRAP_7</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0xA0</TD><TD>TRAP_8</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0xA4</TD><TD>TRAP_9</TD><TD>Access to various system routines</TD>
</TR>
<TR>
<TD>0xA8</TD><TD>TRAP_10<BR>INT_VEC_SELF_TEST</TD><TD>Enter self test</TD>
</TR>
<TR>
<TD>0xAC</TD><TD>TRAP_11<BR>INT_VEC_ARCHIVE</TD><TD>Print "Trap 11" and freeze</TD>
</TR>
<TR>
<TD>0xB0</TD><TD>TRAP_12</TD><TD>Put the processor in supervisor mode; return the previous value of the status register in <CODE>%d0:w</CODE></TD>
</TR>
<TR>
<TD>0xB4</TD><TD>TRAP_13</TD><TD>Print "Trap 13" and freeze</TD>
</TR>
<TR>
<TD>0xB8</TD><TD>TRAP_14</TD><TD>Print "Trap 14" and freeze</TD>
</TR>
<TR>
<TD>0xBC</TD><TD>TRAP_15<BR>INT_VEC_ER_THROW</TD><TD>Print "ER_throw" and freeze</TD>
</TR>
</TABLE>
<BR>
See <A HREF="intr_DEFINE_INT_HANDLER.html">DEFINE_INT_HANDLER</A> for an example of usage.
<P><HR>See also: <A HREF="intr_GetIntVec.html">GetIntVec</A>, <A HREF="intr_IntVecs.html">IntVecs</A>, <A HREF="intr_DEFINE_INT_HANDLER.html">DEFINE_INT_HANDLER</A>
</BODY>
</HTML>
