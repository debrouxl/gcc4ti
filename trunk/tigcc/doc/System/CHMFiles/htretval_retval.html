<HTML>
<HEAD>
<TITLE>Returning Values Like TI-Basic Functions</TITLE>
<LINK REL="STYLESHEET" TYPE="TEXT/CSS" HREF="style.css">
</HEAD>
<BODY BGCOLOR="#FFFFF8">
<TABLE CLASS="INVTABLE" WIDTH="100%">
<TR>
<TD CLASS="NOBORDER" WIDTH="40"><IMG SRC="info.gif" WIDTH="32" HEIGHT="32" BORDER="0"></TD>
<TD CLASS="TITLE">Returning Values Like TI-Basic Functions</TD>
</TR>
</TABLE>
<HR>
<TABLE CLASS="NOBORDER" WIDTH="100%"><TR>
<TD CLASS="HEADER" ALIGN="LEFT" WIDTH="60"></TD>
<TD CLASS="HEADER" ALIGN="CENTER"><A HREF="htretval.html">Returning Values</A></TD>
<TD CLASS="HEADER" ALIGN="RIGHT" WIDTH="60"><A HREF="htretval_retvar.html">Next</A></TD>
</TR></TABLE>
<P>It is possible to write programs which return a value to the TI-Basic, i.e. which act
like TI-Basic function (with some serious limitations; read below for more
info). To do this, put the following statement at the begining of the program (or
at the begining of the main module of your program):<BR><BR>
<PRE>#define RETURN_VALUE
</PRE>
This will work in both NoStub and kernel mode. Such statement will cause
the last value pushed to the expression stack to become the "result"
of the program. For pushing values on expression stack, use routines from the
<A HREF="estack.html">estack.h</A> header file. For example, use
<A HREF="estack_push_shortint.html">push_shortint</A> or
<A HREF="estack_push_longint.html">push_longint</A> to push integer values,
<A HREF="estack_push_Float.html">push_Float</A> to push floating point values,
<A HREF="estack_push_zstr.html">push_zstr</A> to push strings, etc. Note
that if you declared <CODE>RETURN_VALUE</CODE>, you <I>must</I> push something on the
expression stack.
<BR><BR>
If you plan to write a function which returns a value to TI-Basic in either ASM or C, you
should also clean up all arguments of the function from the expression stack before
pushing the result including the <A HREF="estack_Tags.html#END_TAG">END_TAG</A>. If you
neglect to do this, then using the function as an argument of another one will not work
correctly. Also, you should leave exactly one value on the expression stack (i.e. you
should delete all eventual temporary results from the expression stack). Here is a
sample code how you can clean up function arguments from the expression stack:
<PRE>while (GetArgType (top_estack) != END_TAG)
  top_estack = next_expression_index (top_estack);
top_estack--;
</PRE>
Here is a complete example (called "Add Arguments") of a
very simple program which gets two arguments (assuming that they are small
positive integers, without any checking), and returns their sum (see
<A HREF="args.html">args.h</A> for more info about getting the arguments):
<PRE>// Add the first two integers passed to the program

#define RETURN_VALUE

#define USE_TI89
#define USE_TI92PLUS
#define USE_V200

#define MIN_AMS 101

#include &lt;args.h&gt;
#include &lt;estack.h&gt;

void _main(void)
{
  ESI argptr = top_estack;
  short a = GetIntArg (argptr);
  short b = GetIntArg (argptr);
  while (GetArgType (top_estack) != END_TAG)  // Clean up arguments
    top_estack = next_expression_index (top_estack);
  top_estack--;
  push_longint (a + b);
}
</PRE>
Test this program from TI-Basic by giving <CODE>add(2,3)</CODE> (assuming that
you compiled it and gave the name "add.c" to it). Note that if you neglect cleaning
up arguments from the expression stack, then something like
<CODE>add(add(3,5),add(4,7))</CODE> will not give the correct result!
<BR><BR>
You can even return <B>lists</B> as the result. To do this, push first
End_Of_List marker (using <A HREF="estack_push_END_TAG.html">push_END_TAG</A>), then
push elements of the list in the reverse order, and finnaly push List marker on the
expression stack using <A HREF="estack_push_LIST_TAG.html">push_LIST_TAG</A>. The following
program (called "Folder") returns the list of all variables in the folder which is given as the argument:
<PRE>// Get the variables in a folder as a list

#define RETURN_VALUE

#define USE_TI89
#define USE_TI92PLUS
#define USE_V200

#define MIN_AMS 101

#include &lt;args.h&gt;
#include &lt;estack.h&gt;
#include &lt;vat.h&gt;

void _main(void)
{
  ESI argptr = top_estack;
  SYM_ENTRY *SymPtr = SymFindFirst (GetSymstrArg (argptr), 1);
  while (GetArgType (top_estack) != END_TAG)  // Clean up arguments
    top_estack = next_expression_index (top_estack);
  top_estack--;
  push_END_TAG ();
  while (SymPtr)
    {
      push_ANSI_string (SymPtr-&gt;name);
      SymPtr = SymFindNext ();
    }
  push_LIST_TAG ();
}
</PRE>
Give the name "folder.c" to it, compile it using<BR><BR>
<B>tigcc -O2 folder.c</B><BR><BR>
then try, for example, <CODE>folder("main")</CODE> from the TI-Basic. Happy? Many
users asked me how to make such a program!
<BR><BR>
Now about problems. Everything works fine in AMS 1.xx, but AMS 2.xx forbids the use of
ASM programs in expressions. So, in the above example, <CODE>'add(2,3)'</CODE> will
work perfectly, but <CODE>'5+add(2,3)'</CODE> or even
<CODE>'add(2,3)-&gt;a'</CODE> will not. This stupidity
makes returning values mostly useless. What to do? Unfortunately, I can't do nothing
from GCC4TI itself, because an ASM program will not be executed at all if AMS 2.xx
detects its presence in an expression. However, there is a solution: it is possible to
make a resident program which will intercept such "stupid" behaviour of AMS 2.xx and to
allow executing ASM programs in expressions. Such interception is already implemented
in PreOS and KerNO. So, if you have installed a fresh release of PreOS or KerNO, everything
will work OK even on AMS 2.xx. There is also a TSR called IPR which intercepts only this
error and the "ASAP or Exec string too long" error available at
<A HREF="http://membres.lycos.fr/sirryl/download/index.php?url=download.php">Cyril
Pascal's (Paxal's) web page</A> for those who don't want to install a full-featured
kernel. But for HW2 calculators, the <A HREF="http://ti89prog.kevinkofler.cjb.net">HW2
AMS 2 TSR support (h220xTSR)</A> needs to be installed before IPR.
This does <B>not</B> mean that your program must be compiled in "kernel" mode:
it may be a "nostub" program, but PreOs, KerNO or IPR must be present on the calculator
(to intercept stupid behavior of AMS 2.xx). To conclude: if you have AMS 2.xx and if
you want to use "returning a value" feature, you must have installed PreOs, KerNO or
IPR. If you are a programmer, please note this fact in the documentation of any program
which uses this feature!
<BR><BR>
As an alternative, you may use <A HREF="htretval_retvar.html">returning values
through variables</A>.
</BODY>
</HTML>
