[Main]
Name=LIO_RecvData
Type=Function
Subtype=ROM Call
Header Files=link.h
Definition=unsigned short LIO_RecvData (void *dest, unsigned long size, unsigned long WaitDelay);

[ROM Call]
Index=$5B

[Description]
Receives data from the link interface.

[Explanation]
LIO_RecvData reads <I>size</I> bytes through the link interface, and stores received bytes
at the address <I>dest</I>. This functions calls repeatedly <A HREF="$$LINK(link.h/OSReadLinkBlock)">OSReadLinkBlock</A> function
as many times as necessary to receive wanted amount of data. Parameter <I>WaitDelay</I> is
the maximal allowed waiting time: if no data is received during <I>WaitDelay</I> timer ticks
(one timer tick is 1/20 seconds by default), the reading fails. When <I>WaitDelay</I> is set
to zero, this means "waiting forever". Anyway, this operation may be interrupted by pressing ON
key. LIO_RecvData returns zero if the operation was successful, else returns a non-zero value
(this value describes the type of the error, but I am not sure about the concrete meaning of
particular values).
<BR><BR><B>Note:</B> This functions registers <A HREF="$$LINK(system.h/Timers)">LIO_TIMER</A> for measuring
the time. See <A HREF="$$LINK(system.h/OSRegisterTimer)">OSRegisterTimer</A> for more info.

[References]
In=link.h/LIO_Get, link.h/LIO_Receive, link.h/LIO_Send, link.h/LIO_SendProduct, link.h/OSCheckSilentLink, link.h/OSLinkCmd, events.h/handleVarLinkKey, link.h/LIO_SendIdList
Out=link.h/OSReadLinkBlock, link.h/OSLinkReset, system.h/off, system.h/OSClearBreak, system.h/OSFreeTimer, system.h/OSRegisterTimer, system.h/OSTimerExpired, system.h/OSTimerRestart, unknown.h/_ROM_CALL_46E
