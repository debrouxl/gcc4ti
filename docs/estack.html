<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>estack.h</TITLE>
<STYLE TYPE="TEXT/CSS">
<!--
.IE3-DUMMY { CONT-SIZE: 100%; }
BODY { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; }
P { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H1 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H2 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H3 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H4 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H5 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H6 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
UL { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #FFFFFF; }
.NOBORDER { BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.NOBORDER TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.CODE { FONT-FAMILY: Courier New; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#E0E0E0">
<FONT SIZE="5"><B>The &lt;estack.h&gt; Header File</B></FONT>
<HR>
<P><B>Routines for symbolic manipulation and expression handling</B></P>

<H3><U>Functions</U></H3>
<DL INDENT="20"><DT><B><A HREF="#add_to_top">add_to_top</A></B><DD>Adds a value to the expression on the top of the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#add1_to_top">add1_to_top</A></B><DD>Adds 1 to the top of the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#all_tail">all_tail</A></B><DD>Checks whether all elements in the list have some property.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#and_onto_top">and_onto_top</A></B><DD>Logical ANDs an expression onto the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#any_tail">any_tail</A></B><DD>Checks whether any element in the list has some property.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#are_expressions_identical">are_expressions_identical</A></B><DD>Checks whether two expressions are identical.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#can_be_approxed">can_be_approxed</A></B><DD>Checks whether an expression can be approximated to a number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#check_estack_size">check_estack_size</A></B><DD>Checks if there is enough room on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#compare_complex_magnitudes">compare_complex_magnitudes</A></B><DD>Compares magnitudes of two complex number entries on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#compare_expressions">compare_expressions</A></B><DD>Compares two expressions.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#compare_Floats">compare_Floats</A></B><DD>Compares two floating point entries on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#CreateEmptyList">CreateEmptyList</A></B><DD>Creates a MULTI_EXPR containing an empty list and returns its handle.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#delete_between">delete_between</A></B><DD>Deletes a sequence of bytes from the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#delete_expression">delete_expression</A></B><DD>Deletes an expression from the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#deleted_between">deleted_between</A></B><DD>Deletes a sequence of bytes from the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#deleted_expression">deleted_expression</A></B><DD>Deletes an expression from the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#did_push_cnvrt_Float_to_integer">did_push_cnvrt_Float_to_integer</A></B><DD>Pushes a floating point entry converted to an integer, but only if it is an exact whole number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#display_statements">display_statements</A></B><DD>Converts tokenized expressions or TI-Basic statements to the printable form.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#divide_top">divide_top</A></B><DD>Divides the expression onto the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#estack_number_to_Float">estack_number_to_Float</A></B><DD>Converts entry on the expression stack to floating point number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#estack_to_short">estack_to_short</A></B><DD>Converts entry on the expression stack to signed short integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#estack_to_ushort">estack_to_ushort</A></B><DD>Converts entry on the expression stack to unsigned short integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ESTACK">ESTACK</A></B><DD>Reads the expression stack at a specific index.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#factor_base_index">factor_base_index</A></B><DD>Gets the index of the base of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#factor_exponent_index">factor_exponent_index</A></B><DD>Gets the index of the exponent of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#gcd_exact_whole_Floats">gcd_exact_whole_Floats</A></B><DD>Finds the greatest common divisor of two floating point entries.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#get_key_ptr">get_key_ptr</A></B><DD>Converts a tag code to a tag name.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GetValue">GetValue</A></B><DD>Converts entry on the expression stack to short integer and checks whether it is in a given range.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="homescr.html#HS_popEStack">HS_popEStack</A></B><DD>Pops the entire expression stack into memory.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#HToESI">HToESI</A></B><DD>Converts a handle to an expression stack index.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#im_index">im_index</A></B><DD>Gets the index of the imaginary part of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#index_below_display_expression_aux">index_below_display_expression_aux</A></B><DD>Main routine for detokenizing.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#index_main_var">index_main_var</A></B><DD>Searches an expression for a first encountered variable.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#index_numeric_term">index_numeric_term</A></B><DD>Searches terms in the expression for a numeric term.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#index_of_lead_base_of_lead_term">index_of_lead_base_of_lead_term</A></B><DD>Gets the index of the base of the lead term of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#init_list_indices">init_list_indices</A></B><DD>Computes and stores the indices of the elements of a list.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#init_matrix_indices">init_matrix_indices</A></B><DD>Computes and stores the indices of the elements of a matrix.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#integer_non_unknown">integer_non_unknown</A></B><DD>Tests if an expression is an integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is0">is0</A></B><DD>Tests if an expression is equal to 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is1">is1</A></B><DD>Tests if an expression is equal to 1.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_advanced_tag">is_advanced_tag</A></B><DD>Checks whether a tag is an advanced tag.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_antisymmetric">is_antisymmetric</A></B><DD>Checks for a antisymmetry.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_complex0">is_complex0</A></B><DD>Checks whether an expression is reducible to zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_complex_number">is_complex_number</A></B><DD>Checks whether an expression is a number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_constant">is_constant</A></B><DD>Checks whether an expression is constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_Float_exact_whole_number">is_Float_exact_whole_number</A></B><DD>Checks whether a floating point entry is an exact whole number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_free_of_tag">is_free_of_tag</A></B><DD>Checks whether an expression is free of a particular tag.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_independent_of_de_seq_vars">is_independent_of_de_seq_vars</A></B><DD>Checks whether an expression is independent of differential equation and sequence variables.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_independent_of_elements">is_independent_of_elements</A></B><DD>Checks whether an expression is independent of the elements of a list.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_independent_of_tail">is_independent_of_tail</A></B><DD>Checks whether an expression is independent of a sequence of variables (or expressions).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_independent_of">is_independent_of</A></B><DD>Checks whether an expression is independent of a variable (or expression).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_matrix">is_matrix</A></B><DD>Checks whether an expression is a matrix.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_minus1">is_minus1</A></B><DD>Tests if an expression is equal to -1.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_monomial_in_kernel">is_monomial_in_kernel</A></B><DD>Checks whether an expression is a monomial in kernel.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_monomial">is_monomial</A></B><DD>Checks whether an expression is a monomial.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_narrowly_independent_of">is_narrowly_independent_of</A></B><DD>Checks whether an expression is narrowly independent of a variable (???).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_negative">is_negative</A></B><DD>Tests if an expression is less than 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_never0">is_never0</A></B><DD>Tests if an expression is never 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_nonnegative">is_nonnegative</A></B><DD>Tests if an expression is &gt;= 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_nonpositive">is_nonpositive</A></B><DD>Tests if an expression is &lt;= 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_polynomial_in_var_or_kern">is_polynomial_in_var_or_kern</A></B><DD>Checks if an expression is a polynomial with respect to another expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_pos_int_and_eq_quantum">is_pos_int_and_eq_quantum</A></B><DD>Determines whether <I>expr</I> points to the tag of a positive integer equal to <I>num</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_positive">is_positive</A></B><DD>Tests if an expression is greater than 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_reciprocal_of_quantum">is_reciprocal_of_quantum</A></B><DD>Determines whether <I>expr</I> points to the tag of the reciprocal of <CODE>ESQ</CODE> <I>num</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_square_matrix">is_square_matrix</A></B><DD>Checks whether an expression is a square matrix.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_symmetric">is_symmetric</A></B><DD>Checks for symmetry.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_tail_independent_of">is_tail_independent_of</A></B><DD>Checks whether a sequence of expressions is independent of a variable (or expression).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_temperature_unit">is_temperature_unit</A></B><DD>Checks for strings of temperature units.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_totally_polynomial">is_totally_polynomial</A></B><DD>Checks if an expression is polynomial in all variables.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_valid_smap_aggregate">is_valid_smap_aggregate</A></B><DD>Checks whether an expression is a valid aggregate type.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_variable">is_variable</A></B><DD>Checks if the expression is a variable.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_whole_number">is_whole_number</A></B><DD>Tests if an expression is a whole number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#last_element_index">last_element_index</A></B><DD>Searches for the last expression in the list.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#lead_base_index">lead_base_index</A></B><DD>Gets the index of the base of the lead factor of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#lead_exponent_index">lead_exponent_index</A></B><DD>Gets the index of the exponent of the lead factor of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#lead_factor_index">lead_factor_index</A></B><DD>Gets the index of the lead factor of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#lead_term_index">lead_term_index</A></B><DD>Gets the index of the lead term of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#likely_approx_to_complex_number">likely_approx_to_complex_number</A></B><DD>Checks if it is likely that an expression can be approxed to a complex number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#likely_approx_to_number">likely_approx_to_number</A></B><DD>Checks is it likely that an expression can be approxed to a real number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#main_gen_var_index">main_gen_var_index</A></B><DD>Searches an expression for a generalized variable.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#map_tail_Int">map_tail_Int</A></B><DD>Applies an extended function to all elements in the list.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#map_tail">map_tail</A></B><DD>Applies a function to all elements in the list.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#map_unary_over_comparison">map_unary_over_comparison</A></B><DD>Calls callback function for both comparison terms and pushes the comparison tag.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#min_quantum">min_quantum</A></B><DD>Finds smaller of two tags.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#move_between_to_top">move_between_to_top</A></B><DD>Moves a sequence of bytes to the top of the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#moved_between_to_top">moved_between_to_top</A></B><DD>Moves a sequence of bytes to the top of the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#negate_top">negate_top</A></B><DD>Negates the top of the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#next_expression_index">next_expression_index</A></B><DD>Finds the next entry on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NG_approxESI">NG_approxESI</A></B><DD>Evaluates an expression in "APPROX" mode.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NG_execute">NG_execute</A></B><DD>Executes TI-Basic statements.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NG_graphESI">NG_graphESI</A></B><DD>Evaluates an expressions for graphing purposes.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NG_rationalESI">NG_rationalESI</A></B><DD>Evaluates an expression in "EXACT" mode.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NG_RPNToText">NG_RPNToText</A></B><DD>Detokenizes a tokenized structure associated with a handle.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NG_tokenize">NG_tokenize</A></B><DD>Tokenizes text associated with a handle and pushes them to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#norm1_complex_Float">norm1_complex_Float</A></B><DD>Finds the 1-norm of a complex number entry.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#numeric_factor_index">numeric_factor_index</A></B><DD>Searches factors in the expression for a numeric factor.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#or_onto_top">or_onto_top</A></B><DD>Logical ORs an expression onto the estack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Parms2D">Parms2D</A></B><DD>Gets information about dimensions of block which will be "pretty printed".<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Parse1DExpr">Parse1DExpr</A></B><DD>Parses a tokenized expression to be printed.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Parse2DExpr">Parse2DExpr</A></B><DD>Parses a tokenized expression to be pretty printed using Print2DExpr.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Parse2DMultiExpr">Parse2DMultiExpr</A></B><DD>Parses a multi-statement expression associated with a handle to be pretty printed using Print2DExpr.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Print2DExpr">Print2DExpr</A></B><DD>Performs "pretty printing" (or "2D printing") of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push0">push0</A></B><DD>Pushes a tagged integer or a tagged float 0, depending on the mode setting.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push1">push1</A></B><DD>Pushes a tagged integer or a tagged float 1, depending on the mode setting.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_ANSI_string">push_ANSI_string</A></B><DD>Pushes a standard C string to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_between">push_between</A></B><DD>Pushes a sequence of bytes to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_cnvrt_integer_if_whole_nmb">push_cnvrt_integer_if_whole_nmb</A></B><DD>Pushes a floating point entry eventually converted to an integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_e">push_e</A></B><DD>Pushes <B><I>e</I></B>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_END_TAG">push_END_TAG</A></B><DD>Pushes end-of-list marker to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_exact0">push_exact0</A></B><DD>Pushes a tagged integer 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_exact1">push_exact1</A></B><DD>Pushes a tagged integer 1.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_exact_minus1">push_exact_minus1</A></B><DD>Pushes a tagged integer -1.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_expr_quantum">push_expr_quantum</A></B><DD>Pushes an expression followed by a tag to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_expr2_quantum">push_expr2_quantum</A></B><DD>Pushes two expressions followed by a tag to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_expression">push_expression</A></B><DD>Pushes an expression to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_Float_to_nonneg_int">push_Float_to_nonneg_int</A></B><DD>Rounds a floating point value to an integer, then pushes it to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_Float_to_rat">push_Float_to_rat</A></B><DD>Pushes a rational approximation of a floating point entry.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_Float">push_Float</A></B><DD>Pushes a floating point value to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_half">push_half</A></B><DD>Pushes a tagged fraction +1/2 or a tagged float 0.5, depending on the mode setting.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_i">push_i</A></B><DD>Pushes <B><I>i</I></B>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_internal_simplify">push_internal_simplify</A></B><DD>Converts an expression into internal canonic form and pushes the result to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_LIST_TAG">push_LIST_TAG</A></B><DD>Pushes list tag to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_long_to_integer">push_long_to_integer</A></B><DD>Pushes a signed long integer to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_longint">push_longint</A></B><DD>Pushes a long integer to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_longlongint">push_longlongint</A></B><DD>Pushes a double-long integer to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_minus1">push_minus1</A></B><DD>Pushes a tagged integer or a tagged float -1, depending on the mode setting.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_minus_half">push_minus_half</A></B><DD>Pushes a tagged fraction -1/2 or a tagged float -0.5, depending on the mode setting.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_minus_recip_of_quantum">push_minus_recip_of_quantum</A></B><DD>Pushes on the EStack minus the reciprocal of the argument as a tagged negative fraction.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_negate_quantum_as_negint">push_negate_quantum_as_negint</A></B><DD>Pushes on the EStack the argument as a tagged negative integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_next_arb_int">push_next_arb_int</A></B><DD>Pushes a next "arbitrary integer" symbol to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_next_arb_real">push_next_arb_real</A></B><DD>Pushes a next "arbitrary real" symbol to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_next_internal_var">push_next_internal_var</A></B><DD>Pushes an internal variable to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_no_solution_found_string">push_no_solution_found_string</A></B><DD>Pushes "No solution found", or its localized version if a language localization is active (on AMS 2.xx), on the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_offset_array">push_offset_array</A></B><DD>Pushes an array of offsets to the list items.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_overflow_to_infinity">push_overflow_to_infinity</A></B><DD>Displays a warning, and pushes a tag to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_parse_text">push_parse_text</A></B><DD>Parses an expression given in a string and pushes tokenized expression to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_pi_on_quantum">push_pi_on_quantum</A></B><DD>Pushes on the EStack the quotient of PI (numerator) and of the argument (denominator), in a way depending on the mode setting.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_pi">push_pi</A></B><DD>Pushes on the EStack a tagged float PI if the mode setting is APPROX, otherwise pushes a <A HREF="#PI_TAG">PI_TAG</A>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_quantum_as_nonnegative_int">push_quantum_as_nonnegative_int</A></B><DD>Pushes on the EStack the argument as a tagged positive integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_quantum_pair_as_pos_frac">push_quantum_pair_as_pos_frac</A></B><DD>Pushes on the EStack the quotient of the first argument (numerator) and the second argument (denominator).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_quantum_pair">push_quantum_pair</A></B><DD>Pushes two bytes (tags) to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_quantum">push_quantum</A></B><DD>Pushes a byte (tag) to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_reciprocal_of_quantum">push_reciprocal_of_quantum</A></B><DD>Pushes on the EStack the reciprocal of the argument as a tagged positive fraction.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_reversed_tail">push_reversed_tail</A></B><DD>Pushes elements of the list up to tail onto the stack in reversed order.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_round_Float">push_round_Float</A></B><DD>Pushes an approximation of a floating point entry.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_shortint">push_shortint</A></B><DD>Pushes a short integer to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_simplify">push_simplify</A></B><DD>Simplifies the argument and pushes onto the estack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_transpose_aux">push_transpose_aux</A></B><DD>Pushes transposed matrix to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_ulong_to_integer">push_ulong_to_integer</A></B><DD>Pushes an unsigned long integer to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_ushort_to_integer">push_ushort_to_integer</A></B><DD>Pushes an unsigned short integer to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#push_zstr">push_zstr</A></B><DD>Pushes a standard C string to the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#raise_to_top">raise_to_top</A></B><DD>Raises a value to the power given by the expression on the top of the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#re_index">re_index</A></B><DD>Gets the index of the real part of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#reductum_index">reductum_index</A></B><DD>Gets the index of remaining terms of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#remaining_element_count">remaining_element_count</A></B><DD>Returns number of elements remaining.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#remaining_factors_index">remaining_factors_index</A></B><DD>Gets the index of remaining factors of an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top_with_post_simplified">replace_top_with_post_simplified</A></B><DD>Replaces the expression on top of the EStack, in internal form, with the external (printing) form.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top_with_reciprocal">replace_top_with_reciprocal</A></B><DD>Replaces the expression on top of the EStack by its reciprocal.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_and">replace_top2_with_and</A></B><DD>Replace the two top-most expressions on the EStack by their logical AND.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_difference">replace_top2_with_difference</A></B><DD>Replace the two top-most expressions on the EStack by their difference.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_imre">replace_top2_with_imre</A></B><DD>Replace the two top-most expressions on the EStack by a complex number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_or">replace_top2_with_or</A></B><DD>Replace the two top-most expressions on the EStack by their logical OR.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_pow">replace_top2_with_pow</A></B><DD>Replace the two top-most expressions on the EStack by a power.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_prod">replace_top2_with_prod</A></B><DD>Replace the two top-most expressions on the EStack by their product.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_ratio">replace_top2_with_ratio</A></B><DD>Replace the two top-most expressions on the EStack by their ratio.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#replace_top2_with_sum">replace_top2_with_sum</A></B><DD>Replace the two top-most expressions on the EStack by their sum.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#reset_control_flags">reset_control_flags</A></B><DD>Resets the control flags for operations with the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#reset_estack_size">reset_estack_size</A></B><DD>Reallocates the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#should_and_did_push_approx_arg2">should_and_did_push_approx_arg2</A></B><DD>Pushes a second floating point argument, if possible.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#signum_Float">signum_Float</A></B><DD>Finds the signum of a floating point entry.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#subtract_from_top">subtract_from_top</A></B><DD>Subtracts a value from the top of the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#subtract1_from_top">subtract1_from_top</A></B><DD>Subtracts 1 from the top of the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#times_top">times_top</A></B><DD>Multiplies the expression onto the EStack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#TokenizeSymName">TokenizeSymName</A></B><DD>Tokenizes a C string into a symbol name.</DL>
<H3><U>Global Variables</U></H3>
<DL INDENT="20"><DT><B><A HREF="#ARb_int_count">ARb_int_count</A></B><DD>Represents the number of times arbitrary-integer variables were already used by some calculus.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ARb_real_count">ARb_real_count</A></B><DD>Represents the number of times arbitrary variables were already used by some calculus.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bottom_estack">bottom_estack</A></B><DD>Points to the bottom of the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#command_tag_list">command_tag_list</A></B><DD>Array of structures containing information on <A HREF="#InstructionTags">InstructionTags</A>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#estack_max_index">estack_max_index</A></B><DD>Points to the end of the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Float0Index">Float0Index</A></B><DD>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value 0.0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Float1Index">Float1Index</A></B><DD>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value 1.0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FloatExp1Index">FloatExp1Index</A></B><DD>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value <I>e</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FloatHalfIndex">FloatHalfIndex</A></B><DD>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value 0.5.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FloatMinus1Index">FloatMinus1Index</A></B><DD>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value -1.0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FloatPiIndex">FloatPiIndex</A></B><DD>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value <I>pi</I>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FLOATTAB">FLOATTAB</A></B><DD>A pointer to an array of more or less commonly used <U>untagged</U> floats.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#index_false">index_false</A></B><DD>Pointer on a <CODE>FALSE_TAG</CODE> (0x2B) stored in the Flash.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#index_true">index_true</A></B><DD>Pointer on a <CODE>TRUE_TAG</CODE> (0x2C) stored in the Flash.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Integer0Index">Integer0Index</A></B><DD>Pointer to the end tag (POSINT_TAG) of an integer value 0.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Integer1Index">Integer1Index</A></B><DD>Pointer to the end tag (POSINT_TAG) of an integer value 1.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Integer2Index">Integer2Index</A></B><DD>Pointer to the end tag (POSINT_TAG) of an integer value 2.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#IntegerMinus1Index">IntegerMinus1Index</A></B><DD>Pointer to the end tag (NEGINT_TAG) of an integer value -1.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#primary_tag_list">primary_tag_list</A></B><DD>Array of structures containing information on <A HREF="#Tags">Tags</A>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#secondary_tag_list">secondary_tag_list</A></B><DD>Array of structures containing information on <A HREF="#ExtTags">ExtTags</A>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#sysvar_tag_list">sysvar_tag_list</A></B><DD>Array of structures containing information on <A HREF="#SysvarTags">SysvarTags</A>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#top_estack">top_estack</A></B><DD>Points to the top of the expression stack.</DL>
<H3><U>Constants</U></H3>
<DL INDENT="20"><DT><B><A HREF="alloc.html#H_NULL">H_NULL</A></B><DD>A null-handle value.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NULL_INDEX">NULL_INDEX</A></B><DD>Describes an empty expression stack index.</DL>
<H3><U>Predefined Types</U></H3>
<DL INDENT="20"><DT><B><A HREF="timath.html#bcd">bcd</A></B><DD>Represents the internal organization of floating point numbers
in the format recognized by the TIOS.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="alloc.html#Bool">Bool</A></B><DD>An enumeration to describe true or false values.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#CESI_Callback_t">CESI_Callback_t</A></B><DD>Represents a pointer to a CESI callback function.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#CESI">CESI</A></B><DD>Represents a pointer to a constant expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cmd_info">cmd_info</A></B><DD>Structure containing information about AMS EStack command tags (<A HREF="#InstructionTags">InstructionTags</A>).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ESI_Callback_Int_t">ESI_Callback_Int_t</A></B><DD>Represents a pointer to an ESI callback function with integer extensions.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ESI_Callback_t">ESI_Callback_t</A></B><DD>Represents a pointer to an ESI callback function.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ESI">ESI</A></B><DD>Represents an index of a value on the TIOS expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ESQ">ESQ</A></B><DD>Represents a quantum within an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#EStackDisplacement">EStackDisplacement</A></B><DD>Type used for representing difference of two <A HREF="#ESI">ESI</A> pointers.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#EStackIndex">EStackIndex</A></B><DD>Represents an index of a value on the TIOS expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ExtTags">ExtTags</A></B><DD>An enumeration to describe extra types of entries on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FLOATTABIndexes">FLOATTABIndexes</A></B><DD>An enumeration for describing the valid indexes for <A HREF="#FLOATTAB">FLOATTAB</A>.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="alloc.html#HANDLE">HANDLE</A></B><DD>Represents a handle associated with an allocated memory block.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#InstructionTags">InstructionTags</A></B><DD>An enumeration to describe types of instructions on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#MULTI_EXPR">MULTI_EXPR</A></B><DD>Describes a multi-expression, which is processed as a separate expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Quantum">Quantum</A></B><DD>Represents a quantum within an expression.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="graph.html#SCR_RECT">SCR_RECT</A></B><DD>A scructure for defining a rectangular area.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="graph.html#SCR_STATE">SCR_STATE</A></B><DD>A structure for saving the state of the graphics system.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#SYM_STR">SYM_STR</A></B><DD>Represents a pointer to the terminating zero byte of a string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#sysvar_info">sysvar_info</A></B><DD>Structure containing information about AMS EStack tags (<A HREF="#SysvarTags">SysvarTags</A>).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#SysvarTags">SysvarTags</A></B><DD>An enumeration to describe types of system variable entries on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#tag_info">tag_info</A></B><DD>Structure containing information about AMS EStack tags (<A HREF="#Tags">Tags</A>, <A HREF="#ExtTags">ExtTags</A>).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#Tags">Tags</A></B><DD>An enumeration to describe types of entries on the expression stack.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="timath.html#ti_float">ti_float</A></B><DD>An alias for the standard ANSI float type.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#TokenizeSymNameFlags">TokenizeSymNameFlags</A></B><DD>Contains flags specifying how a symbol name is tokenized.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="wingraph.html#WINDOW">WINDOW</A></B><DD>The main window-describing structure.</DL>
<P>See also: <A HREF="args.html">args.h</A></P>
<HR>
<H3><A NAME="add_to_top"><U>add_to_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> add_to_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Adds a value to the expression on the top of the EStack.</B></P>

<P>add_to_top adds the expression pointed to by <I>ptr</I> to the expression currently at
the top of the EStack and stores the result to the top of the EStack,
in place of the expression that was added to.</P>

<P>See also: <A HREF="#subtract_from_top">subtract_from_top</A>, <A HREF="#negate_top">negate_top</A>, <A HREF="#add1_to_top">add1_to_top</A>, <A HREF="#subtract1_from_top">subtract1_from_top</A></P>
<HR>
<H3><A NAME="add1_to_top"><U>add1_to_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> add1_to_top (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Adds 1 to the top of the EStack.</B></P>

<P>add1_to_top adds 1 (or 1.0) to the value on the top of the EStack. This routine basically calls
<A HREF="#add_to_top">add_to_top</A> with "1" as the pointed-to value.</P>

<P>See also: <A HREF="#add_to_top">add_to_top</A>, <A HREF="#subtract1_from_top">subtract1_from_top</A></P>
<HR>
<H3><A NAME="all_tail"><U>all_tail</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> all_tail (<A HREF="#CESI_Callback_t">CESI_Callback_t</A> f, <A HREF="#ESI">ESI</A> start_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether all elements in the list have some property.</B></P>

<P>all_tail is similar to <A HREF="#map_tail">map_tail</A>, but callback function <I>f</I> is
not void. It needs to return a Boolean value (<A HREF="alloc.html#Bool">TRUE</A> or <A HREF="alloc.html#Bool">FALSE</A>).
If <I>f</I> returns <A HREF="alloc.html#Bool">FALSE</A>, any further processing of the list tail will
be stopped, even if <A HREF="#END_TAG">END_TAG</A> is not reached yet. The result of all_tail is
the last value returned from <I>f</I>. In other words, it returns <A HREF="alloc.html#Bool">TRUE</A> if
and only if the callback function <I>f</I> returns <A HREF="alloc.html#Bool">TRUE</A> for each expression
in the tail of expressions indexed by <I>element_ptr</I>.
<BR><BR>
all_tail is very useful to check whether all elements of a list possess some property. Suppose
that you defined the following function which checks whether an entry on the expression stack is a positive
integer:</P>
<PRE>short is_positive_integer (ESI ptr)
{
  return (*ptr == POSINT_TAG);
}
</PRE>
<P>and suppose that <I>start_ptr</I> points to the first element of the list (one byte below
<A HREF="#LIST_TAG">LIST_TAG</A>). Then, you can use the following call to check whether all
elements of the lists are positive integers:</P>
<PRE>are_all_positive_integers = all_tail (is_positive_integer, <I>start_ptr</I>);
</PRE>

<HR>
<H3><A NAME="and_onto_top"><U>and_onto_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> and_onto_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Logical ANDs an expression onto the EStack.</B></P>

<P>and_onto_top replaces the top expression on the EStack with the logical AND of itself and
the expression pointed to by <I>ptr</I>.</P>

<P>See also: <A HREF="#or_onto_top">or_onto_top</A></P>
<HR>
<H3><A NAME="any_tail"><U>any_tail</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> any_tail (<A HREF="#CESI_Callback_t">CESI_Callback_t</A> f, <A HREF="#ESI">ESI</A> start_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether any element in the list has some property.</B></P>

<P>any_tail is similar like <A HREF="#all_tail">all_tail</A>, except further processing of
the list will be stopped if <I>f</I> returns <A HREF="alloc.html#Bool">TRUE</A> instead
of <A HREF="alloc.html#Bool">FALSE</A>. In other words, it returns <A HREF="alloc.html#Bool">TRUE</A> if
and only if the callback function <I>f</I> returns <A HREF="alloc.html#Bool">TRUE</A> for at least
one expression in the tail of expressions indexed by <I>element_ptr</I>.
any_tail is very useful to check whether any element of a list
possesses some property. Assuming the same assumptions as in the example given with
<A HREF="#all_tail">all_tail</A>, the following call will check whether any element of
the list is a positive integer:</P>
<PRE>is_any_positive_integer = any_tail (is_positive_integer, <I>start_ptr</I>);
</PRE>

<HR>
<H3><A NAME="are_expressions_identical"><U>are_expressions_identical</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> are_expressions_identical (<A HREF="#CESI">CESI</A> ptr1, <A HREF="#CESI">CESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Checks whether two expressions are identical.</B></P>

<P>are_expressions_identical returns <A HREF="alloc.html#Bool">TRUE</A> if expressions pointed to by
<I>ptr1</I> and <I>ptr2</I> are syntactically identical, else returns <A HREF="alloc.html#Bool">FALSE</A>.
At the moment, I am not exactly sure what is the criteria for equivalence. I only know
that a+b and b+a are not identical for example. And, floats are never identical to
rational numbers. So far, I only know that this function
surely returns <A HREF="alloc.html#Bool">TRUE</A> when two expressions are absolutely identical.
But, if this is the only case of equivalence, this routine should be very simple. But it
is not. It is very complicated and recursive, so I am really not sure which pairs of
expressions may be treated as "identical". Any additional info is welcomed.</P>

<HR>
<H3><A NAME="can_be_approxed"><U>can_be_approxed</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> can_be_approxed (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">short</A></B> Complex);</TD></TR></TABLE></P>
<P><B>Checks whether an expression can be approximated to a number.</B></P>

<P>can_be_approxed returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> can be approximated to a number (including transfinite ones) or a list of
numbers (such expression are for example
<CODE>'ln(2+sin(1))/5'</CODE>, <CODE>'1/0'</CODE> or
<CODE>'x^2+1-x*x'</CODE>), else returns <A HREF="alloc.html#Bool">FALSE</A>.
<I>Complex</I> is a Boolean parameter:
if it is <A HREF="alloc.html#Bool">TRUE</A>, complex results will be allowed, but if it
is <A HREF="alloc.html#Bool">FALSE</A>, complex results will be treated as "cannot be approxed".
<BR><BR>
<B>Note:</B> can_be_approxed performs much detailed investigation than functions
<A HREF="#likely_approx_to_number">likely_approx_to_number</A> and
<A HREF="#likely_approx_to_complex_number">likely_approx_to_complex_number</A>.</P>

<HR>
<H3><A NAME="check_estack_size"><U>check_estack_size</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> check_estack_size (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> Size);</TD></TR></TABLE></P>
<P><B>Checks if there is enough room on the expression stack.</B></P>

<P>check_estack_size checks if there is enough room to push <I>Size</I> bytes to
the expression stack. If there is not enough space, it tries to enlarge the stack
(using <A HREF="alloc.html#HeapRealloc">HeapRealloc</A>) to make additional space.
It throws an error if the requirement cannot be satisfied. Note that
all "push_..." functions call this routine, so all of them may throw an error if
there is not enough memory.</P>

<HR>
<H3><A NAME="compare_complex_magnitudes"><U>compare_complex_magnitudes</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> compare_complex_magnitudes (<A HREF="#CESI">CESI</A> ptr1, <A HREF="#CESI">CESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Compares magnitudes of two complex number entries on the expression stack.</B></P>

<P>compare_complex_magnitudes compares two complex number entries (which may be real also)
on the expression stack pointed to by
<I>ptr1</I> and <I>ptr2</I>, and returns a value which is</P>
<UL>
<LI><P>&lt; 0 if the magnitude of the number pointed to by <I>ptr1</I> is less than the magnitude of the number pointed to by <I>ptr2</I></P></LI>
<LI><P>== 0 if the magnitude of the number pointed to by <I>ptr1</I> is the same as the magnitude of the number pointed to by <I>ptr2</I></P></LI>
<LI><P>&gt; 0 if the magnitude of the number pointed to by <I>ptr1</I> is greater than the magnitude of the number pointed to by <I>ptr2</I></P></LI>
</UL>

<HR>
<H3><A NAME="compare_expressions"><U>compare_expressions</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> compare_expressions (<A HREF="#CESI">CESI</A> ptr1, <A HREF="#CESI">CESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Compares two expressions.</B></P>

<P>compare_expressions returns 0 if two expressions pointed to by <I>ptr1</I> and <I>ptr2</I>
are equal in the sense that they have the same structure, variables, function names, and
numbers that compare equal. A float and a rational number compare equal
if converting the rational number to a float produces an identical number.
If the expressions are not, it returns a non-zero value which may be positive or negative
(more precise, 1 or -1). Positive result means that the
expression pointed to by <I>ptr1</I> is "more main" that the expression pointed to by <I>ptr2</I>,
and negative result means "less main". Principally, variables are more main than symbolic constants
such as <B>pi</B>, which are more main than numbers. In expressions such
as <CODE>'expand(...,var)'</CODE> or <CODE>'Integral(...,var)'</CODE>, a variable <I>var</I>
is "most main". Otherwise, the 26 Roman one-letter variables order
r&gt;&gt;s&gt;&gt;...&gt;&gt;z&gt;&gt;a&gt;&gt;b&gt;&gt;...&gt;&gt;q ('&gt;&gt;' means "more main"),
which order more main than all other variables, which order alphabetically. Functions and operators
are typically ordered by recursively comparing their first arguments, with ties broken by
comparing their second arguments, etc. then finally comparing the operators or functions, if
necessary. For example:</P>
<UL>
<LI><P>-2.0 and -2 are equal;</P></LI>
<LI><P>-2.0 is less main than -1;</P></LI>
<LI><P><B>pi</B> is more main than 4;</P></LI>
<LI><P><CODE>x</CODE> is more main than 4;</P></LI>
<LI><P><CODE>x</CODE> is less main than <CODE>r</CODE>;</P></LI>
<LI><P><CODE>x</CODE> is more main than <CODE>ln(y)</CODE>;</P></LI>
<LI><P><CODE>x</CODE> is less main than <CODE>ln(x)</CODE>.</P></LI>
</UL>
<P><B>Note:</B> Both expressions should be in internal canonic form
(see <A HREF="#push_internal_simplify">push_internal_simplify</A>),
else this function may not work as expected.</P>

<HR>
<H3><A NAME="compare_Floats"><U>compare_Floats</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> compare_Floats (<A HREF="#CESI">CESI</A> ptr1, <A HREF="#CESI">CESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Compares two floating point entries on the expression stack.</B></P>

<P>compare_Floats compares two floating point entries on the expression stack pointed to by
<I>ptr1</I> and <I>ptr2</I>, and returns a value which is</P>
<UL>
<LI><P>&lt; 0 if the number pointed to by <I>ptr1</I> is less than the number pointed to by <I>ptr2</I></P></LI>
<LI><P>== 0 if the number pointed to by <I>ptr1</I> is the same as the number pointed to by <I>ptr2</I></P></LI>
<LI><P>&gt; 0 if the number pointed to by <I>ptr1</I> is greater than the number pointed to by <I>ptr2</I></P></LI>
</UL>
<P>So, this function is similar like <A HREF="timath.html#fcmp">fcmp</A>, except the arguments are
different (<A HREF="timath.html#fcmp">fcmp</A> uses floating point arguments, and compare_Floats
uses pointers to floating point entries on the expression stack).</P>

<HR>
<H3><A NAME="CreateEmptyList"><U>CreateEmptyList</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="alloc.html#HANDLE">HANDLE</A> CreateEmptyList (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Creates a MULTI_EXPR containing an empty list and returns its handle.</B></P>

<P>This function throws an error if there is not enough memory to allocate the handle.</P>

<HR>
<H3><A NAME="delete_between"><U>delete_between</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> delete_between (<A HREF="#ESI">ESI</A> ptr1, <A HREF="#ESI">ESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Deletes a sequence of bytes from the expression stack.</B></P>

<P>delete_between deletes a sequence of bytes between <I>ptr1</I> and <I>ptr2</I>
(more precise, starting at <I>ptr1</I>+1 and ending at <I>ptr2</I>) from the
expression stack. It does this by moving the memory from <I>ptr2</I>+1 to
<A HREF="#top_estack">top_estack</A> downwards (using <A HREF="mem.html#memmove">memmove</A>)
and adjusting <A HREF="#top_estack">top_estack</A>. This routine assumes that
<I>ptr1</I> and <I>ptr2</I> really point to parts of the expression stack
and that <I>ptr2</I> is above <I>ptr1</I>, otherwise the result is unpredictable.</P>

<HR>
<H3><A NAME="delete_expression"><U>delete_expression</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> delete_expression (<A HREF="#ESI">ESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Deletes an expression from the expression stack.</B></P>

<P>delete_expression deletes an entry on the expression stack pointed to by
<I>ptr</I> (it needs to point to the entry tag) from the stack. The
entry need not be a simple entity; it may be a complex symbolic
expression too. This is achieved by calling
<A HREF="#next_expression_index">next_expression_index</A> and
<A HREF="#delete_between">delete_between</A>.</P>

<HR>
<H3><A NAME="deleted_between"><U>deleted_between</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> deleted_between (<A HREF="#ESI">ESI</A> ptr1, <A HREF="#ESI">ESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Deletes a sequence of bytes from the expression stack.</B></P>

<P>deleted_between acts like <A HREF="#delete_between">delete_between</A>, but it also
returns a number of deleted bytes. Note that <A HREF="#delete_between">delete_between</A> calls
<A HREF="mem.html#memmove">memmove</A> for moving memory after <I>ptr2</I>, but
deleted_between uses an embedded loop sequence for the same task. I don't know why
these two routines use different methods: as I can see, the final effect is the
same. Maybe I am wrong?</P>

<HR>
<H3><A NAME="deleted_expression"><U>deleted_expression</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> deleted_expression (<A HREF="#ESI">ESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Deletes an expression from the expression stack.</B></P>

<P>deleted_expression acts like <A HREF="#delete_expression">delete_expression</A>, but it also
returns a number of deleted bytes. It calls <A HREF="#deleted_between">deleted_between</A>
instead of <A HREF="#delete_between">delete_between</A>.</P>

<HR>
<H3><A NAME="did_push_cnvrt_Float_to_integer"><U>did_push_cnvrt_Float_to_integer</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> did_push_cnvrt_Float_to_integer (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Pushes a floating point entry converted to an integer, but only if it is an exact whole number.</B></P>

<P>did_push_cnvrt_Float_to_integer is a subroutine used in
<A HREF="#push_cnvrt_integer_if_whole_nmb">push_cnvrt_integer_if_whole_nmb</A>. It assumes
that <I>ptr</I> points to a floating point entry. If it is a whole number
(including big numbers too), did_push_cnvrt_Float_to_integer pushes the number converted to a
tagged integer to the expression
stack, and returns <A HREF="alloc.html#Bool">TRUE</A>, otherwise it does nothing and returns
<A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="display_statements"><U>display_statements</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="alloc.html#HANDLE">HANDLE</A> display_statements (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> Newlines, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> FullPrec);</TD></TR></TABLE></P>
<P><B>Converts tokenized expressions or TI-Basic statements to the printable form.</B></P>

<P>display_statements converts the expression (or a group of tokenized TI-Basic statements)
pointed to by <I>ptr</I> from RPN form to the
standard printable ("algebraic") form, and returns a handle to
the memory block where the converted string is stored (you don't need to allocate anything by
yourself, this function will do it instead; note that this routine may cause heap compression).
It will return <A HREF="alloc.html#H_NULL">H_NULL</A> if memory is full.
<I>Newline</I> is a Boolean flag: when it is
nonzero, all newline characters will be replaced with ':', otherwise they will remain intact.
<I>FullPrec</I> is also a Boolean flag: when it is non-zero,
all floating point values will be converted using the maximal precision (14 digits), else
current precision settings (from TI-Basic MODE dialog) will be used. Here is an illustrative
example for usage of this command (take a look at the "Integrate" example as well):</P>
<PRE>push_parse_text ("expand((x+1)(x+2)(x+3))");
NG_rationalESI (top_estack);
handle = display_statements (top_estack, 1, 1);
printf_xy (0, 40, "%s", HeapDeref (handle));
HeapFree (handle);
</PRE>
<P>See <A HREF="#push_parse_text">push_parse_text</A>, <A HREF="#NG_rationalESI">NG_rationalESI</A>,
<A HREF="alloc.html#HeapDeref">HeapDeref</A> and <A HREF="alloc.html#HeapFree">HeapFree</A>
to understand how this example works.
<BR><BR>
<B>Note:</B> Handles returned by <I>display_statements</I> aren't locked so any heap
compression will move the block associated with the handle. Therefore it is safer
to lock them using <A HREF="alloc.html#HLock">HLock</A> and
<A HREF="alloc.html#HeapUnlock">HeapUnlock</A> than to just dereference them
using <A HREF="alloc.html#HeapDeref">HeapDeref</A>.
<BR><BR>
display_statements will always convert expressions into the "canonic printing (external) form".
For example, both x*3 and 3*x will be displayed as 3*x, x*y^(-1) will be displayed as x/y etc.
<BR><BR>
<B>Note:</B> Although display_statements is very similar to <A HREF="#Parse1DExpr">Parse1DExpr</A>
and both of them may usually be used for the same purposes, display_statements is used in TIOS for
printing TI-Basic statements (from programs) and for the detokenization (in <A HREF="#NG_RPNToText">NG_RPNToText</A>),
and <A HREF="#Parse1DExpr">Parse1DExpr</A> is used for printing expressions.</P>

<HR>
<H3><A NAME="divide_top"><U>divide_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> divide_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Divides the expression onto the EStack.</B></P>

<P>divide_top divides the expression currently at the top of the EStack by
the expression pointed to by <I>ptr</I>, and stores the result to the top of
the EStack, in place of the expression that was divided by.</P>

<P>See also: <A HREF="#times_top">times_top</A></P>
<HR>
<H3><A NAME="estack_number_to_Float"><U>estack_number_to_Float</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> estack_number_to_Float (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Converts entry on the expression stack to floating point number.</B></P>

<P>estack_number_to_Float converts an entry on the expression stack pointed to by
<I>ptr</I> (it needs to point to the entry tag) to a floating point value
and returns the result. Note that the entry need not be represented by
<A HREF="#FLOAT_TAG">FLOAT_TAG</A>: it also may be represented by an integer, or
by a fraction. This function does not remove the entry from the stack.
<BR><BR>
<B>Note:</B> estack_number_to_Float will throw an error if the entry on the stack is not
a floating point number, a fraction or an integer, so you will need to use
<A HREF="error.html#ER_catch">ER_catch</A> to catch eventual errors.</P>

<HR>
<H3><A NAME="estack_to_short"><U>estack_to_short</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> estack_to_short (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">short</A></B> *value_ptr);</TD></TR></TABLE></P>
<P><B>Converts entry on the expression stack to signed short integer.</B></P>

<P>estack_to_short converts an entry on the expression stack pointed to by
<I>ptr</I> (it needs to point to the entry tag) to a signed short integer
and stores the result in the location pointed to by <I>value_ptr</I>.
Note that the entry need not be represented by <A HREF="#POSINT_TAG">POSINT_TAG</A>
or <A HREF="#NEGINT_TAG">NEGINT_TAG</A>: it also may be represented by
<A HREF="#FLOAT_TAG">FLOAT_TAG</A> for example, but the value itself needs to be a whole
number. This function does not remove the entry from the stack.
<BR><BR>
estack_to_short returns 1 if the conversion was successful, 0 in the case of overflow
(in this case the stored result will be -32768 or 32767 depending of the direction
of the overflow), and -1 if the entry cannot be represented as a whole number (in
this case the result is undefined).</P>

<HR>
<H3><A NAME="estack_to_ushort"><U>estack_to_ushort</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> estack_to_ushort (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> *value_ptr);</TD></TR></TABLE></P>
<P><B>Converts entry on the expression stack to unsigned short integer.</B></P>

<P>estack_to_ushort converts an entry on the expression stack pointed to by
<I>ptr</I> (it needs to point to the entry tag) to a unsigned short integer
and stores the result in the location pointed to by <I>value_ptr</I>.
Note that the entry need not be represented by <A HREF="#POSINT_TAG">POSINT_TAG</A>
or <A HREF="#NEGINT_TAG">NEGINT_TAG</A>: it also may be represented by
<A HREF="#FLOAT_TAG">FLOAT_TAG</A> for example, but the value itself needs to be a whole
number. This function does not remove the entry from the stack.
<BR><BR>
estack_to_short returns 1 if the conversion was successful, 0 in the case of overflow
(in this case the stored result will be 0 or 65535 depending of the direction of the
overflow), and -1 if the entry cannot be represented as a whole number (in this case
the result is undefined).</P>

<HR>
<H3><A NAME="ESTACK"><U>ESTACK</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> ESTACK(idx) (*(idx))</TD></TR></TABLE></P>
<P><B>Reads the expression stack at a specific index.</B></P>

<P>The ESTACK macro can be used to read the expression stack at the index <I>idx</I>.
It simply dereferences <I>idx</I>, since the <A HREF="#ESI">ESI</A> and
<A HREF="#CESI">CESI</A> types are in fact pointers to quantums of type
<A HREF="#ESQ">ESQ</A>.</P>

<HR>
<H3><A NAME="factor_base_index"><U>factor_base_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> factor_base_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the base of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#POW_TAG">POW_TAG</A>, which is a case when it
points to an expression of form <I>base</I>&nbsp;^&nbsp;<I>exponent</I>
factor_base_index returns the pointer to <I>base</I>. If <I>ptr</I> does not point to the
<A HREF="#POW_TAG">POW_TAG</A>, factor_base_index returns <I>ptr</I> (i.e. the pointer to the expression itself).</P>

<HR>
<H3><A NAME="factor_exponent_index"><U>factor_exponent_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> factor_exponent_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the exponent of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#POW_TAG">POW_TAG</A>, which is a case when it
points to an expression of form <I>base</I>&nbsp;^&nbsp;<I>exponent</I>
factor_exponent_index returns the pointer to <I>exponent</I>. If <I>ptr</I> does not
point to the <A HREF="#POW_TAG">POW_TAG</A>, factor_exponent_index returns
a pointer to a simple expression which consists only of the number 1 (floating point or integer,
depending on whether the approximation mode is active or not).</P>

<HR>
<H3><A NAME="gcd_exact_whole_Floats"><U>gcd_exact_whole_Floats</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> gcd_exact_whole_Floats (<A HREF="#CESI">CESI</A> ptr1, <A HREF="#CESI">CESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Finds the greatest common divisor of two floating point entries.</B></P>

<P>gcd_exact_whole_Floats finds the greatest common divisor of two floating point entries
pointed to by <I>ptr1</I> and <I>ptr2</I> and returns the result (the result is a garbage
if <I>ptr1</I> or <I>ptr2</I> doesn't point to floating point entries).
<BR><BR>
<B>Note:</B> Although the name of the function suggests that both entries need to be whole
numbers, this is not true. This function, in fact, returns "generalized" GCD of two
numbers <I>x</I> and <I>y</I> which is defined as the greatest number <I>z</I>
which has a property that both <I>x</I>/<I>z</I> and
<I>y</I>/<I>z</I> are whole numbers.</P>

<HR>
<H3><A NAME="get_key_ptr"><U>get_key_ptr</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#int">char</A></B> *get_key_ptr (<A HREF="#ESQ">ESQ</A> Tag1, <A HREF="#ESQ">ESQ</A> Tag2);</TD></TR></TABLE></P>
<P><B>Converts a tag code to a tag name.</B></P>

<P>get_key_ptr returns a static pointer to the string which represents the name of the
tag <I>Tag1</I>. <I>Tag2</I> is used only if <I>Tag1</I> is an extended tag
(i.e. <A HREF="#EXT_TAG">EXT_TAG</A>, <A HREF="#EXT_INSTR_TAG">EXT_INSTR_TAG</A> or <A HREF="#EXT_SYSTEM_TAG">EXT_SYSTEM_TAG</A>)
which can't be fully represented using only one byte.
<BR><BR>
If the tag corresponds to a function, AMS 1.xx does not append
'(' at the end of the string, but AMS 2.xx does. Thus, anyone who
intends to use this function for function tokens should use extra
code to handle both cases.</P>

<HR>
<H3><A NAME="GetValue"><U>GetValue</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> GetValue (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">long</A></B> low, <B><A HREF="keywords.html#short">long</A></B> high);</TD></TR></TABLE></P>
<P><B>Converts entry on the expression stack to short integer and checks whether it is in a given range.</B></P>

<P>GetValue converts an entry on the expression stack pointed to by <I>ptr</I> (it needs
to point on the entry tag) to a short integer value using
<A HREF="#estack_to_short">estack_to_short</A> or <A HREF="#estack_to_ushort">estack_to_ushort</A>,
depending on the sign of <I>low</I>. Then, a "Domain Error" is thrown if the value
is smaller than <I>low</I> or greater than <I>high</I>, otherwise the value will be
returned as the result of the function. It will also throw a "Data type" error if the entry
cannot be represented as an integer.</P>

<HR>
<H3><A NAME="HToESI"><U>HToESI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> HToESI (<A HREF="alloc.html#HANDLE">HANDLE</A> Handle);</TD></TR></TABLE></P>
<P><B>Converts a handle to an expression stack index.</B></P>

<P>HToESI is a simple but very useful routine. It returns a pointer to the last
byte of the <A HREF="#MULTI_EXPR">MULTI_EXPR</A> structure referenced
by <I>Handle</I>. Therefore it allows for the use of TIOS variables as input
data in expression stack routines. Assuming that <I>Handle</I>
is a handle of a TIOS variable which contains an expression, HToESI will return a pointer
to the tag of the expression contained in the variable. Such a pointer may be used in
any routine which needs an argument of type <A HREF="#CESI">CESI</A>, like
<A HREF="#NG_approxESI">NG_approxESI</A>, etc. (except in functions which manipulate
the actual memory space on the expression stack, like
<A HREF="#delete_between">delete_between</A>).
In fact, HToESI simply dereferences <I>Handle</I> and adds the size plus 1 to the address.
It also may be used to determine the type of a TIOS variable, because after execution the
result points to the data type tag of the variable data.
<BR><BR>
<B>Note:</B> If the handle is not locked, HToESI must be called again after a heap compression
since the block of memory associated with the handle may have moved.</P>

<HR>
<H3><A NAME="im_index"><U>im_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> im_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the imaginary part of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#COMPLEX_TAG">COMPLEX_TAG</A>
(i.e. if the expression is complex), im_index returns the pointer
to the imaginary part of the expression. If <I>ptr</I> does not point to the
<A HREF="#COMPLEX_TAG">COMPLEX_TAG</A> (i.e. if the expression is real),
im_index returns a pointer to a simple zero expression, i.e. expression which
consists only of the number 0 (floating point or integer,
depending on whether the approximation mode is active or not).
<BR><BR>
<B>Note:</B> The expression should be in internal canonic form
(see <A HREF="#push_internal_simplify">push_internal_simplify</A>), else this function
is not reliable.</P>

<HR>
<H3><A NAME="index_below_display_expression_aux"><U>index_below_display_expression_aux</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> index_below_display_expression_aux (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Main routine for detokenizing.</B></P>

<P>index_below_display_expression_aux is main (recursive) routine for detokenizing.
As it is just an auxiliary routine used in <A HREF="#display_statements">display_statements</A>
and <A HREF="#Parse1DExpr">Parse1DExpr</A>, it shouldn't need to be used directly.</P>

<HR>
<H3><A NAME="index_main_var"><U>index_main_var</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> index_main_var (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Searches an expression for a first encountered variable.</B></P>

<P>index_main_var returns the index of the first encountered variable in the expression
pointed to by <I>ptr</I>. More precise, it repeatedly decreases value of <I>ptr</I> by one
until the tag of a variable, a number or a symbolic constant (like <B>pi</B>) is
reached. As expressions are usually organized in "internal canonic" form (see notes given with
description of <A HREF="#numeric_factor_index">numeric_factor_index</A>) in which all
constants are always "below" variables on the stack, a variable will always be reached
before any constant, except if there are not any variables in the expression
(in this case, a pointer to a constant is returned). Obviously, this function is not
reliable if the expression is not in the internal canonic form
(see <A HREF="#push_internal_simplify">push_internal_simplify</A>).</P>

<HR>
<H3><A NAME="index_numeric_term"><U>index_numeric_term</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> index_numeric_term (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Searches terms in the expression for a numeric term.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#ADD_TAG">ADD_TAG</A>, which is a case when it
points to an expression of form <I>term1</I>&nbsp;+&nbsp;<I>term2</I>&nbsp;+&nbsp;<B>...</B>
(i.e. if the expression is a sum of simpler terms), index_numeric_term returns the pointer
to the eventual numeric term in the expression. If the expression is a number, index_numeric_term
returns <I>ptr</I> (i.e. the pointer to the expression itself). If <I>ptr</I> does not point to
the <A HREF="#ADD_TAG">ADD_TAG</A> (i.e. if the expression is not a sum of simpler terms),
or if there are not any numeric terms in the expression, index_numeric_factor returns
a pointer to a simple expression which consists only of the number 0 (floating point or integer,
depending on whether the approximation mode is active or not).
<BR><BR>
<B>Note:</B> This function is not implemented to be very universal. TIOS always "reorganizes" expressions
on such way that numeric terms are at the beginning of the expression (for example, x+3 will be reorganized
into 3+x, although it will be displayed just reversed, i.e. as x+3), and this function assumes that the
expression is organized on such way. In other words, it must be in internal canonic form (such
expressions always have at most one term with a numeric tag, in which case it is the deepest
term). Fortunately,
all expressions in argument are always in internal canonic form. However, this is not true after
<A HREF="#push_parse_text">push_parse_text</A> function, nor after an evaluation using
<A HREF="#NG_rationalESI">NG_rationalESI</A> or <A HREF="#NG_approxESI">NG_approxESI</A>. In
other words, results of these commands are not always "correctly" organized. To force converting
an expression to the internal canonic form, always call
<A HREF="#push_internal_simplify">push_internal_simplify</A> after usage of any of the functions
mentioned above.</P>

<HR>
<H3><A NAME="index_of_lead_base_of_lead_term"><U>index_of_lead_base_of_lead_term</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> index_of_lead_base_of_lead_term (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the base of the lead term of an expression.</B></P>

<P>index_of_lead_base_of_lead_term first calls <A HREF="#lead_term_index">lead_term_index</A>,
then apply <A HREF="#lead_base_index">lead_base_index</A> on the result.
So, it returns the pointer to the base of the lead factor of the first term of
the expression pointed to by <I>ptr</I>.</P>

<HR>
<H3><A NAME="init_list_indices"><U>init_list_indices</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> *init_list_indices (<A HREF="#ESI">ESI</A> *indices, <A HREF="#CESI">CESI</A> expr);</TD></TR></TABLE></P>
<P><B>Computes and stores the indices of the elements of a list.</B></P>

<P>init_list_indices stores the index of the first element to <I>indices</I>, then it
repeatedly calls <A HREF="#next_expression_index">next_expression_index</A> and
stores the result to <I>indices</I> until <A HREF="#END_TAG">END_TAG</A> is reached.
<BR>
<I>expr</I> is assumed to point to a <A HREF="#LIST_TAG">LIST_TAG</A>.
init_list_indices returns <I>indices</I>.
<BR><BR>
Here is an example (called "List elements") which displays the list elements as returned by
init_list_indices: </P>
<PRE>// Shows how the init_list_indices function works.

#define USE_TI89              // Compile for TI-89
#define USE_TI92PLUS          // Compile for TI-92 Plus
#define USE_V200              // Compile for V200

#define MIN_AMS 101           // Compile for AMS 1.01 or higher
#define SAVE_SCREEN           // Save/Restore LCD Contents

#include &lt;tigcclib.h&gt;         // Include All Header Files

// The {1, 0, -1} list.
static const ESQ list_1_0_minus1[10] = {END_TAG, 0x01, 0x01, NEGINT_TAG, 0x00, POSINT_TAG, 0x01, 0x01, POSINT_TAG, LIST_TAG};

// Main Function
void _main(void)
{
  ESI elements[3];
  HANDLE h;

  TRY
    ClrScr();
    DrawStr (0, 0, &quot;The elements of list&quot;, A_NORMAL);
    DrawStr (0, 20, &quot;are&quot;, A_NORMAL);
    // Print whole expression.
    h = Parse1DExpr (list_1_0_minus1 + 9, FALSE, 0);
    DrawStr(0, 10, HeapDeref(h), A_NORMAL);
    HeapFree(h);

    // Get the individual constituents of the expression and print them.
    init_list_indices(elements, list_1_0_minus1 + 9);
    h = Parse1DExpr (elements[0], FALSE, 0);
    DrawStr(0, 30, HeapDeref(h), A_NORMAL);
    HeapFree(h);
    h = Parse1DExpr (elements[1], FALSE, 0);
    DrawStr(0, 40, HeapDeref(h), A_NORMAL);
    HeapFree(h);
    h = Parse1DExpr (elements[2], FALSE, 0);
    DrawStr(0, 50, HeapDeref(h), A_NORMAL);
    HeapFree(h);
  ONERR
    DrawStr (0, 70, &quot;Error!&quot;, A_NORMAL);
  ENDTRY
  GKeyIn (NULL, 0);
}
</PRE>

<HR>
<H3><A NAME="init_matrix_indices"><U>init_matrix_indices</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> *init_matrix_indices (<A HREF="#ESI">ESI</A> *indices, <A HREF="#CESI">CESI</A> expr);</TD></TR></TABLE></P>
<P><B>Computes and stores the indices of the elements of a matrix.</B></P>

<P>init_matrix_indices stores the index of the first element of the first row to <I>indices</I>, then
it repeatedly calls <A HREF="#next_expression_index">next_expression_index</A> and
stores the result to <I>indices</I> until the <A HREF="#END_TAG">END_TAG</A>
for the whole matrix is reached.<BR>
<I>expr</I> is assumed to point to a double <A HREF="#LIST_TAG">LIST_TAG</A>.
init_matrix_indices returns <I>indices</I>.
<BR><BR>
Here is an example (called "Matrix elements") which displays the matrix elements as returned by
init_matrix_indices: </P>
<PRE>// Shows how the init_matrix_indices function works.

#define USE_TI89              // Compile for TI-89
#define USE_TI92PLUS          // Compile for TI-92 Plus
#define USE_V200              // Compile for V200

#define MIN_AMS 101           // Compile for AMS 1.01 or higher
#define SAVE_SCREEN           // Save/Restore LCD Contents

#include &lt;tigcclib.h&gt;         // Include All Header Files

// The [1, 0; 0, 1] matrix.
static const ESQ matrix_identity_2[16] = {END_TAG, END_TAG, 0x01, 0x01, POSINT_TAG, 0x00, POSINT_TAG, LIST_TAG, END_TAG, 0x00, POSINT_TAG, 0x01, 0x01, POSINT_TAG, LIST_TAG, LIST_TAG};

// Main Function
void _main(void)
{
  ESI elements[4];
  HANDLE h;

  TRY
    ClrScr();
    DrawStr (0, 0, &quot;The elements of matrix&quot;, A_NORMAL);
    DrawStr (0, 20, &quot;are&quot;, A_NORMAL);
    // Print whole expression.
    h = Parse1DExpr (matrix_identity_2 + 15, FALSE, 0);
    DrawStr(0, 10, HeapDeref(h), A_NORMAL);
    HeapFree(h);

    // Get the individual constituents of the expression and print them.
    init_matrix_indices(elements, matrix_identity_2 + 15);
    h = Parse1DExpr (elements[0], FALSE, 0);
    DrawStr(0, 30, HeapDeref(h), A_NORMAL);
    HeapFree(h);
    h = Parse1DExpr (elements[1], FALSE, 0);
    DrawStr(0, 40, HeapDeref(h), A_NORMAL);
    HeapFree(h);
    h = Parse1DExpr (elements[2], FALSE, 0);
    DrawStr(0, 50, HeapDeref(h), A_NORMAL);
    HeapFree(h);
    h = Parse1DExpr (elements[3], FALSE, 0);
    DrawStr(0, 60, HeapDeref(h), A_NORMAL);
    HeapFree(h);
  ONERR
    DrawStr (0, 70, &quot;Error!&quot;, A_NORMAL);
  ENDTRY
  GKeyIn (NULL, 0);
}
</PRE>

<HR>
<H3><A NAME="integer_non_unknown"><U>integer_non_unknown</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> integer_non_unknown (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is an integer.</B></P>

<P>Returns 1 if the expression pointed to by <I>ptr</I> is an integer
or floating-point value; returns -1 for constants like <B><FONT FACE="Symbol">p</FONT></B> or <B><I>e</I></B>.
Returns 0 for everything else - this includes expressions like <CODE>ln(2)</CODE>,
<CODE>2<B><FONT FACE="Symbol">p</FONT></B></CODE>, or <CODE><B><FONT FACE="Symbol">&#214;</FONT></B>(2)</CODE>.</P>

<HR>
<H3><A NAME="is0"><U>is0</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is0 (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is equal to 0.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is equal to zero (integer or floating point).</P>

<P>See also: <A HREF="#is1">is1</A>, <A HREF="#is_minus1">is_minus1</A>, <A HREF="#is_never0">is_never0</A></P>
<HR>
<H3><A NAME="is1"><U>is1</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is1 (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is equal to 1.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is equal to one (integer or floating point).</P>

<P>See also: <A HREF="#is0">is0</A>, <A HREF="#is_minus1">is_minus1</A></P>
<HR>
<H3><A NAME="is_advanced_tag"><U>is_advanced_tag</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_advanced_tag (<A HREF="#ESQ">ESQ</A> Tag);</TD></TR></TABLE></P>
<P><B>Checks whether a tag is an advanced tag.</B></P>

<P>is_advanced_tag returns <A HREF="alloc.html#Bool">TRUE</A> if a byte <I>Tag</I> is an
advanced tag, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>. Advanced tags are all
tags which do not represent a variable, a number (integer, fraction or float)
or an expression which consists only of simple operations "+", "-", "*", "/" and "^"
(including element-by-element versions
"+<B>.</B>", "-<B>.</B>", "*<B>.</B>", "/<B>.</B>" and "^<B>.</B>").</P>

<HR>
<H3><A NAME="is_antisymmetric"><U>is_antisymmetric</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_antisymmetric (<A HREF="#CESI">CESI</A> expr_ptr, <A HREF="#CESI">CESI</A> var_ptr);</TD></TR></TABLE></P>
<P><B>Checks for a antisymmetry.</B></P>

<P>is_antisymmetric returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>expr_ptr</I> is such that it changes the sign but keeps the same magnitude
when the variable pointed to by
<I>var_ptr</I> changes it sign, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_complex0"><U>is_complex0</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_complex0 (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is reducible to zero.</B></P>

<P>is_complex0 returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is a zero (signed, unsigned, or even complex), otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.
<BR><BR>
<B>Note:</B> The information about this routine in releases of TIGCCLIB before 2.3 was wrong.</P>

<HR>
<H3><A NAME="is_complex_number"><U>is_complex_number</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_complex_number (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is a number.</B></P>

<P>is_complex_number returns <A HREF="alloc.html#Bool">TRUE</A> if the expression (in RPN form,
of course) pointed to by <I>ptr</I> is a "number" (integer, rational, floating point, or
complex, but not irrational), otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.
Note that <CODE>'sqrt(2)'</CODE> is not a "number" in this convention.
A complex number is a "number" if both real and imaginary parts are "numbers" in a sense
of the convention given above.
<BR><BR>
<B>Note:</B> The information about this routine in releases of TIGCCLIB before 2.3 was wrong.</P>

<P>See also: <A HREF="#likely_approx_to_number">likely_approx_to_number</A></P>
<HR>
<H3><A NAME="is_constant"><U>is_constant</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_constant (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is constant.</B></P>

<P>is_constant returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by 
<I>ptr</I> does not rely on any variables (initialized, built-in, but not constants like <B><FONT FACE="Symbol">p</FONT></B>),
otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_Float_exact_whole_number"><U>is_Float_exact_whole_number</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_Float_exact_whole_number (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether a floating point entry is an exact whole number.</B></P>

<P>is_Float_exact_whole_number returns <A HREF="alloc.html#Bool">TRUE</A> if the floating point
entry pointed to by <I>ptr</I> is an exact whole number whose magnitude is less than
the smallest whole number that is not represented exactly (1e15), otherwise it returns
<A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_free_of_tag"><U>is_free_of_tag</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_free_of_tag (<A HREF="#CESI">CESI</A> ptr, <A HREF="#ESQ">ESQ</A> Tag);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is free of a particular tag.</B></P>

<P>is_free_of_tag is a recursive function which returns <A HREF="alloc.html#Bool">TRUE</A>
if the expression structure pointed to by <I>ptr</I> is free of tag <I>Tag</I>,
otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_independent_of_de_seq_vars"><U>is_independent_of_de_seq_vars</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_independent_of_de_seq_vars (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is independent of differential equation and sequence variables.</B></P>

<P>is_independent_of_de_seq_vars returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>expr_ptr</I> is independent of system variables which are used for differential
equation and sequence graphing (i.e. variables u1-u99
and y1'-y99'),
otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_independent_of_elements"><U>is_independent_of_elements</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_independent_of_elements (<A HREF="#CESI">CESI</A> expr_ptr, <A HREF="#CESI">CESI</A> varlist_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is independent of the elements of a list.</B></P>

<P>is_independent_of_elements is very similar to <A HREF="#is_independent_of_tail">is_independent_of_tail</A>.
Assuming that <I>varlist_ptr</I> points to the list of variables or expressions (more precise, to the
<A HREF="#LIST_TAG">LIST_TAG</A> of such list), is_independent_of_elements returns
<A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by <I>expr_ptr</I> is independent
of all variables from the list pointed to by <I>varlist_ptr</I>, otherwise it returns
<A HREF="alloc.html#Bool">FALSE</A>. More precisely,</P>
<PRE>is_independent_of_elements (expr_ptr, varlist_ptr)
</PRE>
<P>is the same as</P>
<PRE>is_independent_of_tail (expr_ptr, varlist_ptr - 1)
</PRE>

<HR>
<H3><A NAME="is_independent_of_tail"><U>is_independent_of_tail</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_independent_of_tail (<A HREF="#CESI">CESI</A> expr_ptr, <A HREF="#CESI">CESI</A> start_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is independent of a sequence of variables (or expressions).</B></P>

<P>is_independent_of_tail returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>expr_ptr</I> is independent of all entries on the expression stack stored below
<I>start_ptr</I> up to <A HREF="#END_TAG">END_TAG</A> tag, otherwise it returns
<A HREF="alloc.html#Bool">FALSE</A>.</P>

<P>See also: <A HREF="#is_independent_of">is_independent_of</A>, <A HREF="#is_independent_of_elements">is_independent_of_elements</A>, <A HREF="#map_tail">map_tail</A>, <A HREF="#all_tail">all_tail</A></P>
<HR>
<H3><A NAME="is_independent_of"><U>is_independent_of</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_independent_of (<A HREF="#CESI">CESI</A> expr_ptr, <A HREF="#CESI">CESI</A> var_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is independent of a variable (or expression).</B></P>

<P>is_independent_of returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>expr_ptr</I> is independent of the variable pointed to by
<I>var_ptr</I>, else returns <A HREF="alloc.html#Bool">FALSE</A>. Although <I>var_ptr</I>
may point to something which is not a variable, the independence of the "expression"
is not well defined, so avoid such situations until more information about what
such "independence" means (TI says that this means "syntactical independence", but
this is not well defined either).
<BR><BR>
<B>Note:</B> This routine (and all other "independence" routines also)
is not reliable if expressions are not in internal canonic form
(see <A HREF="#push_internal_simplify">push_internal_simplify</A>).</P>

<HR>
<H3><A NAME="is_matrix"><U>is_matrix</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_matrix (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is a matrix.</B></P>

<P>is_matrix returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is a matrix (i.e. a list which consists of equally sized lists),
otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_minus1"><U>is_minus1</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_minus1 (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is equal to -1.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is equal to negative one (integer or floating point).</P>

<P>See also: <A HREF="#is0">is0</A>, <A HREF="#is1">is1</A></P>
<HR>
<H3><A NAME="is_monomial_in_kernel"><U>is_monomial_in_kernel</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_monomial_in_kernel (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is a monomial in kernel.</B></P>

<P>is_monomial_in_kernel returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is a monomial in kernel, i.e. if it is a monomial function of kernels,
where "kernel" means any irrational subexpression, else returns <A HREF="alloc.html#Bool">FALSE</A>.
For example, <CODE>'sin(x)*ln(y)'</CODE> is not monomial (in respect to <CODE>'x'</CODE>
and <CODE>'y'</CODE>), but it is monomial in kernel (in respect to <CODE>'sin(x)'</CODE>
and <CODE>'ln(y)'</CODE>).</P>

<HR>
<H3><A NAME="is_monomial"><U>is_monomial</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_monomial (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is a monomial.</B></P>

<P>is_monomial returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is a monomial expression, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.
For example, the expression <CODE>'x*y^3'</CODE> is a monomial, and
<CODE>x+y*z'</CODE> or <CODE>'ln(x)'</CODE> are not.</P>

<HR>
<H3><A NAME="is_narrowly_independent_of"><U>is_narrowly_independent_of</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_narrowly_independent_of (<A HREF="#CESI">CESI</A> expr_ptr, <A HREF="#CESI">CESI</A> var_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is narrowly independent of a variable (???).</B></P>

<P>is_narrowly_independent_of returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>expr_ptr</I> is narrowly independent of the variable pointed to by
<I>var_ptr</I>, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>. I am not sure what
"narrowly independent" really means, and what the difference between this function
and <A HREF="#is_independent_of">is_independent_of</A> is.</P>

<HR>
<H3><A NAME="is_negative"><U>is_negative</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_negative (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is less than 0.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is known to be negative, <A HREF="alloc.html#Bool">FALSE</A> otherwise.</P>

<P>See also: <A HREF="#is_nonnegative">is_nonnegative</A>, <A HREF="#is_positive">is_positive</A>, <A HREF="#is_nonpositive">is_nonpositive</A></P>
<HR>
<H3><A NAME="is_never0"><U>is_never0</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_never0 (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is never 0.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> cannot be equal to zero.</P>

<P>See also: <A HREF="#is0">is0</A></P>
<HR>
<H3><A NAME="is_nonnegative"><U>is_nonnegative</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_nonnegative (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is &gt;= 0.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is known to be positive or zero, <A HREF="alloc.html#Bool">FALSE</A> otherwise.</P>

<P>See also: <A HREF="#is_negative">is_negative</A>, <A HREF="#is_positive">is_positive</A>, <A HREF="#is_nonpositive">is_nonpositive</A></P>
<HR>
<H3><A NAME="is_nonpositive"><U>is_nonpositive</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_nonpositive (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is &lt;= 0.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is known to be negative or zero, <A HREF="alloc.html#Bool">FALSE</A> otherwise.</P>

<P>See also: <A HREF="#is_positive">is_positive</A>, <A HREF="#is_negative">is_negative</A>, <A HREF="#is_nonnegative">is_nonnegative</A></P>
<HR>
<H3><A NAME="is_polynomial_in_var_or_kern"><U>is_polynomial_in_var_or_kern</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_polynomial_in_var_or_kern (<A HREF="#CESI">CESI</A> test, <A HREF="#CESI">CESI</A> var_or_kern);</TD></TR></TABLE></P>
<P><B>Checks if an expression is a polynomial with respect to another expression.</B></P>

<P>is_polynomial_in_var_or_kern returns <A HREF="alloc.html#Bool">TRUE</A> if the expression
pointed to by <I>test</I> is a polynomial with respect to the expression <I>var_or_kern</I>,
otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>. The definition of "polynomial
with respect to" is more complicated when dealing with expressions in <I>var_or_kern</I>. For
example, "x+sin(x)" is polynomial with respect to "sin(x)" but not to "x".
Interestingly, when testing with respect to "sin(x)", "x" seems to be treated like a constant.</P>

<HR>
<H3><A NAME="is_pos_int_and_eq_quantum"><U>is_pos_int_and_eq_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_pos_int_and_eq_quantum (<A HREF="#CESI">CESI</A> expr, <A HREF="#ESQ">ESQ</A> num);</TD></TR></TABLE></P>
<P><B>Determines whether <I>expr</I> points to the tag of a positive integer equal to <I>num</I>.</B></P>

<P>Returns TRUE if <I>expr</I> points to the tag of a positive integer equal to <I>num</I>, FALSE otherwise.<BR>
This function assumes that <I>num</I> is nonzero.</P>

<HR>
<H3><A NAME="is_positive"><U>is_positive</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_positive (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is greater than 0.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is known to be positive (not zero), <A HREF="alloc.html#Bool">FALSE</A> otherwise.</P>

<P>See also: <A HREF="#is_nonpositive">is_nonpositive</A>, <A HREF="#is_negative">is_negative</A>, <A HREF="#is_nonnegative">is_nonnegative</A></P>
<HR>
<H3><A NAME="is_reciprocal_of_quantum"><U>is_reciprocal_of_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_reciprocal_of_quantum (<A HREF="#CESI">CESI</A>, <A HREF="#ESQ">ESQ</A>);</TD></TR></TABLE></P>
<P><B>Determines whether <I>expr</I> points to the tag of the reciprocal of <CODE>ESQ</CODE> <I>num</I>.</B></P>

<P>Returns TRUE if <I>expr</I> points to the tag of the fraction that is the reciprocal of 
<CODE>ESQ</CODE> <I>num</I>, FALSE otherwise.<BR>
This function assumes that <I>num</I> is nonzero.</P>

<HR>
<H3><A NAME="is_square_matrix"><U>is_square_matrix</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_square_matrix (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is a square matrix.</B></P>

<P>is_square_matrix returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is a square matrix, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_symmetric"><U>is_symmetric</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_symmetric (<A HREF="#CESI">CESI</A> expr_ptr, <A HREF="#CESI">CESI</A> var_ptr);</TD></TR></TABLE></P>
<P><B>Checks for symmetry.</B></P>

<P>is_symmetric returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>expr_ptr</I> is such that it remains the same when the variable pointed to by
<I>var_ptr</I> changes its sign, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_tail_independent_of"><U>is_tail_independent_of</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_tail_independent_of (<A HREF="#CESI">CESI</A> start_ptr, <A HREF="#CESI">CESI</A> var_ptr);</TD></TR></TABLE></P>
<P><B>Checks whether a sequence of expressions is independent of a variable (or expression).</B></P>

<P>is_tail_independent_of returns <A HREF="alloc.html#Bool">TRUE</A> if all expressions on the
expression stack which are stored below <I>start_ptr</I> up to <A HREF="#END_TAG">END_TAG</A>
are independent of the variable pointed to by <I>var_ptr</I>, otherwise it returns
<A HREF="alloc.html#Bool">FALSE</A>.</P>

<P>See also: <A HREF="#is_independent_of">is_independent_of</A>, <A HREF="#map_tail">map_tail</A>, <A HREF="#all_tail">all_tail</A></P>
<HR>
<H3><A NAME="is_temperature_unit"><U>is_temperature_unit</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_temperature_unit(<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks for strings of temperature units.</B></P>

<P>Checks if <I>ptr</I> points to the end of AMS strings (zero-padded at both sides) SYMSTR("_C"),
SYMSTR("_K"), SYMSTR("_F") and SYMSTR("_R"), i.e. strings of temperature units.</P>

<HR>
<H3><A NAME="is_totally_polynomial"><U>is_totally_polynomial</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_totally_polynomial (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks if an expression is polynomial in all variables.</B></P>

<P>is_totally_polynomial returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by 
<I>ptr</I> is polynomial with respect to all variables - that is, consists only of variables 
raised to positive constant powers (with coefficients) and multiplied or added together.
Otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="is_valid_smap_aggregate"><U>is_valid_smap_aggregate</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_valid_smap_aggregate (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks whether an expression is a valid aggregate type.</B></P>

<P>is_valid_smap_aggregate returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by
<I>ptr</I> is a valid aggregate type (i.e. list or valid matrix), otherwise it returns
<A HREF="alloc.html#Bool">FALSE</A>. This is not a simple check whether a tag pointed to by
<I>ptr</I> is <A HREF="#LIST_TAG">LIST_TAG</A>. For example, list which consists of
lists which are not equally sized (like {{1,2,3},{4,5}}) are not valid. Also, matrices
whose elements are list or matrices are also not valid aggregate types.</P>

<HR>
<H3><A NAME="is_variable"><U>is_variable</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_variable (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks if the expression is a variable.</B></P>

<P>is_variable returns <A HREF="alloc.html#Bool">TRUE</A> if the expression is a variable
and <A HREF="alloc.html#Bool">FALSE</A> if it is not.</P>

<HR>
<H3><A NAME="is_whole_number"><U>is_whole_number</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_whole_number (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Tests if an expression is a whole number.</B></P>

<P>Returns <A HREF="alloc.html#Bool">TRUE</A> if the expression pointed to by <I>ptr</I>
is a whole number (it can be a floating-point value).</P>

<HR>
<H3><A NAME="last_element_index"><U>last_element_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> last_element_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Searches for the last expression in the list.</B></P>

<P>last_element_index calls <A HREF="#next_expression_index">next_expression_index</A> in a loop
starting from <I>ptr</I> until <A HREF="#END_TAG">END_TAG</A> is reached, then returns the
pointer to the last encountered expression before <A HREF="#END_TAG">END_TAG</A>. So, assuming
that <I>ptr</I> points to a member of the list (including argument lists too),
last_element_index will return the pointer to the last element of the list.</P>

<HR>
<H3><A NAME="lead_base_index"><U>lead_base_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> lead_base_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the base of the lead factor of an expression.</B></P>

<P>lead_base_index first calls <A HREF="#lead_factor_index">lead_factor_index</A>,
then applies <A HREF="#factor_base_index">factor_base_index</A> to the result.
So, it returns the pointer to the base of the lead factor (i.e. the lead base)
of the expression pointed to by <I>ptr</I>.</P>

<HR>
<H3><A NAME="lead_exponent_index"><U>lead_exponent_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> lead_exponent_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the exponent of the lead factor of an expression.</B></P>

<P>lead_exponent_index first calls <A HREF="#lead_factor_index">lead_factor_index</A>,
then applies <A HREF="#factor_exponent_index">factor_exponent_index</A> to the result.
So, it returns the pointer to the exponent of the lead factor (i.e. the lead
exponent) of the expression pointed to by <I>ptr</I>.</P>

<HR>
<H3><A NAME="lead_factor_index"><U>lead_factor_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> lead_factor_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the lead factor of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#MUL_TAG">MUL_TAG</A>, which is the case when it
points to an expression of form <I>factor1</I>&nbsp;*&nbsp;<I>factor2</I>&nbsp;*&nbsp;<B>...</B>
(i.e. if the expression is a product of simpler factors), lead_factor_index returns the pointer
to <I>factor1</I> (i.e. to the lead factor). If <I>ptr</I> does not point to the
<A HREF="#MUL_TAG">MUL_TAG</A> (i.e. if the expression is not a product of simpler factors),
lead_factor_index returns <I>ptr</I> (i.e. the pointer to the expression itself).
<BR><BR>
<B>Note:</B> Expressions in internal canonic form have the most main factor shallowest, with less main factors deeper
(see <A HREF="#compare_expressions">compare_expressions</A> for more info about "main"
ordering). Also, the lead factor of an internally-simplified product is never a product.
For example, lead factor of <CODE>'(3*x^2)*y'</CODE> converted into canonic form is
<CODE>'x^2'</CODE>. Internally-simplified numeric denominator factors are combined with
numeric numerator factors into a fractional numeric factor. Non-numeric denominator
factors are internally simplified to be merged with numerator factors as negative powers.
For example, the lead factor of <CODE>'2/x'</CODE> converted into canonic form is
<CODE>'x^-1'</CODE>. A factor having a sum as its base orders shallower than a factor
having the sums main variable as its base. For example, the lead factor
of <CODE>'(x+1)^-2*x^3'</CODE> converted into canonic form is <CODE>'(x+1)^-2'</CODE>.
See <A HREF="#push_internal_simplify">push_internal_simplify</A>
for more info about how to convert an expression into the internal canonic form.</P>

<HR>
<H3><A NAME="lead_term_index"><U>lead_term_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> lead_term_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the lead term of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#ADD_TAG">ADD_TAG</A>, which is a case when it
points to an expression of form <I>term1</I>&nbsp;+&nbsp;<I>term2</I>&nbsp;+&nbsp;<B>...</B>
(i.e. if the expression is a sum of simpler terms), lead_term_index returns the pointer
to <I>term1</I> (i.e. to the lead term). If <I>ptr</I> does not point to the
<A HREF="#ADD_TAG">ADD_TAG</A> (i.e. if the expression is not a sum of simpler terms),
lead_term_index returns <I>ptr</I> (i.e. the pointer to the expression itself).
<BR><BR>
<B>Note:</B> Expressions in internal canonic form have the most main term shallowest, with less main
terms deeper (see <A HREF="#compare_expressions">compare_expressions</A> about more info about
"main" ordering). Also, the lead term of an internally-simplified sum is never a sum.
For example, the lead term of <CODE>'(2+x)+y'</CODE> converted to canonic form is <CODE>'x'</CODE>.
By default, similar powers of the main variable are collected in internal canonic forms.
For example, the lead term of <CODE>'x^2*y+x^2+5'</CODE> converted to canonic form is
<CODE>'x^2*(y+1)'</CODE>. See <A HREF="#push_internal_simplify">push_internal_simplify</A>
for more info about how to convert an expression into the internal canonic form.</P>

<HR>
<H3><A NAME="likely_approx_to_complex_number"><U>likely_approx_to_complex_number</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> likely_approx_to_complex_number (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks if it is likely that an expression can be approxed to a complex number.</B></P>

<P>likely_approx_to_complex_number is very similar to
<A HREF="#likely_approx_to_number">likely_approx_to_number</A>, except that it checks for the possibility
of approximation to numbers which need not be real numbers.</P>

<HR>
<H3><A NAME="likely_approx_to_number"><U>likely_approx_to_number</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> likely_approx_to_number (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Checks is it likely that an expression can be approxed to a real number.</B></P>

<P>If likely_approx_to_number returned <A HREF="alloc.html#Bool">TRUE</A>, it is sure that the expression pointed to by
<I>ptr</I> can be approxed to a real number, but returning <A HREF="alloc.html#Bool">FALSE</A>
does not mean that the approximation is not possible: it only means that the approximation
to a number is not obvious. For example, it is obvious that expression
<CODE>'ln(2+sin(1))/5'</CODE> can be approxed to a number, but this is not so obvious for
expression <CODE>'x^2+1-x*x'</CODE>, because it
contains a symbolic variable name. See <A HREF="#can_be_approxed">can_be_approxed</A> for a more
detailed investigation of possibility of approximation.</P>

<HR>
<H3><A NAME="main_gen_var_index"><U>main_gen_var_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> main_gen_var_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Searches an expression for a generalized variable.</B></P>

<P>main_gen_var_index is a variant of <A HREF="#index_main_var">index_main_var</A>, but it
searches for a "generalized variable", which may also be a subexpression. For example,
if the expression is <CODE>'sin(x)+y'</CODE>, <A HREF="#index_main_var">index_main_var</A>
will return a pointer to <CODE>'x'</CODE>, but main_gen_var_index will return a pointer to
<CODE>'sin(x)'</CODE>. Generalized variable can be an ordinary variable, the base of a
noninteger power, or a kernel (like <CODE>'sin(x)'</CODE>), meaning any other irrational
subexpression.
<BR><BR>
More precise, main_gen_var_index skips all <A HREF="#ADD_TAG">ADD_TAG</A>,
<A HREF="#MUL_TAG">MUL_TAG</A> and <A HREF="#POW_TAG">POW_TAG</A> tags, then stops at the
first tag which is not equal to some of them. In addition to this, if the tag is
<A HREF="#POW_TAG">POW_TAG</A>, function <A HREF="#next_expression_index">next_expression_index</A>
will be called, to get access to the base of the power (note that "powers" cannot be
"reorganized" on such way that constants are always in front of variables, because <CODE>'2^x'</CODE>
and <CODE>'x^2'</CODE> are not the same expression). This implies that "main generalized variable"
of a sum, a product or an integer power is equal to the main generalized variable of a lead term,
a lead factor or a base respectively. Otherwise, main generalized variable is the expression
itself. For example, main "generalized variables" of expressions <CODE>'sin(x)^2*y+ln(z)'</CODE>,
<CODE>'3^(1/5)+2'</CODE> and <CODE>'(x+y)^(1/2)+x'</CODE> are <CODE>'sin(x)'</CODE>,
<CODE>'3'</CODE> and <CODE>'x+y'</CODE> respectively.</P>

<HR>
<H3><A NAME="map_tail_Int"><U>map_tail_Int</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> map_tail_Int (<A HREF="#ESI_Callback_Int_t">ESI_Callback_Int_t</A> f, <A HREF="#ESI">ESI</A> start_ptr, <B><A HREF="keywords.html#short">short</A></B> n);</TD></TR></TABLE></P>
<P><B>Applies an extended function to all elements in the list.</B></P>

<P>map_tail_Int is very similar to <A HREF="#map_tail">map_tail</A>, except callback function <I>f</I> has
one additional parameter <I>n</I>. Each time <I>f</I> is called, the parameter <I>n</I>
passed to map_tail_Int is passed to <I>f</I>. Also, the callback function is not void but
returns a Boolean value (<A HREF="alloc.html#Bool">TRUE</A> or <A HREF="alloc.html#Bool">FALSE</A>). The result
of map_tail_Int is the logical OR of all the values returned by <I>f</I>.</P>

<HR>
<H3><A NAME="map_tail"><U>map_tail</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> map_tail (<A HREF="#ESI_Callback_t">ESI_Callback_t</A> f, <A HREF="#ESI">ESI</A> start_ptr);</TD></TR></TABLE></P>
<P><B>Applies a function to all elements in the list.</B></P>

<P>map_tail first pushes <A HREF="#END_TAG">END_TAG</A> on the expression stack, then
calls callback function <I>f</I> for every expression on the expression stack
(in reversed order), starting from the expression pointed to by <I>start_ptr</I> until
<A HREF="#END_TAG">END_TAG</A> is reached. Each time <I>f</I> is called, a pointer to the
actual expression is passed to it. This function is very useful if you want to apply some
operation on all elements of the list (then <I>start_ptr</I> need to point to the first
element of the list). If the callback function does not push anything on the stack, the
<A HREF="#END_TAG">END_TAG</A> pushed by map_tail should probably be deleted.
<BR><BR>
<B>Note:</B> map_tail calls <A HREF="#next_expression_index">next_expression_index</A>
to step from one expression to another.</P>

<HR>
<H3><A NAME="map_unary_over_comparison"><U>map_unary_over_comparison</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> map_unary_over_comparison (<A HREF="#ESI_Callback_t">ESI_Callback_t</A> f, <A HREF="#ESI">ESI</A> cmptag_ptr);</TD></TR></TABLE></P>
<P><B>Calls callback function for both comparison terms and pushes the comparison tag.</B></P>

<P>map_unary_over_comparison assumes that <I>cmptag_ptr</I>
points to a comparison tag. It calls the callback function <I>f</I> twice, passing to it pointers
to both comparison terms, i.e. the two expressions below the comparison tag (the callback function
should push something to the expression stack). The callback function is applied first to the
deeper argument on the stack, then to the shallower argument. Finally, map_unary_over_comparison
will push the tag pointed to by <I>cmptag_ptr</I> (one byte) to the expression stack.
This function is useful to perform some transformations on both sides of a comparison
(e.g. to transform <CODE>'n&lt;5'</CODE> into <CODE>'n!&lt;120'</CODE>). Beware that squaring of
both sides of an inequality can cause loss of solutions, and squaring both sides of an
equation may introduce spurious solutions!</P>

<HR>
<H3><A NAME="min_quantum"><U>min_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESQ">ESQ</A> min_quantum (<A HREF="#ESQ">ESQ</A> Tag1, <A HREF="#ESQ">ESQ</A> Tag2);</TD></TR></TABLE></P>
<P><B>Finds smaller of two tags.</B></P>

<P>min_quantum returns <I>Tag1</I> if it is smaller than <I>Tag2</I>, else
returns <I>Tag2</I>.</P>

<HR>
<H3><A NAME="move_between_to_top"><U>move_between_to_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> move_between_to_top (<A HREF="#ESI">ESI</A> ptr1, <A HREF="#ESI">ESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Moves a sequence of bytes to the top of the expression stack.</B></P>

<P>move_between_to_top moves a sequence of bytes between <I>ptr1</I> and <I>ptr2</I>
(more precise, starting at <I>ptr1</I>+1 and ending at <I>ptr2</I>) to the
top of the expression stack. It acts like a combination of <A HREF="#push_between">push_between</A>
and <A HREF="#delete_between">delete_between</A> (in fact, it is). This routine assumes that
<I>ptr1</I> and <I>ptr2</I> really point to parts of the expression stack
and that <I>ptr2</I> is above <I>ptr1</I>, otherwise the result is unpredictable.</P>

<HR>
<H3><A NAME="moved_between_to_top"><U>moved_between_to_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> moved_between_to_top (<A HREF="#ESI">ESI</A> ptr1, <A HREF="#ESI">ESI</A> ptr2);</TD></TR></TABLE></P>
<P><B>Moves a sequence of bytes to the top of the expression stack.</B></P>

<P>moved_between_to_top acts like <A HREF="#move_between_to_top">move_between_to_top</A>, but it also
returns a number of moved bytes. It calls <A HREF="#deleted_between">deleted_between</A>
instead of <A HREF="#delete_between">delete_between</A>.</P>

<HR>
<H3><A NAME="negate_top"><U>negate_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> negate_top (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Negates the top of the EStack.</B></P>

<P>negate_top changes the sign of the expression on the top of the EStack.</P>

<P>See also: <A HREF="#add_to_top">add_to_top</A>, <A HREF="#subtract_from_top">subtract_from_top</A>, <A HREF="#and_onto_top">and_onto_top</A></P>
<HR>
<H3><A NAME="next_expression_index"><U>next_expression_index</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> next_expression_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Finds the next entry on the expression stack.</B></P>

<P>Assuming that <I>ptr</I> points to an expression entry on the expression stack,
next_expression_index returns the pointer which points to an expression which is
located just below the expression pointed to by <I>ptr</I>. So, by successive calls
to next_expression_index starting from <A HREF="#top_estack">top_estack</A>, you
can locate all expressions on the stack. This command will throw an error if
<I>ptr</I> points to the <A HREF="#END_TAG">END_TAG</A>, so be careful.
<BR><BR>
<B>Note:</B> next_expression_index calls index_after_match_endtag
for TI-Basic functions and program tags, so that inline functions are counted as entire
expressions rather than of their components.</P>

<HR>
<H3><A NAME="NG_approxESI"><U>NG_approxESI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> NG_approxESI (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Evaluates an expression in "APPROX" mode.</B></P>

<P>NG_approxESI executes the entry on the expression stack pointed to by <I>ptr</I>
(it needs to point to the entry tag) in "APPROX" mode, then pushes the result (i.e. a new
expression) on the top of the expression stack. The pushed result is NOT in
internal canonic form
(if necessary, do <A HREF="#push_internal_simplify">push_internal_simplify</A> to force conversion
to the internal canonic form). The following example illustrates this very powerful command:</P>
<PRE>push_parse_text ("sin(1.3)+log(2)/7");
NG_approxESI (top_estack);
printf_xy (0, 50, "%f", estack_number_to_Float (top_estack));
</PRE>
<P>See <A HREF="#push_parse_text">push_parse_text</A> and <A HREF="#estack_number_to_Float">estack_number_to_Float</A>
to understand how this example works.
<BR><BR>
<B>Note:</B> The expression must not contain TI-Basic statements.
For executing TI-Basic statements, use <A HREF="#NG_execute">NG_execute</A>. Also, this
command may cause expansion of the expression stack or heap compression, and may throw
various errors is something is wrong.</P>

<HR>
<H3><A NAME="NG_execute"><U>NG_execute</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> NG_execute (<A HREF="alloc.html#HANDLE">HANDLE</A> Handle, <B><A HREF="keywords.html#short">short</A></B> approx_flag);</TD></TR></TABLE></P>
<P><B>Executes TI-Basic statements.</B></P>

<P>NG_execute executes a sequence of TI-Basic statements in tokenized form, which are
located in a memory block pointed to by handle <I>Handle</I>. It is a handle
to a <A HREF="#MULTI_EXPR">MULTI_EXPR</A> structure. To create such a block, the
functions <A HREF="#push_parse_text">push_parse_text</A> and <A HREF="homescr.html#HS_popEStack">HS_popEStack</A>
may be very useful, like in the following example:</P>
<PRE>push_parse_text ("ClrGraph:Graph sin(x)");
handle = HS_popEStack ();
NG_execute (handle, FALSE);
HeapFree (handle);
</PRE>
<P>If <I>approx_flag</I> is non-zero, the sequence will be executed in "approx" mode
(like running with [DIAMOND]+[ENTER]). Otherwise, the current mode settings will be used.
This routine is called after <A HREF="#NG_RPNToText">NG_RPNToText</A> from the home screen.
<BR><BR>
NG_execute can also evaluate expressions. In this case, the result of the evaluation
is pushed on the top of the expression stack.
<BR><BR>
<B>Note:</B> This routine always clears the error context, resets control flags, may cause estack
expansion or heap compression. It may throw various errors if something is wrong.</P>

<HR>
<H3><A NAME="NG_graphESI"><U>NG_graphESI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> NG_graphESI (<A HREF="#CESI">CESI</A> ptr, <A HREF="alloc.html#HANDLE">HANDLE</A> Handle);</TD></TR></TABLE></P>
<P><B>Evaluates an expressions for graphing purposes.</B></P>

<P>NG_graphESI is the function used in TIOS during drawing function graphs. It evaluates
the entry on the expression stack pointed to by <I>ptr</I> in "APPROX" mode then pushes
the result on the top of the expression stack, similar to what <A HREF="#NG_approxESI">NG_approxESI</A>
does, but NG_graphESI requires that all variables in the expression must be defined, i.e.
the expression must evaluate to a number (else "Undefined variable" error will be thrown).
<I>Handle</I> is the handle of the function in which the expression is defined. I don't
know exactly when and why this function needs this handle (probably to check which variables
are parameters of the function, which variables are local etc.). When I tried to pass
<A HREF="alloc.html#H_NULL">H_NULL</A> to this function, nothing bad happened. However, in the absence
of more info, avoid this function.</P>

<HR>
<H3><A NAME="NG_rationalESI"><U>NG_rationalESI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> NG_rationalESI (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Evaluates an expression in "EXACT" mode.</B></P>

<P>NG_rationalESI executes the entry on the expression stack pointed to by <I>ptr</I>
(it needs to point to the entry tag) in "EXACT" mode, then pushes the result (i.e. a new
expression) on the top of the expression stack. See the example of usage given with
<A HREF="#display_statements">display_statements</A>. The same notes given with
<A HREF="#NG_approxESI">NG_approxESI</A> are true with this command too.
<BR><BR>
<B>Note:</B> The expression must not contain TI-Basic statements.
For executing TI-Basic statements, use <A HREF="#NG_execute">NG_execute</A>. Also, this
command may cause expansion of the expression stack or heap compression, and may throw
various errors is something is wrong.</P>

<HR>
<H3><A NAME="NG_RPNToText"><U>NG_RPNToText</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="alloc.html#HANDLE">HANDLE</A> NG_RPNToText (<A HREF="alloc.html#HANDLE">HANDLE</A> hRPN, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> NewLines, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> FullPrec);</TD></TR></TABLE></P>
<P><B>Detokenizes a tokenized structure associated with a handle.</B></P>

<P>NG_RPNToText detokenizes a tokenized structure (an expression, TI-Basic statement or
a group of statements) associated with handle <I>hRPN</I> and
returns a handle to the memory block where detokenized string is stored (you don't need
to allocate anything by yourself, this function will do it instead). The first word of the
data associated with <I>hRPN</I> should be the length of the data which is used to find
the first tag of the tokenized data. It throws an error
if the detokenization fails. This function is mainly identical to
<A HREF="#display_statements">display_statements</A> except NG_RPNToText requires a
handle instead of the pointer to the structure which needs to be detokenized. See
<A HREF="#display_statements">display_statements</A> for more info.</P>

<HR>
<H3><A NAME="NG_tokenize"><U>NG_tokenize</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> NG_tokenize (<A HREF="alloc.html#HANDLE">HANDLE</A> hTEXT, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> *ErrCode, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> *ErrOffset);</TD></TR></TABLE></P>
<P><B>Tokenizes text associated with a handle and pushes them to the expression stack.</B></P>

<P>NG_tokenize is more powerful variant of <A HREF="#push_parse_text">push_parse_text</A>.
It tokenizes the text associated with the handle <I>hTEXT</I>, and pushes the converted
text to the expression stack. Returns <A HREF="alloc.html#Bool">TRUE</A> if the operation was
successful, otherwise it returns <A HREF="alloc.html#Bool">FALSE</A>. If there was an error, then the
variable pointed to by <I>ErrCode</I> contains the error code, and the variable pointed
to by <I>ErrOffset</I> contains the offset in the text where the error occurred. If there
were not any errors, then the variable pointed to by <I>ErrCode</I> contains multi state
(this is the result returned from <A HREF="#push_parse_text">push_parse_text</A>) and
<I>ErrOffset</I> is undefined. This routine may expand the expression stack, may cause
the heap compression, or even may throw an error if something goes really wrong (not enough
memory, for example).</P>

<HR>
<H3><A NAME="norm1_complex_Float"><U>norm1_complex_Float</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> norm1_complex_Float (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Finds the 1-norm of a complex number entry.</B></P>

<P>norm1_complex_Float finds the 1-norm (i.e. the sum of
absolute values of real and imaginary part) of the complex number entry pointed to by
<I>ptr</I> and returns the result. If the entry is not a complex or real floating point
number, the result is garbage (in the case of a real number, norm1_complex_Float
reduces to a simple absolute value).</P>

<HR>
<H3><A NAME="numeric_factor_index"><U>numeric_factor_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> numeric_factor_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Searches factors in the expression for a numeric factor.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#MUL_TAG">MUL_TAG</A>, which is a case when it
points to an expression of form <I>factor1</I>&nbsp;*&nbsp;<I>factor2</I>&nbsp;*&nbsp;<B>...</B>
(i.e. if the expression is a product of simpler factors), numeric_factor_index returns the pointer
to the eventual numeric factor in the expression. If the expression is a number, numeric_factor_index
returns <I>ptr</I> (i.e. the pointer to the expression itself). If <I>ptr</I> does not point to
the <A HREF="#MUL_TAG">MUL_TAG</A> (i.e. if the expression is not a product of simpler factors),
or if there is not any numeric factors in the expression, lead_factor_index returns
a pointer to a simple expression which consists only of the number 1 (floating point or integer,
depending of whether the approximation mode is active or not).
<BR><BR>
<B>Note:</B> This function is not implemented to be very universal. TIOS always "reorganizes" expressions
on such way that numeric factors are at the beginning of the expression (i.e. x*3 will be reorganized
into 3*x), and this function assumes that the expression is organized on such way. This is the so-called
"internal canonic" form, and such expressions always have at most one factor with a numeric tag, in
which case it is the deepest factor. So, <CODE>'3*x^2*y'</CODE> contains a numeric factor (3),
but <CODE>'2*x+3'</CODE> does not. Also, numeric factors in numerators and denominators are
always simplified into a single numeric factor in internal canonic forms (so, the numeric
factor of <CODE>'6*x/(4*y)'</CODE> after conversion to canonic form is 3/2. Fortunately,
all expressions in arguments are always in internal canonic form. However, this is not true after
<A HREF="#push_parse_text">push_parse_text</A> function, nor after an evaluation using
<A HREF="#NG_rationalESI">NG_rationalESI</A> or <A HREF="#NG_approxESI">NG_approxESI</A>. In
other words, results of these commands are not always "correctly" organized. To force converting
an expression to the internal canonic form, always call
<A HREF="#push_internal_simplify">push_internal_simplify</A> after usage any of functions
mentioned above.</P>

<HR>
<H3><A NAME="or_onto_top"><U>or_onto_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> or_onto_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Logical ORs an expression onto the estack.</B></P>

<P>or_onto_top replaces the top expression on the estack with the logical OR of itself and
the expression pointed to by <I>ptr</I>.</P>

<P>See also: <A HREF="#and_onto_top">and_onto_top</A></P>
<HR>
<H3><A NAME="Parms2D"><U>Parms2D</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> Parms2D (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">short</A></B> *Width, <B><A HREF="keywords.html#short">short</A></B> *Bottom, <B><A HREF="keywords.html#short">short</A></B> *Top);</TD></TR></TABLE></P>
<P><B>Gets information about dimensions of block which will be "pretty printed".</B></P>

<P>Parms2D gets information about the screen space which will be occupied by displayed expression.
It should be called after calling <A HREF="#Parse2DExpr">Parse2DExpr</A>
(or <A HREF="#Parse2DMultiExpr">Parse2DMultiExpr</A>), and <I>ptr</I>
should be a result returned from it. Params2D stores the information in three variables
pointed to by <I>Width</I>, <I>Bottom</I> and <I>Top</I>. <I>Width</I> is the width of
the displayed block, and <I>Top</I> and <I>Bottom</I> are distances of top and bottom
edge of the block measured from the wanted y position. More precise, if the expression is
printed at (x,&nbsp;y) using <A HREF="#Print2DExpr">Print2DExpr</A>, the left corner of the
occupied space will be at (x,&nbsp;y-*<I>Top</I>), and the
right corner of the occupied space will be at (x+*<I>Width</I>,&nbsp;y+*<I>Bottom</I>).
So, the 2D expression has an imaginary center line above which is the "Top", and below (counting
this line too) is the "Bottom".</P>

<HR>
<H3><A NAME="Parse1DExpr"><U>Parse1DExpr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="alloc.html#HANDLE">HANDLE</A> Parse1DExpr (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> FullPrec, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> width);</TD></TR></TABLE></P>
<P><B>Parses a tokenized expression to be printed.</B></P>

<P>Parse1DExpr does a similar job as <A HREF="#display_statements">display_statements</A>
(i.e. converts a RPN expression to the TEXT and returns the handle to the text), but the
parameters are somewhat different. Here, <I>width</I> is the
maximum width of text result (0 indicates no width restriction). So, when necessary, symbolic
expressions are truncated to <I>width</I>-1
characters and terminated with an ellipsis character ('...'). When <I>ptr</I>
points to a tagged floating point number, the number is rounded to fit in <I>width</I>
characters. When the number cannot be rounded to fit in <I>width</I> characters,
an ellipsis character ('...') is returned.
See <A HREF="#display_statements">display_statements</A> for more info.</P>

<HR>
<H3><A NAME="Parse2DExpr"><U>Parse2DExpr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Parse2DExpr (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> FullPrec);</TD></TR></TABLE></P>
<P><B>Parses a tokenized expression to be pretty printed using Print2DExpr.</B></P>

<P>Parse2DExpr parses the expression pointed to by <I>ptr</I>, so it can be displayed with
<A HREF="#Print2DExpr">Print2DExpr</A>. This function splits up expression into blocks with
information about their relative position and size. This splitting is performed for
efficiency reasons, so the expression may be displayed again without having to calculate
the positions again. Parse2DExpr returns the pointer to a created structure (it needs to be
passed to <A HREF="#Print2DExpr">Print2DExpr</A>). This pointer is in fact the new
value of <A HREF="#top_estack">top_estack</A>, because the created structure (known as "boxed RPN")
is also pushed on the expression stack. <I>FullPrec</I> is a Boolean flag:
when it is non-zero, all floating point values will be converted using the maximal precision
(14 digits), else current precision settings (from TI-Basic MODE dialog) will be used.
If there is not enough memory, a special symbol is pushed onto the expression stack to signify
this. This routine may cause heap compression.
See <A HREF="#Print2DExpr">Print2DExpr</A> for an example of usage.
<BR><BR>
Parse2DExpr will always convert expressions into the "canonic printing (external) form".
For example, both x*3 and 3*x will be displayed as 3*x, x*y^(-1) will be displayed as x/y etc.
<BR><BR>
<B>Note:</B> Break key (ON) is checked during execution of this function, and pressing it will throw
an error!</P>

<HR>
<H3><A NAME="Parse2DMultiExpr"><U>Parse2DMultiExpr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Parse2DMultiExpr (<A HREF="alloc.html#HANDLE">HANDLE</A> Handle, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> FullPrec);</TD></TR></TABLE></P>
<P><B>Parses a multi-statement expression associated with a handle to be pretty printed using Print2DExpr.</B></P>

<P>Parse2DMultiExpr parses a multi-expression (see <A HREF="#MULTI_EXPR">MULTI_EXPR</A>) associated with <I>Handle</I> so that it
can be displayed with <A HREF="#Print2DExpr">Print2DExpr</A>. Parameter <I>FullPrec</I> has
the same meaning as in <A HREF="#Parse2DExpr">Parse2DExpr</A>. The expression associated with
<I>Handle</I> may contain multiple expressions separated with <A HREF="#NEXTEXPR_TAG">NEXTEXPR_TAG</A>
(in opposite to <A HREF="#Parse2DExpr">Parse2DExpr</A>). I must admit that I don't understand
this function very well, so avoid it except if you know about it more than I know...</P>

<HR>
<H3><A NAME="Print2DExpr"><U>Print2DExpr</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> Print2DExpr (<A HREF="#CESI">CESI</A> ptr, <A HREF="wingraph.html#WINDOW">WINDOW</A> *w, <B><A HREF="keywords.html#short">short</A></B> x, <B><A HREF="keywords.html#short">short</A></B> y);</TD></TR></TABLE></P>
<P><B>Performs "pretty printing" (or "2D printing") of an expression.</B></P>

<P>Print2DExpr prints the expression in "pretty" or "2D" style. Before printing, the expression
needs first to be "parsed" using <A HREF="#Parse2DExpr">Parse2DExpr</A>, and argument <I>ptr</I>
should be a result returned from <A HREF="#Parse2DExpr">Parse2DExpr</A>
(an error may be thrown if <I>ptr</I> points to something else). <I>w</I> is a pointer
to the <A HREF="wingraph.html#WINDOW">WINDOW</A> structure which describes the window in which
the expression will be displayed (see <A HREF="wingraph.html">wingraph.h</A> header file for
more info about windows). If you didn't create your own windows in the program, you can pass
<A HREF="wingraph.html#DeskTop">DeskTop</A> as the parameter (as in the example given below).
<I>x</I> and <I>y</I> are coordinates (window-relative) where the expression will be printed.
<I>x</I> determines the left edge of the expression, and the expression goes (in y direction)
both above and below the value of <I>y</I>. See <A HREF="#Parms2D">Parms2D</A> for exact
information about dimensions of displayed expression. If the displayed expression cannot fit
into the given window, it will be simply clipped at edges of the window.
<BR><BR>
Here is an example (called "Pretty Print") which first calculates the integral of 1/((x-3)(x^2+4)), then "pretty prints"
the result on the screen:</P>
<PRE>// Calculate an integral and pretty print it

#define USE_TI89              // Compile for TI-89
#define USE_TI92PLUS          // Compile for TI-92 Plus
#define USE_V200              // Compile for V200

#define MIN_AMS 101           // Compile for AMS 1.01 or higher
#define SAVE_SCREEN           // Save/Restore LCD Contents

#include &lt;tigcclib.h&gt;         // Include All Header Files

// Main Function
void _main(void)
{
  TRY
    push_END_TAG ();
    push_quantum (VAR_X_TAG);
    push_parse_text (&quot;1/((x-3)(x^2+4))&quot;);
    push_quantum (INTEGRATE_TAG);
    NG_rationalESI (top_estack);
    WinClr (DeskTop);
    Print2DExpr (Parse2DExpr (top_estack, FALSE), DeskTop, 0, 50);
  ONERR
    DrawStr (20, 20, &quot;Error!&quot;, A_NORMAL);
  ENDTRY
  ngetchx ();
}
</PRE>
<P>It is also possible to use</P>
<PRE>Parse2DExpr (top_estack, FALSE);
Print2DExpr (top_estack, DeskTop, 0, 50);
</PRE>
<P>instead of</P>
<PRE>Print2DExpr (Parse2DExpr (top_estack, FALSE), DeskTop, 0, 50);
</PRE>
<P>You can use <A HREF="#Parms2D">Parms2D</A> to get information about the height and the width
of the printed expression without displaying it on the screen. This may be used to determine
coordinates where the expression needs to be displayed.</P>

<HR>
<H3><A NAME="push0"><U>push0</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push0 (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged integer or a tagged float 0, depending on the mode setting.</B></P>

<P>If the mode setting is APPROX, the tagged float 0.0 is pushed onto the EStack.
Else, the tagged integer 0 is pushed by <A HREF="#push_exact0">push_exact0</A>.</P>

<P>See also: <A HREF="#push1">push1</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_exact0">push_exact0</A>, <A HREF="#push_exact1">push_exact1</A>, <A HREF="#push_exact_minus1">push_exact_minus1</A></P>
<HR>
<H3><A NAME="push1"><U>push1</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push1 (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged integer or a tagged float 1, depending on the mode setting.</B></P>

<P>If the mode setting is APPROX, the tagged float 1.0 is pushed onto the EStack.
Else, the tagged integer 1 is pushed by <A HREF="#push_exact1">push_exact1</A>.</P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_exact0">push_exact0</A>, <A HREF="#push_exact1">push_exact1</A>, <A HREF="#push_exact_minus1">push_exact_minus1</A></P>
<HR>
<H3><A NAME="push_ANSI_string"><U>push_ANSI_string</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_ANSI_string (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str);</TD></TR></TABLE></P>
<P><B>Pushes a standard C string to the expression stack.</B></P>

<P>push_ANSI_string is an alias (known from early versions of TIGCCLIB)
for the TIOS function <A HREF="#push_zstr">push_zstr</A>.</P>

<HR>
<H3><A NAME="push_between"><U>push_between</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_between (<B><A HREF="keywords.html#void">void</A></B> *ptr1, <B><A HREF="keywords.html#void">void</A></B> *ptr2);</TD></TR></TABLE></P>
<P><B>Pushes a sequence of bytes to the expression stack.</B></P>

<P>push_between pushes a sequence of bytes starting at <I>ptr1</I>+1 and ending at <I>ptr2</I>
to the expression stack.
<BR><BR>
<B>Note:</B> The break key (ON) is checked during execution of this routine, and an error is thrown if
it is pressed!</P>

<HR>
<H3><A NAME="push_cnvrt_integer_if_whole_nmb"><U>push_cnvrt_integer_if_whole_nmb</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_cnvrt_integer_if_whole_nmb (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Pushes a floating point entry eventually converted to an integer.</B></P>

<P>push_cnvrt_integer_if_whole_nmb checks the entry on the expression stack pointed to by
<I>ptr</I>. If it is not a floating point value (represented by <A HREF="#FLOAT_TAG">FLOAT_TAG</A>),
or if it is a floating point value which is not a whole number, yet another copy of the entry is
pushed on the expression stack. If the entry is a floating point value which is a whole number,
this number is pushed on the expression stack, but this time as an integer (i.e. with
<A HREF="#POSINT_TAG">POSINT_TAG</A> or <A HREF="#NEGINT_TAG">NEGINT_TAG</A>).</P>

<HR>
<H3><A NAME="push_e"><U>push_e</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_e (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes <B><I>e</I></B>.</B></P>

<P>If the mode setting is APPROX, the tagged float <B><I>e</I></B> is pushed onto the EStack. Otherwise, <B><I>e</I></B>^1 is pushed.</P>

<HR>
<H3><A NAME="push_END_TAG"><U>push_END_TAG</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_END_TAG (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes end-of-list marker to the expression stack.</B></P>

<P>push_END_TAG pushes <A HREF="#END_TAG">END_TAG</A> to the expression stack. This
is the same as push_quantum&nbsp;(END_TAG).
<BR><BR>
push_END_TAG may be useful when you want to push a list on the expressions
stack: first push <A HREF="#END_TAG">END_TAG</A>, then all elements of the list in reverse order, and finally
push <A HREF="#LIST_TAG">LIST_TAG</A> (using <A HREF="#push_LIST_TAG">push_LIST_TAG</A>).</P>

<P>See also: <A HREF="#push_quantum">push_quantum</A></P>
<HR>
<H3><A NAME="push_exact0"><U>push_exact0</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_exact0 (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged integer 0.</B></P>

<P>This routine is called by <A HREF="#push0">push0</A> if the mode setting is not APPROX.</P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push1">push1</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_exact1">push_exact1</A>, <A HREF="#push_exact_minus1">push_exact_minus1</A></P>
<HR>
<H3><A NAME="push_exact1"><U>push_exact1</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_exact1 (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged integer 1.</B></P>

<P>This routine is called by <A HREF="#push1">push1</A> if the mode setting is not APPROX.</P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push1">push1</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_exact0">push_exact0</A>, <A HREF="#push_exact_minus1">push_exact_minus1</A></P>
<HR>
<H3><A NAME="push_exact_minus1"><U>push_exact_minus1</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_exact_minus1 (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged integer -1.</B></P>

<P>This routine is called by <A HREF="#push_minus1">push_minus1</A> if the mode setting is not APPROX.</P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push1">push1</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_exact0">push_exact0</A>, <A HREF="#push_exact1">push_exact1</A></P>
<HR>
<H3><A NAME="push_expr_quantum"><U>push_expr_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_expr_quantum (<A HREF="#CESI">CESI</A> ptr, <A HREF="#ESQ">ESQ</A> Tag);</TD></TR></TABLE></P>
<P><B>Pushes an expression followed by a tag to the expression stack.</B></P>

<P>push_expr_quantum pushes an entry (expression) pointed to by <I>ptr</I> (it
needs to point to the entry tag) to the top of the expression stack, then
pushes a byte <I>Tag</I>. The entry does not need to be a simple entity; it may be a
complex symbolic expression, too. This is achieved by calling
<A HREF="#next_expression_index">next_expression_index</A>
and <A HREF="#push_between">push_between</A>. This function is useful
when you need to perform a unary operation on the expression.</P>

<P>See also: <A HREF="#push_expression">push_expression</A>, <A HREF="#push_expr2_quantum">push_expr2_quantum</A></P>
<HR>
<H3><A NAME="push_expr2_quantum"><U>push_expr2_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_expr2_quantum (<A HREF="#CESI">CESI</A> ptr1, <A HREF="#CESI">CESI</A> ptr2, <A HREF="#ESQ">ESQ</A> Tag);</TD></TR></TABLE></P>
<P><B>Pushes two expressions followed by a tag to the expression stack.</B></P>

<P>push_expr2_quantum pushes two entries (expressions) on the expression stack
pointed to by <I>ptr1</I> and <I>ptr2</I> to the top of the stack, then
pushes a byte <I>Tag</I>. This function is useful when you need to perform
a binary operation on two expressions.</P>

<P>See also: <A HREF="#push_expression">push_expression</A>, <A HREF="#push_expr_quantum">push_expr_quantum</A></P>
<HR>
<H3><A NAME="push_expression"><U>push_expression</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_expression (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Pushes an expression to the expression stack.</B></P>

<P>push_expression pushes an entry (expression) pointed to by <I>ptr</I> (it
needs to point to the entry tag) to the top of the expression stack. The
entry does not need to be a simple entity; it may be a complex symbolic
expression, too. This is achieved by calling
<A HREF="#next_expression_index">next_expression_index</A>
and <A HREF="#push_between">push_between</A>.</P>

<P>See also: <A HREF="#push_quantum">push_quantum</A>, <A HREF="#push_expr_quantum">push_expr_quantum</A>, <A HREF="#push_expr2_quantum">push_expr2_quantum</A></P>
<HR>
<H3><A NAME="push_Float_to_nonneg_int"><U>push_Float_to_nonneg_int</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_Float_to_nonneg_int (<B><A HREF="keywords.html#float">float</A></B> value);</TD></TR></TABLE></P>
<P><B>Rounds a floating point value to an integer, then pushes it to the expression stack.</B></P>

<P>push_Float_to_nonneg_int rounds <I>value</I> to the nearest integer, then pushes
it to the expression stack, as a tagged integer value. The sign of <I>value</I> is ignored.
This routine may throw an error if the truncated integer part of <I>value</I> is
not representable as a big integer.</P>

<HR>
<H3><A NAME="push_Float_to_rat"><U>push_Float_to_rat</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_Float_to_rat (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Pushes a rational approximation of a floating point entry.</B></P>

<P>push_Float_to_rat finds a rational approximation of the floating point entry pointed to by
<I>ptr</I> (of course, <I>ptr</I> points to the tag), and pushes it on the top of the
expression stack. The relative error can be specified using the AMS global variable RAtionalize_tol.
This routine works well even with transfinite
floats (e.g. <A HREF="timath.html#POSITIVE_INF">POSITIVE_INF</A> will be pushed as
<A HREF="#INFINITY_TAG">INFINITY_TAG</A>).</P>

<HR>
<H3><A NAME="push_Float"><U>push_Float</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_Float (<B><A HREF="keywords.html#float">float</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes a floating point value to the expression stack.</B></P>

<P>push_Float rounds <I>value</I> to the 14 significant digits (using
<A HREF="timath.html#round14">round14</A>), then pushes it to the expression stack.
If <I>value</I> is not representable as a finite float, the most appropriate
transfinite tag is pushed.</P>

<HR>
<H3><A NAME="push_half"><U>push_half</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_half (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged fraction +1/2 or a tagged float 0.5, depending on the mode setting.</B></P>

<P>If the mode setting is APPROX, the tagged float 0.5 is pushed onto the EStack.
Else, the tagged fraction +1/2 is pushed by calling <CODE>push_reciprocal_of_quantum(2);</CODE></P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push1">push1</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_minus_half">push_minus_half</A>, <A HREF="#push_reciprocal_of_quantum">push_reciprocal_of_quantum</A></P>
<HR>
<H3><A NAME="push_i"><U>push_i</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_i (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes <B><I>i</I></B>.</B></P>

<P>The complex <B><I>i</I></B> is pushed onto the EStack, in float or integer form, depending on the APPROX mode setting.</P>

<HR>
<H3><A NAME="push_internal_simplify"><U>push_internal_simplify</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_internal_simplify (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Converts an expression into internal canonic form and pushes the result to the expression stack.</B></P>

<P>This extremely important low-level subroutine converts an expression pointed to by <I>ptr</I>
to the internal canonic form (see <A HREF="#top_estack">top_estack</A> for more info about
the internal canonic form), and pushes the converted expression at the top of the expression
stack. This routine accepts all valid (algebraic, calculus, relational, logical or Boolean)
tokenized expressions. During the conversion, various simplifications may be performed as well.
This routine may cause heap compression, stack expansion, and may throw an error if something
goes wrong.</P>

<HR>
<H3><A NAME="push_LIST_TAG"><U>push_LIST_TAG</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_LIST_TAG (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes list tag to the expression stack.</B></P>

<P>push_LIST_TAG pushes <A HREF="#LIST_TAG">LIST_TAG</A> to the expression stack. This
is the same as push_quantum&nbsp;(LIST_TAG).
<BR><BR>
push_LIST_TAG may be useful when you want to push a list on the expressions
stack: first push <A HREF="#END_TAG">END_TAG</A> (using <A HREF="#push_END_TAG">push_END_TAG</A>),
then all elements of the list in reverse order, and finally push <A HREF="#LIST_TAG">LIST_TAG</A>.</P>

<P>See also: <A HREF="#push_quantum">push_quantum</A></P>
<HR>
<H3><A NAME="push_long_to_integer"><U>push_long_to_integer</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_long_to_integer (<B><A HREF="keywords.html#short">long</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes a signed long integer to the expression stack.</B></P>

<P>push_long_to_integer pushes the long integer value <I>value</I> to the expression stack.
It is the same as <A HREF="#push_longint">push_longint</A>, except that
it is implemented in the operating system instead of by GCC4TI.</P>

<P>See also: <A HREF="#push_ulong_to_integer">push_ulong_to_integer</A>, <A HREF="#push_ushort_to_integer">push_ushort_to_integer</A>, <A HREF="#push_longint">push_longint</A></P>
<HR>
<H3><A NAME="push_longint"><U>push_longint</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_longint (<B><A HREF="keywords.html#short">long</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes a long integer to the expression stack.</B></P>

<P>push_longint pushes the long integer value <I>value</I> to the expression stack.
<BR><BR>
<B>Note:</B> push_longint is not a TIOS entry; it is implemented "by hand" using
<A HREF="#push_quantum">push_quantum</A>. This means that either
<A HREF="#push_shortint">push_shortint</A> or push_longint should be used in a
program, but using both is usually not desirable.</P>

<P>See also: <A HREF="#push_shortint">push_shortint</A>, <A HREF="#push_longlongint">push_longlongint</A></P>
<HR>
<H3><A NAME="push_longlongint"><U>push_longlongint</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_longlongint (<B><A HREF="keywords.html#short">long</A></B> <B><A HREF="keywords.html#short">long</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes a double-long integer to the expression stack.</B></P>

<P>push_longlongint pushes the double-long integer value <I>value</I> to the expression stack.
<BR><BR>
<B>Note:</B> push_longlongint is not a TIOS entry; it is implemented "by hand" using
<A HREF="#push_quantum">push_quantum</A>.</P>

<P>See also: <A HREF="#push_shortint">push_shortint</A>, <A HREF="#push_longint">push_longint</A></P>
<HR>
<H3><A NAME="push_minus1"><U>push_minus1</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_minus1 (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged integer or a tagged float -1, depending on the mode setting.</B></P>

<P>If the mode setting is APPROX, the tagged float -1.0 is pushed onto the EStack.
Else, the tagged integer -1 is pushed by <A HREF="#push_exact_minus1">push_exact_minus1</A>.</P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push1">push1</A>, <A HREF="#push_exact0">push_exact0</A>, <A HREF="#push_exact1">push_exact1</A>, <A HREF="#push_exact_minus1">push_exact_minus1</A></P>
<HR>
<H3><A NAME="push_minus_half"><U>push_minus_half</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_minus_half (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a tagged fraction -1/2 or a tagged float -0.5, depending on the mode setting.</B></P>

<P>If the mode setting is APPROX, the tagged float -0.5 is pushed onto the EStack.
Else, the tagged fraction -1/2 is pushed by calling <CODE>push_minus_recip_of_quantum(2);</CODE></P>

<P>See also: <A HREF="#push0">push0</A>, <A HREF="#push1">push1</A>, <A HREF="#push_minus1">push_minus1</A>, <A HREF="#push_half">push_half</A>, <A HREF="#push_minus_recip_of_quantum">push_minus_recip_of_quantum</A></P>
<HR>
<H3><A NAME="push_minus_recip_of_quantum"><U>push_minus_recip_of_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_minus_recip_of_quantum (<A HREF="#ESQ">ESQ</A> q);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack minus the reciprocal of the argument as a tagged negative fraction.</B></P>

<P>This function assumes that its argument is strictly superior to 1.</P>

<P>See also: <A HREF="#push_reciprocal_of_quantum">push_reciprocal_of_quantum</A>, <A HREF="#push_quantum_as_nonnegative_int">push_quantum_as_nonnegative_int</A>, <A HREF="#push_negate_quantum_as_negint">push_negate_quantum_as_negint</A>, <A HREF="#push_quantum_pair_as_pos_frac">push_quantum_pair_as_pos_frac</A></P>
<HR>
<H3><A NAME="push_negate_quantum_as_negint"><U>push_negate_quantum_as_negint</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_negate_quantum_as_negint (<A HREF="#ESQ">ESQ</A>);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack the argument as a tagged negative integer.</B></P>

<P>This function assumes that its argument is strictly superior to 0.</P>

<P>See also: <A HREF="#push_quantum_as_nonnegative_int">push_quantum_as_nonnegative_int</A>, <A HREF="#push_reciprocal_of_quantum">push_reciprocal_of_quantum</A>, <A HREF="#push_minus_recip_of_quantum">push_minus_recip_of_quantum</A>, <A HREF="#push_quantum_pair_as_pos_frac">push_quantum_pair_as_pos_frac</A></P>
<HR>
<H3><A NAME="push_next_arb_int"><U>push_next_arb_int</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_next_arb_int (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a next "arbitrary integer" symbol to the expression stack.</B></P>

<P>push_next_arb_int pushes a next "arbitrary integer" symbol (i.e. symbol <B>@n</B><I>xxx</I>)
to the top of the expression stack. More precise, it increments an internal counter for
arbitrary integers, pushes the counter on the stack, then pushes <A HREF="#ARB_INT_TAG">ARB_INT_TAG</A>.
The counter wraps to zero after 255 is reached.</P>

<HR>
<H3><A NAME="push_next_arb_real"><U>push_next_arb_real</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_next_arb_real (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes a next "arbitrary real" symbol to the expression stack.</B></P>

<P>push_next_arb_int pushes a next "arbitrary real" symbol (i.e. symbol <B>@</B><I>xxx</I>)
to the top of the expression stack. More precise, it increments an internal counter for
arbitrary reals, pushes the counter on the stack, then pushes <A HREF="#ARB_REAL_TAG">ARB_REAL_TAG</A>.
The counter wraps to zero after 255 is reached.</P>

<HR>
<H3><A NAME="push_next_internal_var"><U>push_next_internal_var</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_next_internal_var (<A HREF="#ESQ">ESQ</A> Tag);</TD></TR></TABLE></P>
<P><B>Pushes an internal variable to the expression stack.</B></P>

<P>push_next_internal_var is an auxiliary function used in calculus operations. It
pushes the sequence 0,&nbsp;<I>Tag</I>+1,&nbsp;<I>count</I>,&nbsp;0 to the
expression stack, where <I>count</I> is the internal counter of internal
variables. Then, the counter is increased by one. TIOS usually passes 0 or 1
for <I>Tag</I>, so it manages a two independent sets of internal variables.
You can see that internal variable names consist of two bytes (see
<A HREF="#VAR_NAME_TAG">VAR_NAME_TAG</A>): one byte is "set number", and another byte
is "number of a variable in the set".</P>

<HR>
<H3><A NAME="push_no_solution_found_string"><U>push_no_solution_found_string</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_no_solution_found_string (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes "No solution found", or its localized version if a language localization is active (on AMS 2.xx), on the EStack.</B></P>

<P>The string is pushed as an AMS string using <A HREF="#push_zstr">push_zstr</A>.</P>

<HR>
<H3><A NAME="push_offset_array"><U>push_offset_array</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> push_offset_array (<A HREF="#CESI">CESI</A> elements_ptr, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> **dest);</TD></TR></TABLE></P>
<P><B>Pushes an array of offsets to the list items.</B></P>

<P>This function is not complicated, but it is a bit hard to explain.
It first increments the pointer to the top of the expression stack to the
nearest even address, then pushes a word array which contains the offsets to all entries
on the expression stack below <I>elements_ptr</I> until <A HREF="#END_TAG">END_TAG</A> is
reached. The offset is expressed relative to the <I>elements_ptr</I>.
push_offset_array returns the size of pushed array in words (i.e. the number of elements),
and stores in the pointer variable pointed to by <I>dest</I> the top address of pushed
array. For example, if you execute the following sequence
<BR><BR>
unsigned int *offsets;<BR>
ESI esi;<BR>
unsigned int count;<BR>
<B>...</B><BR>
esi=top_estack;<BR>
count=push_offset_array (esi, &amp;offsets);
<BR><BR>
then
esi-offsets[0],
esi-offsets[-1],
esi-offsets[-2],
..., esi-offsets[1-count]
will point to entries on the expression stack.
esi-offsets[0] will point to the further entry from the
top of the expression stack,
esi-offsets[-1] will point
to the next one, and finally,
esi-offsets[1-count] will
point to the entry on the top of the expression stack (more precise,
offsets[1-count] is always zero). This function is useful
when you need a fast way to access to all entries on the expression stack many times.</P>

<HR>
<H3><A NAME="push_overflow_to_infinity"><U>push_overflow_to_infinity</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_overflow_to_infinity (<A HREF="#ESQ">ESQ</A> inf_tag);</TD></TR></TABLE></P>
<P><B>Displays a warning, and pushes a tag to the expression stack.</B></P>

<P>push_overflow_to_infinity displays the warning message "Warning: Overflow replaced
by INF or -INF", then pushes byte <I>inf_tag</I>
to the expression stack (it is usually <A HREF="#INFINITY_TAG">INFINITY_TAG</A> or
<A HREF="#NEGINFINITY_TAG">NEGINFINITY_TAG</A>).</P>

<HR>
<H3><A NAME="push_parse_text"><U>push_parse_text</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> push_parse_text (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str);</TD></TR></TABLE></P>
<P><B>Parses an expression given in a string and pushes tokenized expression to the expression stack.</B></P>

<P>push_parse_text is an extremely powerful function: it parses the expression given in the
string <I>str</I>, and pushes the expressions (in RPN form) to the expression stack.
This function also can parse TI-Basic statements (after parsing, the tokenized form of these
statements is pushed on the expression stack too). push_parse_text returns <A HREF="alloc.html#Bool">FALSE</A>
if the expression is a multi expression (i.e. if it contains "<B>:</B>" [separator], "-&gt;" [store] or
TI-Basic statements), otherwise it returns <A HREF="alloc.html#Bool">TRUE</A>. This routine may cause expansion
of the expression stack or heap compression.
GCC4TILIB internally uses this function (together with <A HREF="#estack_number_to_Float">estack_number_to_Float</A>)
in the implementation of <A HREF="timath.html#atof">atof</A> function.
For more examples of usage of this function, see <A HREF="#NG_approxESI">NG_approxESI</A>,
<A HREF="#NG_rationalESI">NG_rationalESI</A>, <A HREF="#NG_execute">NG_execute</A> etc.
The "inverse" function of push_parse_text is <A HREF="#display_statements">display_statements</A>.
<BR><BR>
If you want to perform highly advanced symbolic operations with expressions, you should know that expressions
created by push_parse_text are not always organized on a way which allows the most efficient symbolic
processing (so-called internal canonic form). For example, TIOS always converts <CODE>'x*3'</CODE>
into <CODE>'3*x'</CODE> and converts
<CODE>'x-y'</CODE> into <CODE>'x+y*(-1)'</CODE>, although it will be printed as
<CODE>'x-y'</CODE>. However, expressions
created by push_parse_text are always as-is, i.e.
<CODE>'3*x'</CODE> will be just <CODE>'3*x'</CODE>, not <CODE>'x*3'</CODE>. Some routines
(like <A HREF="#numeric_factor_index">numeric_factor_index</A> for example) may be fooled if
the expression is not "sorted" correctly. Also, some routines
(like <A HREF="#lead_term_index">lead_term_index</A>, <A HREF="#lead_factor_index">lead_factor_index</A>
etc.) may also be fooled with expressions like <CODE>'x-y'</CODE> and
<CODE>'x/y'</CODE>, because operators <CODE>'-'</CODE> and <CODE>'/'</CODE> are usually never seen in
expressions during symbolic processing (the processing is more unique if addition and
subtraction are treated as the same operation; the same is true for <CODE>'*'</CODE> and
<CODE>'/'</CODE>). So, if you
planed to perform some advanced symbolic processing which is based on accessing various
part of the expression, always call <A HREF="#push_internal_simplify">push_internal_simplify</A>
after calling push_parse_text. This function pushes on the expression stack the same expression
but converted in internal canonic form.
<BR><BR>
<B>Note:</B> push_parse_text will throw an error if the string contains expression with wrong
syntax, so you need to use <A HREF="error.html#TRY">TRY</A> etc. to catch
eventual errors. And, the string must be built using TI-Basic conventions (for
example, you must use 0xAD ("small" minus) instead of <CODE>'-'</CODE> for
unary minus, etc. See <A HREF="#NG_tokenize">NG_tokenize</A> for a more powerful function which
doesn't throw any errors, and which can determine the exact location and type of the error.</P>

<HR>
<H3><A NAME="push_pi_on_quantum"><U>push_pi_on_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_pi_on_quantum (<A HREF="#ESQ">ESQ</A>);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack the quotient of PI (numerator) and of the argument (denominator), in a way depending on the mode setting.</B></P>

<P>If the mode setting is APPROX, then a tagged float is pushed on the EStack.
The sequence of bytes [<I>reciprocal of argument</I>] PI_TAG MUL_TAG is pushed otherwise.<BR>
This function assumes that its argument is strictly superior to 1.</P>

<P>See also: <A HREF="#push_pi">push_pi</A></P>
<HR>
<H3><A NAME="push_pi"><U>push_pi</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_pi (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack a tagged float PI if the mode setting is APPROX, otherwise pushes a <A HREF="#PI_TAG">PI_TAG</A>.</B></P>

<P>This function assumes nothing.</P>

<P>See also: <A HREF="#push_pi_on_quantum">push_pi_on_quantum</A></P>
<HR>
<H3><A NAME="push_quantum_as_nonnegative_int"><U>push_quantum_as_nonnegative_int</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_quantum_as_nonnegative_int (<A HREF="#ESQ">ESQ</A>);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack the argument as a tagged positive integer.</B></P>

<P>This function assumes that its argument is strictly superior to 0.</P>

<P>See also: <A HREF="#push_negate_quantum_as_negint">push_negate_quantum_as_negint</A>, <A HREF="#push_reciprocal_of_quantum">push_reciprocal_of_quantum</A>, <A HREF="#push_minus_recip_of_quantum">push_minus_recip_of_quantum</A>, <A HREF="#push_quantum_pair_as_pos_frac">push_quantum_pair_as_pos_frac</A></P>
<HR>
<H3><A NAME="push_quantum_pair_as_pos_frac"><U>push_quantum_pair_as_pos_frac</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_quantum_pair_as_pos_frac (<A HREF="#ESQ">ESQ</A>, <A HREF="#ESQ">ESQ</A>);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack the quotient of the first argument (numerator) and the second argument (denominator).</B></P>

<P>This function assumes:</P>
<UL>
<LI><P>that the numerator and the denominator are relatively prime;</P></LI>
<LI><P>that the numerator is strictly superior to 0;</P></LI>
<LI><P>that the denominator is strictly superior to 1.</P></LI>
</UL>

<P>See also: <A HREF="#push_quantum_as_nonnegative_int">push_quantum_as_nonnegative_int</A>, <A HREF="#push_negate_quantum_as_negint">push_negate_quantum_as_negint</A>, <A HREF="#push_reciprocal_of_quantum">push_reciprocal_of_quantum</A>, <A HREF="#push_minus_recip_of_quantum">push_minus_recip_of_quantum</A></P>
<HR>
<H3><A NAME="push_quantum_pair"><U>push_quantum_pair</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_quantum_pair (<A HREF="#ESQ">ESQ</A> Tag1, <A HREF="#ESQ">ESQ</A> Tag2);</TD></TR></TABLE></P>
<P><B>Pushes two bytes (tags) to the expression stack.</B></P>

<P>push_quantum_pair pushes the bytes <I>Tag1</I> and <I>Tag2</I> to the expression stack.
Basically, it acts like:</P>
<PRE>push_quantum (Tag1);
push_quantum (Tag2);
</PRE>
<P>but it is a little more optimized.</P>

<P>See also: <A HREF="#push_quantum">push_quantum</A></P>
<HR>
<H3><A NAME="push_quantum"><U>push_quantum</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_quantum (<A HREF="#ESQ">ESQ</A> Tag);</TD></TR></TABLE></P>
<P><B>Pushes a byte (tag) to the expression stack.</B></P>

<P>push_quantum is the basic function for manipulating the expression stack, and many other
functions are based on it. It pushes a byte <I>Tag</I> to the expression stack. For example,
you can push a complex value to the expression stack using the following construction:</P>
<PRE>push_Float (<I>real_part</I>);
push_Float (<I>imaginary_part</I>);
push_quantum (COMPLEX_TAG);
</PRE>
<P>See <A HREF="#push_Float">push_Float</A>, and info about <A HREF="#top_estack">top_estack</A>
and <A HREF="#Tags">Tags</A> for more info about this example.
<BR><BR>
<B>Note:</B> This routine (as well as all other "push_..." routines) may cause heap compression, and
may throw an error if there is not enough space on the expression stack.</P>

<P>See also: <A HREF="#push_quantum_pair">push_quantum_pair</A>, <A HREF="#push_expression">push_expression</A>, <A HREF="#push_expr_quantum">push_expr_quantum</A></P>
<HR>
<H3><A NAME="push_reciprocal_of_quantum"><U>push_reciprocal_of_quantum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_reciprocal_of_quantum (<A HREF="#ESQ">ESQ</A> q);</TD></TR></TABLE></P>
<P><B>Pushes on the EStack the reciprocal of the argument as a tagged positive fraction.</B></P>

<P>This function assumes that its argument is strictly superior to 1.</P>

<P>See also: <A HREF="#push_minus_recip_of_quantum">push_minus_recip_of_quantum</A>, <A HREF="#push_quantum_as_nonnegative_int">push_quantum_as_nonnegative_int</A>, <A HREF="#push_negate_quantum_as_negint">push_negate_quantum_as_negint</A>, <A HREF="#push_quantum_pair_as_pos_frac">push_quantum_pair_as_pos_frac</A></P>
<HR>
<H3><A NAME="push_reversed_tail"><U>push_reversed_tail</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_reversed_tail (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Pushes elements of the list up to tail onto the stack in reversed order.</B></P>

<P>push_reversed_tail first pushes <A HREF="#END_TAG">END_TAG</A> to the expression stack,
then pushes all expressions starting from the expression pointed to by <I>ptr</I>
one by one (by calling <A HREF="#next_expression_index">next_expression_index</A>)
until <A HREF="#END_TAG">END_TAG</A> is reached. So after calling this function, the
expressions up to tail will be pushed onto the stack in reversed order. See other
"tail" operations like <A HREF="#map_tail">map_tail</A>.</P>

<HR>
<H3><A NAME="push_round_Float"><U>push_round_Float</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_round_Float (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Pushes an approximation of a floating point entry.</B></P>

<P>push_round_Float first finds a rational approximation of the floating point entry pointed
to by <I>ptr</I> using <A HREF="#push_Float_to_rat">push_Float_to_rat</A>, then converts
this fraction back to the floating point number and pushes it on the top of the expressions
stack. The summary effect is rounding float to the precision of about 1e-5.</P>

<HR>
<H3><A NAME="push_shortint"><U>push_shortint</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_shortint (<B><A HREF="keywords.html#short">short</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes a short integer to the expression stack.</B></P>

<P>push_shortint pushes the short integer value <I>value</I> to the expression stack.
<BR><BR>
<B>Note:</B> push_shortint is not a TIOS entry; it is implemented "by hand" using
<A HREF="#push_quantum">push_quantum</A>. This means that either
push_shortint or <A HREF="#push_longint">push_longint</A> should be used in a
program, but using both is usually not desirable.</P>

<P>See also: <A HREF="#push_longint">push_longint</A>, <A HREF="#push_longlongint">push_longlongint</A></P>
<HR>
<H3><A NAME="push_simplify"><U>push_simplify</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_simplify (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Simplifies the argument and pushes onto the estack.</B></P>

<P>push_simplify is like <A HREF="#push_internal_simplify">push_internal_simplify</A>, but
does not convert into internal canonic form.</P>

<HR>
<H3><A NAME="push_transpose_aux"><U>push_transpose_aux</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_transpose_aux (<A HREF="#CESI">CESI</A> ptr, <B><A HREF="keywords.html#short">short</A></B> ConjFlag);</TD></TR></TABLE></P>
<P><B>Pushes transposed matrix to the expression stack.</B></P>

<P>Assuming that <I>ptr</I> points to the tag of a matrix (which is, in fact,
a list of equally sized lists), push_transpose_aux pushes the transpose
of the matrix to the expression stack. If <I>ConjFlag</I> is
<A HREF="alloc.html#Bool">TRUE</A>, a complex conjugate transpose will be produced,
and if <I>ConjFlag</I> is <A HREF="alloc.html#Bool">FALSE</A>, an ordinary
transpose will be produced. For complex conjugate transposition, the matrix
should be in canonic internal form (see <A HREF="#push_internal_simplify">push_internal_simplify</A>).
If <I>ptr</I> doesn't point to a matrix, the behavior is unpredictable.</P>

<HR>
<H3><A NAME="push_ulong_to_integer"><U>push_ulong_to_integer</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_ulong_to_integer (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes an unsigned long integer to the expression stack.</B></P>

<P>push_ulong_to_integer pushes the long integer value <I>value</I> to the expression stack.
It is the same as <A HREF="#push_long_to_integer">push_long_to_integer</A>,
except that the value is interpreted as an unsigned value.</P>

<P>See also: <A HREF="#push_long_to_integer">push_long_to_integer</A>, <A HREF="#push_ushort_to_integer">push_ushort_to_integer</A>, <A HREF="#push_longint">push_longint</A></P>
<HR>
<H3><A NAME="push_ushort_to_integer"><U>push_ushort_to_integer</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_ushort_to_integer (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> value);</TD></TR></TABLE></P>
<P><B>Pushes an unsigned short integer to the expression stack.</B></P>

<P>push_ushort_to_integer pushes the short integer value <I>value</I> to the expression stack.
It is the same as <A HREF="#push_shortint">push_shortint</A>, except
that the value is interpreted as an unsigned value, and that it is
implemented in the operating system instead of by GCC4TI.</P>

<P>See also: <A HREF="#push_long_to_integer">push_long_to_integer</A>, <A HREF="#push_ulong_to_integer">push_ulong_to_integer</A>, <A HREF="#push_shortint">push_shortint</A></P>
<HR>
<H3><A NAME="push_zstr"><U>push_zstr</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> push_zstr (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *str);</TD></TR></TABLE></P>
<P><B>Pushes a standard C string to the expression stack.</B></P>

<P>push_zstr pushes the string <I>str</I> to the expression stack. <I>str</I>
is a standard ANSI (zero-terminated) string.</P>

<HR>
<H3><A NAME="raise_to_top"><U>raise_to_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> raise_to_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Raises a value to the power given by the expression on the top of the EStack.</B></P>

<P>raise_to_top raises the expression pointed to by <I>ptr</I> to the power indicated
by the expression currently at the top of the EStack, and stores the result to the
top of the EStack, in place of the expression that was used as power.</P>

<HR>
<H3><A NAME="re_index"><U>re_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> re_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of the real part of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#COMPLEX_TAG">COMPLEX_TAG</A>
(i.e. if the expression is complex), re_index returns the pointer
to the real part of the expression. If <I>ptr</I> does not point to the
<A HREF="#COMPLEX_TAG">COMPLEX_TAG</A> (i.e. if the expression is real),
re_index returns <I>ptr</I> (i.e. the pointer to the expression itself).
<BR><BR>
<B>Note:</B> The expression should be in internal canonic form
(see <A HREF="#push_internal_simplify">push_internal_simplify</A>), else this function
is not reliable.</P>

<HR>
<H3><A NAME="reductum_index"><U>reductum_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> reductum_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of remaining terms of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#ADD_TAG">ADD_TAG</A>, which is a case when it
points to an expression of form <I>term1</I>&nbsp;+&nbsp;<I>term2</I>&nbsp;+&nbsp;<B>...</B>
(i.e. if the expression is a sum of simpler terms), reductum_index returns the pointer
to the subexpression <I>term2</I>&nbsp;+&nbsp;<B>...</B> (which is a reductum
subexpression of the given expression). If <I>ptr</I> does not point to the
<A HREF="#ADD_TAG">ADD_TAG</A> (i.e. if the expression is not a sum of simpler terms),
reductum_index returns a pointer to a simple zero expression, i.e. expression which
consists only of number 0 (floating point or integer,
depending of whether the approximation mode is active or not).
<BR><BR>
<B>Note:</B> Expressions in internal canonic form have the most main term
shallowest (see <A HREF="#lead_term_index">lead_term_index</A>. So, the reductum of
<CODE>'2+x+y'</CODE> converted to canonic form is <CODE>'y+2'</CODE>.
By default, similar powers of the main variable are collected in internal canonic forms.
For example, the reductum of <CODE>'x^2*y+x^2+5'</CODE> converted to canonic form is
<CODE>'5'</CODE>. See <A HREF="#push_internal_simplify">push_internal_simplify</A>
for more info about how to convert an expression into the internal canonic form.</P>

<HR>
<H3><A NAME="remaining_element_count"><U>remaining_element_count</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> remaining_element_count (<A HREF="#CESI">CESI</A> start_ptr);</TD></TR></TABLE></P>
<P><B>Returns number of elements remaining.</B></P>

<P>remaining_element_count counts how many expressions are stored on the expressions
stack below the expression pointed to by <I>ptr</I> (including this one).
<A HREF="#END_TAG">END_TAG</A> is treated as the terminator, so eventual expressions
below <A HREF="#END_TAG">END_TAG</A> are not counted. So, if <I>ptr</I> points to
an element of the list, remaining_element_count returns the number of elements
in the list starting from this element up to the end of the list.
<BR><BR>
remaining_element_count works using repeated calling <A HREF="#next_expression_index">next_expression_index</A>
and increasing a counter until <A HREF="#END_TAG">END_TAG</A> is reached.</P>

<HR>
<H3><A NAME="remaining_factors_index"><U>remaining_factors_index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> remaining_factors_index (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Gets the index of remaining factors of an expression.</B></P>

<P>If <I>ptr</I> points to the <A HREF="#MUL_TAG">MUL_TAG</A>, which is a case when it
points to an expression of form <I>factor1</I>&nbsp;*&nbsp;<I>factor2</I>&nbsp;*&nbsp;<B>...</B>
(i.e. if the expression is a sum of simpler terms), remaining_factors_index returns the pointer
to the subexpression <I>term2</I>&nbsp;*&nbsp;<B>...</B> (i.e. to the remaining
factors of the expression). If <I>ptr</I> does not point to the
<A HREF="#MUL_TAG">MUL_TAG</A> (i.e. if the expression is not a product of simpler factors),
remaining_factors_index returns a pointer to a simple expression which
consists only of number 1.
<BR><BR>
<B>Note:</B> Expressions in internal canonic form have the most main factor shallowest, with less main factors
below that (see <A HREF="#compare_expressions">compare_expressions</A> for more info about "main"
ordering). Also, the lead factor of an internally-simplified product is never a product.
For example, remaining factors of <CODE>'(3*x^2)*y'</CODE> converted into canonic form
are <CODE>'3*y'</CODE>. By default, similar powers of the main variable are collected, so
remaining factor of <CODE>'x^2*y+x^2'</CODE> after conversion into canonic form is
<CODE>'y+1'</CODE>. Internally-simplified numeric denominator factors are combined with
numeric numerator factors into a fractional numeric factor. Non-numeric denominator
factors are internally simplified to be merged with numerator factors as negative powers.
See <A HREF="#push_internal_simplify">push_internal_simplify</A>
for more info about how to convert an expression into the internal canonic form.</P>

<HR>
<H3><A NAME="replace_top_with_post_simplified"><U>replace_top_with_post_simplified</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top_with_post_simplified (<A HREF="#ESI">ESI</A> prev_top);</TD></TR></TABLE></P>
<P><B>Replaces the expression on top of the EStack, in internal form, with the external (printing) form.</B></P>

<P>See <A HREF="#display_statements">display_statements</A> and
<A HREF="#top_estack">top_estack</A> for more information about the external form.<BR>
<I>prev_top</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#display_statements">display_statements</A>, <A HREF="#top_estack">top_estack</A>, <A HREF="#push_simplify">push_simplify</A>, <A HREF="#push_internal_simplify">push_internal_simplify</A></P>
<HR>
<H3><A NAME="replace_top_with_reciprocal"><U>replace_top_with_reciprocal</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top_with_reciprocal (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Replaces the expression on top of the EStack by its reciprocal.</B></P>

<P>replace_top_with_reciprocal computes the reciprocal of the expression currently
at the top of the EStack, and stores the result in place of the expression.</P>

<HR>
<H3><A NAME="replace_top2_with_and"><U>replace_top2_with_and</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_and (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by their logical AND.</B></P>

<P>The following code:</P>
<PRE>push_quantum(TRUE_TAG);
ptr = top_estack;
push_quantum(FALSE_TAG);
replace_top2_with_and(ptr);
</PRE>
<P>will leave the false expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#replace_top2_with_or">replace_top2_with_or</A></P>
<HR>
<H3><A NAME="replace_top2_with_difference"><U>replace_top2_with_difference</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_difference (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by their difference.</B></P>

<P>The following code:</P>
<PRE>push_quantum(VAR_A_TAG);
ptr = top_estack;
push_quantum(VAR_B_TAG);
replace_top2_with_difference(ptr);
</PRE>
<P>will leave the a - b expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#replace_top2_with_sum">replace_top2_with_sum</A></P>
<HR>
<H3><A NAME="replace_top2_with_imre"><U>replace_top2_with_imre</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_imre (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by a complex number.</B></P>

<P>The following code:</P>
<PRE>push_quantum(VAR_A_TAG);
ptr = top_estack;
push_quantum(VAR_B_TAG);
replace_top2_with_imre(ptr);
</PRE>
<P>will leave the a + b * <B><I>i</I></B> expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<HR>
<H3><A NAME="replace_top2_with_or"><U>replace_top2_with_or</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_or (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by their logical OR.</B></P>

<P>The following code:</P>
<PRE>push_quantum(TRUE_TAG);
ptr = top_estack;
push_quantum(FALSE_TAG);
replace_top2_with_or(ptr);
</PRE>
<P>will leave the true expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#replace_top2_with_and">replace_top2_with_and</A></P>
<HR>
<H3><A NAME="replace_top2_with_pow"><U>replace_top2_with_pow</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_pow (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by a power.</B></P>

<P>The following code:</P>
<PRE>push_quantum(VAR_A_TAG);
ptr = top_estack;
push_quantum(VAR_B_TAG);
replace_top2_with_pow(ptr);
</PRE>
<P>will leave the b ^ a expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<HR>
<H3><A NAME="replace_top2_with_prod"><U>replace_top2_with_prod</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_prod (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by their product.</B></P>

<P>The following code:</P>
<PRE>push_quantum(VAR_A_TAG);
ptr = top_estack;
push_quantum(VAR_B_TAG);
replace_top2_with_prod(ptr);
</PRE>
<P>will leave the a * b expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#replace_top2_with_ratio">replace_top2_with_ratio</A></P>
<HR>
<H3><A NAME="replace_top2_with_ratio"><U>replace_top2_with_ratio</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_ratio (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by their ratio.</B></P>

<PRE>push_quantum(VAR_A_TAG);
ptr = top_estack;
push_quantum(VAR_B_TAG);
replace_top2_with_ratio(ptr);
</PRE>
<P>will leave the a / b expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#replace_top2_with_prod">replace_top2_with_prod</A></P>
<HR>
<H3><A NAME="replace_top2_with_sum"><U>replace_top2_with_sum</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> replace_top2_with_sum (<A HREF="#ESI">ESI</A> expr);</TD></TR></TABLE></P>
<P><B>Replace the two top-most expressions on the EStack by their sum.</B></P>

<P>The following code:</P>
<PRE>push_quantum(VAR_A_TAG);
ptr = top_estack;
push_quantum(VAR_B_TAG);
replace_top2_with_sum(ptr);
</PRE>
<P>will leave the a + b expression on the EStack.<BR>
<I>expr</I> should usually be <CODE>next_expression_index(top_estack)</CODE>.</P>

<P>See also: <A HREF="#replace_top2_with_difference">replace_top2_with_difference</A></P>
<HR>
<H3><A NAME="reset_control_flags"><U>reset_control_flags</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> reset_control_flags (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Resets the control flags for operations with the expression stack.</B></P>

<P>reset_control_flags resets various control flags which control operations which
use the expression stack. It is good idea to call this function before starting
any calculation using the expression stack.</P>

<HR>
<H3><A NAME="reset_estack_size"><U>reset_estack_size</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> reset_estack_size (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> NewSize);</TD></TR></TABLE></P>
<P><B>Reallocates the expression stack.</B></P>

<P>reset_estack_size changes the size of the expression stack to <I>NewSize</I>. It
throws an error if the requirement cannot be satisfied. If <I>NewSize</I> is smaller
than the current amount of used space, then the expression stack is set to the
current amount of used space instead of <I>NewSize</I>. Default size of the
expression stack is 16384 bytes.</P>

<HR>
<H3><A NAME="should_and_did_push_approx_arg2"><U>should_and_did_push_approx_arg2</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> should_and_did_push_approx_arg2 (<A HREF="#CESI">CESI</A> arg1_ptr, <A HREF="#CESI">CESI</A> arg2_ptr);</TD></TR></TABLE></P>
<P><B>Pushes a second floating point argument, if possible.</B></P>

<P>This function is combination of "push" and "check" operations. If the entry on the expressions
stack pointed to by <I>arg1_ptr</I> is not a floating point number (i.e. if <I>arg1_ptr</I>
does not point to <A HREF="#FLOAT_TAG">FLOAT_TAG</A>), this function does nothing and returns
<A HREF="alloc.html#Bool">FALSE</A>. Otherwise, it checks if it is likely that the entry on the expression stack
pointed to by <I>arg2_ptr</I> can be approxed to a real number (using
<A HREF="#likely_approx_to_number">likely_approx_to_number</A>). If it is,
should_and_did_push_approx_arg2 pushes the approximated value to the expression stack and returns
<A HREF="alloc.html#Bool">TRUE</A>, otherwise it does nothing more and returns <A HREF="alloc.html#Bool">FALSE</A>.</P>

<HR>
<H3><A NAME="signum_Float"><U>signum_Float</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> signum_Float (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Finds the signum of a floating point entry.</B></P>

<P>signum_Float finds the signum of the floating point entry pointed to by <I>ptr</I>
(i.e. returns 1 if the entry is positive, -1 if it
is negative, 0 if it is zero). If the entry is not a floating point number, the
result is garbage.</P>

<HR>
<H3><A NAME="subtract_from_top"><U>subtract_from_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> subtract_from_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Subtracts a value from the top of the EStack.</B></P>

<P>subtract_from_top subtracts the expression pointed to by <I>ptr</I> from the expression
currently at the top of the EStack and stores the result to the top of the EStack,
in place of the expression that was substracted from.</P>

<P>See also: <A HREF="#add_to_top">add_to_top</A>, <A HREF="#negate_top">negate_top</A>, <A HREF="#subtract1_from_top">subtract1_from_top</A></P>
<HR>
<H3><A NAME="subtract1_from_top"><U>subtract1_from_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> subtract1_from_top (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Subtracts 1 from the top of the EStack.</B></P>

<P>subtract1_from_top subtracts 1 (or 1.0) from the value on the top of the EStack. This routine basically calls
<A HREF="#add_to_top">add_to_top</A> with "-1" as the pointed-to value.</P>

<P>See also: <A HREF="#subtract_from_top">subtract_from_top</A>, <A HREF="#add1_to_top">add1_to_top</A></P>
<HR>
<H3><A NAME="times_top"><U>times_top</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.02 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> times_top (<A HREF="#CESI">CESI</A> ptr);</TD></TR></TABLE></P>
<P><B>Multiplies the expression onto the EStack.</B></P>

<P>times_top multiplies the expression currently at the top of the EStack by
the expression pointed to by <I>ptr</I>, and stores the result to the top of
the estack, in place of the expression that was multiplied.</P>

<HR>
<H3><A NAME="TokenizeSymName"><U>TokenizeSymName</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> TokenizeSymName (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *src, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> Flags);</TD></TR></TABLE></P>
<P><B>Tokenizes a C string into a symbol name.</B></P>

<P>TokenizeSymName converts a symbol name pointed to by <I>src</I>,
which is an ordinary ANSI C string, into a tokenized form, and pushes the
tokenized form on the expression stack.
After pushing, the new value of <A HREF="#top_estack">top_estack</A>
points to the variable tag on the expression stack. TokenizeSymName returns
the old value of <A HREF="#top_estack">top_estack</A> (which you
can use to restore <A HREF="#top_estack">top_estack</A>), or
<A HREF="#NULL_INDEX">NULL_INDEX</A> if the symbol name was invalid.
<BR><BR>
The parameter <I>Flags</I> is a set of binary flags from
<A HREF="#TokenizeSymNameFlags">TokenizeSymNameFlags</A> with the
following meaning:
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR>
<TD>TSF_FULLY_QUALIFIED</TD>
<TD>Add current default folder to the name if no folder specified in the
name (do not use if tokenizing standalone folder names).</TD>
</TR>
<TR>
<TD>TSF_ALLOW_RESERVED</TD>
<TD>Allow reserved names to be tokenized (otherwise they cause throwing an
error).</TD>
</TR>
<TR>
<TD>TSF_PASS_ERRORS</TD>
<TD>Throw errors instead of returning <A HREF="#NULL_INDEX">NULL_INDEX</A>.</TD>
</TR>
</TABLE>
<BR>
<B>Note:</B> This routine may cause heap compression.</P>

<P>See also: <A HREF="vat.html#StrToTokN">StrToTokN</A></P>
<HR>
<H3><A NAME="ARb_int_count"><U>ARb_int_count</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESQ">ESQ</A> ARb_int_count;</TD></TR></TABLE></P>
<P><B>Represents the number of times arbitrary-integer variables were already used by some calculus.</B></P>

<P>Arbitrary-integer variables (of the form "@n<I>x</I>") are generated by TI-Basic function calls such as <CODE>solve(sin(x)=0,x)</CODE>.
<BR><BR>
This variable is set to 0 every time the calculator is reset, or if
<A HREF="bascmd.html#cmd_clrhome">cmd_clrhome</A> is called.
ARb_int_count wraps back to 0 after 255.</P>

<P>See also: <A HREF="#ARb_real_count">ARb_real_count</A>, <A HREF="bascmd.html#cmd_clrhome">cmd_clrhome</A>, <A HREF="bascmd.html#cmd_newprob">cmd_newprob</A></P>
<HR>
<H3><A NAME="ARb_real_count"><U>ARb_real_count</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESQ">ESQ</A> ARb_real_count;</TD></TR></TABLE></P>
<P><B>Represents the number of times arbitrary variables were already used by some calculus.</B></P>

<P>Arbitrary variables (of the form "@<I>x</I>") are generated by TI-Basic function calls such as <CODE>zeros(0,x)</CODE>.
<BR><BR>
This variable is set to 0 every time the calculator is reset, or if
<A HREF="bascmd.html#cmd_clrhome">cmd_clrhome</A> is called.
ARb_real_count wraps back to 0 after 255.</P>

<P>See also: <A HREF="#ARb_int_count">ARb_int_count</A>, <A HREF="bascmd.html#cmd_clrhome">cmd_clrhome</A>, <A HREF="bascmd.html#cmd_newprob">cmd_newprob</A></P>
<HR>
<H3><A NAME="bottom_estack"><U>bottom_estack</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#CESI">CESI</A> bottom_estack;</TD></TR></TABLE></P>
<P><B>Points to the bottom of the expression stack.</B></P>

<P>bottom_estack is a global variable which points to the bottom of the
expression stack, i.e. the first byte used. The quantum at bottom_estack
is always <A HREF="#ENDSTACK_TAG">ENDSTACK_TAG</A>. Usually, you should not
change this pointer, although it seems that it is possible to change it
temporarily. If you do this, however, you need to make sure that it is
changed back in any case, even if an error occurs.
<BR><BR>
This variable can be used together with
<A HREF="#top_estack">top_estack</A> to determine the amount of memory
on the expression stack which is currently used.
<BR><BR>
The following example (called "Print EStack") prints the values of
bottom_estack and <A HREF="#top_estack">top_estack</A>:</P>
<PRE>// Print bottom_estack and top_estack

#define USE_TI89              // Compile for TI-89
#define USE_TI92PLUS          // Compile for TI-92 Plus
#define USE_V200              // Compile for V200

#define MIN_AMS 100           // Compile for AMS 1.00 or higher
#define SAVE_SCREEN           // Save/Restore LCD Contents

#include &lt;tigcclib.h&gt;         // Include All Header Files

// Main Function
void _main(void)
{
  ClrScr ();
  printf_xy (0, 40, &quot;Bottom = 0x%lp&quot;, bottom_estack);
  printf_xy (0, 50, &quot;Top = 0x%lp&quot;, top_estack);
  ngetchx ();
}
</PRE>

<P>See also: <A HREF="#top_estack">top_estack</A>, <A HREF="#estack_max_index">estack_max_index</A></P>
<HR>
<H3><A NAME="command_tag_list"><U>command_tag_list</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#const">const</A></B> <A HREF="#cmd_info">cmd_info</A> *<B><A HREF="keywords.html#const">const</A></B> command_tag_list;</TD></TR></TABLE></P>
<P><B>Array of structures containing information on <A HREF="#InstructionTags">InstructionTags</A>.</B></P>

<HR>
<H3><A NAME="estack_max_index"><U>estack_max_index</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#CESI">CESI</A> estack_max_index;</TD></TR></TABLE></P>
<P><B>Points to the end of the expression stack.</B></P>

<P>This is the address of the highest usable byte of the expression stack.</P>

<P>See also: <A HREF="#top_estack">top_estack</A>, <A HREF="#bottom_estack">bottom_estack</A></P>
<HR>
<H3><A NAME="Float0Index"><U>Float0Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Float0Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value 0.0.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack, rather than with
<A HREF="timath.html">timath.h</A> functions.</P>

<HR>
<H3><A NAME="Float1Index"><U>Float1Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Float1Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value 1.0.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack, rather than with
<A HREF="timath.html">timath.h</A> functions.</P>

<HR>
<H3><A NAME="FloatExp1Index"><U>FloatExp1Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> FloatExp1Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value <I>e</I>.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack, rather than with
<A HREF="timath.html">timath.h</A> functions.</P>

<HR>
<H3><A NAME="FloatHalfIndex"><U>FloatHalfIndex</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> FloatHalfIndex;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value 0.5.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack, rather than with
<A HREF="timath.html">timath.h</A> functions.</P>

<HR>
<H3><A NAME="FloatMinus1Index"><U>FloatMinus1Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> FloatMinus1Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value -1.0.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack, rather than with
<A HREF="timath.html">timath.h</A> functions.</P>

<HR>
<H3><A NAME="FloatPiIndex"><U>FloatPiIndex</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> FloatPiIndex;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (FLOAT_TAG) of a 14-digit tagged floating-point value <I>pi</I>.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack, rather than with
<A HREF="timath.html">timath.h</A> functions.</P>

<HR>
<H3><A NAME="FLOATTAB"><U>FLOATTAB</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.00 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#float">float</A></B> * <B><A HREF="keywords.html#const">const</A></B> FLOATTAB;</TD></TR></TABLE></P>
<P><B>A pointer to an array of more or less commonly used <U>untagged</U> floats.</B></P>

<P>Elements of this array are:
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP">FPI_TWOPI</TD><TD VALIGN="TOP">2*pi</TD></TR>
<TR><TD VALIGN="TOP">FPI_ONEPI</TD><TD VALIGN="TOP">pi</TD></TR>
<TR><TD VALIGN="TOP">FPI_PIDIV2</TD><TD VALIGN="TOP">pi/2</TD></TR>
<TR><TD VALIGN="TOP">FPI_PIDIV4</TD><TD VALIGN="TOP">pi/4</TD></TR>
<TR><TD VALIGN="TOP">FPI_360</TD><TD VALIGN="TOP">360.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_180</TD><TD VALIGN="TOP">180.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_90</TD><TD VALIGN="TOP">90.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_45</TD><TD VALIGN="TOP">45.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_180DIVPI</TD><TD VALIGN="TOP">180/pi</TD></TR>
<TR><TD VALIGN="TOP">FPI_PIDIV180</TD><TD VALIGN="TOP">pi/180</TD></TR>
<TR><TD VALIGN="TOP">FPI_0</TD><TD VALIGN="TOP">0.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_PT001</TD><TD VALIGN="TOP">0.001</TD></TR>
<TR><TD VALIGN="TOP">FPI_PT1</TD><TD VALIGN="TOP">0.1</TD></TR>
<TR><TD VALIGN="TOP">FPI_PIDIV24 </TD><TD VALIGN="TOP">pi/24</TD></TR>
<TR><TD VALIGN="TOP">FPI_PT5</TD><TD VALIGN="TOP">0.5</TD></TR>
<TR><TD VALIGN="TOP">FPI_PT9</TD><TD VALIGN="TOP">0.9</TD></TR>
<TR><TD VALIGN="TOP">FPI_1</TD><TD VALIGN="TOP">1.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_MINUS1</TD><TD VALIGN="TOP">-1.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_SQRT2</TD><TD VALIGN="TOP">sqrt(2)</TD></TR>
<TR><TD VALIGN="TOP">FPI_2</TD><TD VALIGN="TOP">2.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_3</TD><TD VALIGN="TOP">3.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_2PI12</TD><TD VALIGN="TOP">2*pi (12 digits precision)</TD></TR>
<TR><TD VALIGN="TOP">FPI_10</TD><TD VALIGN="TOP">10.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_MINUS10</TD><TD VALIGN="TOP">-10.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_12</TD><TD VALIGN="TOP">12.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_14</TD><TD VALIGN="TOP">14.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_20</TD><TD VALIGN="TOP">20.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_70</TD><TD VALIGN="TOP">70.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_BIGGEST</TD><TD VALIGN="TOP">10^1000</TD></TR>
<TR><TD VALIGN="TOP">FPI_NEGBIGGEST</TD><TD VALIGN="TOP">-10^1000</TD></TR>
<TR><TD VALIGN="TOP">FPI_16000</TD><TD VALIGN="TOP">16000.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_MINUS16000</TD><TD VALIGN="TOP">-16000.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_32767</TD><TD VALIGN="TOP">32767.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_MINUS32768</TD><TD VALIGN="TOP">-32768.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_65535</TD><TD VALIGN="TOP">65535.0</TD></TR>
<TR><TD VALIGN="TOP">FPI_1E14</TD><TD VALIGN="TOP">1.0e14</TD></TR>
<TR><TD VALIGN="TOP">FPI_INVALID</TD><TD VALIGN="TOP">NAN</TD></TR>
<TR><TD VALIGN="TOP">FPI_LOGE</TD><TD VALIGN="TOP">log(<I>e</I>)</TD></TR>
<TR><TD VALIGN="TOP">FPI_POS0</TD><TD VALIGN="TOP">positive zero</TD></TR>
<TR><TD VALIGN="TOP">FPI_NEG0</TD><TD VALIGN="TOP">negative zero</TD></TR>
<TR><TD VALIGN="TOP">FPI_POSINF</TD><TD VALIGN="TOP">+infinity</TD></TR>
<TR><TD VALIGN="TOP">FPI_NEGINF</TD><TD VALIGN="TOP">-infinity</TD></TR>
<TR><TD VALIGN="TOP">FPI_UNSINF</TD><TD VALIGN="TOP">infinity</TD></TR>
</TABLE>
<BR>
The FPI_... constants are defined in enum <A HREF="#FLOATTABIndexes">FLOATTABIndexes</A>.<BR>
<BR>
Of course, not all these values may be stored anywhere without problems. For instance,
<A HREF="vat.html#VarStore">VarStore</A> can throw errors if you write invalid values to system variables.</P>

<P>See also: <A HREF="#FLOATTABIndexes">FLOATTABIndexes</A></P>
<HR>
<H3><A NAME="index_false"><U>index_false</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> index_false;</TD></TR></TABLE></P>
<P><B>Pointer on a <CODE>FALSE_TAG</CODE> (0x2B) stored in the Flash.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack.</P>

<HR>
<H3><A NAME="index_true"><U>index_true</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> index_true;</TD></TR></TABLE></P>
<P><B>Pointer on a <CODE>TRUE_TAG</CODE> (0x2C) stored in the Flash.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack.</P>

<HR>
<H3><A NAME="Integer0Index"><U>Integer0Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Integer0Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (POSINT_TAG) of an integer value 0.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack.</P>

<HR>
<H3><A NAME="Integer1Index"><U>Integer1Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Integer1Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (POSINT_TAG) of an integer value 1.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack.</P>

<HR>
<H3><A NAME="Integer2Index"><U>Integer2Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> Integer2Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (POSINT_TAG) of an integer value 2.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack.</P>

<HR>
<H3><A NAME="IntegerMinus1Index"><U>IntegerMinus1Index</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 2.04 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> IntegerMinus1Index;</TD></TR></TABLE></P>
<P><B>Pointer to the end tag (NEGINT_TAG) of an integer value -1.</B></P>

<P>This variable is meant to be used with functions dealing with the EStack.</P>

<HR>
<H3><A NAME="primary_tag_list"><U>primary_tag_list</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#const">const</A></B> <A HREF="#tag_info">tag_info</A> *<B><A HREF="keywords.html#const">const</A></B> primary_tag_list;</TD></TR></TABLE></P>
<P><B>Array of structures containing information on <A HREF="#Tags">Tags</A>.</B></P>

<HR>
<H3><A NAME="secondary_tag_list"><U>secondary_tag_list</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#const">const</A></B> <A HREF="#tag_info">tag_info</A> *<B><A HREF="keywords.html#const">const</A></B> secondary_tag_list;</TD></TR></TABLE></P>
<P><B>Array of structures containing information on <A HREF="#ExtTags">ExtTags</A>.</B></P>

<HR>
<H3><A NAME="sysvar_tag_list"><U>sysvar_tag_list</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#const">const</A></B> <A HREF="#sysvar_info">sysvar_info</A> *<B><A HREF="keywords.html#const">const</A></B> sysvar_tag_list;</TD></TR></TABLE></P>
<P><B>Array of structures containing information on <A HREF="#SysvarTags">SysvarTags</A>.</B></P>

<HR>
<H3><A NAME="top_estack"><U>top_estack</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#ESI">ESI</A> top_estack;</TD></TR></TABLE></P>
<P><B>Points to the top of the expression stack.</B></P>

<P>The global variable top_estack points to the top (i.e. the last byte) of the expression stack.
Strictly speaking, in "nostub" mode it is not a real variable but smart macro, although it
works like it is a variable. The expression stack is the place in the memory where TI keeps
expressions during evaluation. All statements are tokenized before being executed
(interpreted). Instructions are reduced to (byte sized) quanta and parsed into Reverse
Polish Notation (RPN). This is a common technique in interpreted languages. Expressions,
functions, etc. are all stored in RPN form, to allow for efficient operation of the expressions
stack. See below for more details about organization of the expression stack.
<BR><BR>
The actual processing of all expressions is done via the expression stack. The position in the
stack is given by top_estack. Pushing a value appends it to the expression stack and increments
top_estack. When a expression is interpreted, expressions are reduced, and executed as far as
possible. Whatever remains on the stack is the result, this may then be stored or processed
later.
<BR><BR>
When a file is interpreted the end of the variable is found and it is processed as a separate
expression stack. It is then processed recursively, producing a simplified version on the real
expression stack. Expressions are therefore interpreted from the top (high memory) recursively.
<BR><BR>
As an artefact of expressions processing mechanism, the arguments of the called program are
kept also on the expression stack. It grows upwards, and the last argument is stored first.
After the assembly program is called, the image of the expression stack is as follows:</P>
<UL>
<LI><P>The first byte (i.e. the byte with the lowest address) on the stack is <A HREF="#END_TAG">END_TAG</A> (0xE5).</P></LI>
<LI><P>Then, a argument list follows, starting from the last argument up to the first
argument. So, top_estack points to the last byte of the first argument.</P></LI>
</UL>
<P>Each string entry on the expression stack is stored as follows (from lower to higher addresses):</P>
<UL>
<LI><P>One zero byte (starting tag);</P></LI>
<LI><P>Content of the string;</P></LI>
<LI><P>Terminating zero byte;</P></LI>
<LI><P>Byte <A HREF="#STR_TAG">STR_TAG</A> (0x2D).</P></LI>
</UL>
<P>Each integer entry is stored as follows:</P>
<UL>
<LI><P>Bytes of the number in little endian format (i.e. the lowest byte is stored first);
the number of bytes varies depending of the size of the number;</P></LI>
<LI><P>A byte which represents the number of the bytes which made the number
(note that zero has zero-byte length);</P></LI>
<LI><P>Byte <A HREF="#POSINT_TAG">POSINT_TAG</A> (0x1F) or <A HREF="#NEGINT_TAG">NEGINT_TAG</A> (0x20), depending whether the number is
positive or negative (for negative numbers, previous bytes contain the absolute
value).</P></LI>
</UL>
<P>Each fraction entry is stored as follows:</P>
<UL>
<LI><P>Bytes of the denominator in little endian format (i.e. the lowest byte is stored first);
the number of bytes varies depending of the size of the number;</P></LI>
<LI><P>A byte which represents the number of the bytes which made the denominator;</P></LI>
<LI><P>Bytes of the numerator in little endian format;</P></LI>
<LI><P>A byte which represents the number of the bytes which made the numerator;</P></LI>
<LI><P>Byte <A HREF="#POSFRAC_TAG">POSFRAC_TAG</A> (0x21) or <A HREF="#NEGFRAC_TAG">NEGFRAC_TAG</A> (0x22), depending whether the fraction is
positive or negative (for negative fractions, previous bytes contain absolute
values).</P></LI>
</UL>
<P>Each floating point entry is stored as follows:</P>
<UL>
<LI><P>Only first 9 bytes of the content of the floating point value
are stored (instead of 10), because TIOS always rounds floating point values up to 14
significant digits before pushing them on expression stack
(see <A HREF="timath.html#bcd">bcd</A> structure for more information about the internal
organization of floating point values);</P></LI>
<LI><P>The last byte is <A HREF="#FLOAT_TAG">FLOAT_TAG</A> (0x23).</P></LI>
</UL>
<P>If the entry is complex number, real part is stored first (which can be integer, float,
fraction, etc.), then imaginary part. <A HREF="#COMPLEX_TAG">COMPLEX_TAG</A> (0x9D) is stored after them, so if the
current argument type is complex, decrease the argument pointer by one, then first read
imaginary part, then real part separately.
<BR><BR>
If the entry is composite (i.e. if it is a list or a matrix), the first byte is end_of_list marker
(byte <A HREF="#END_TAG">END_TAG</A> or 0xE5), then follow each element of the list in reverse order (starting
from the last element), and the last byte is <A HREF="#LIST_TAG">LIST_TAG</A> (0xD9).
Now, you surely have an idea how you can pick up elements from the list. Note that a matrix is
a "list of lists".
<BR><BR>
Signed zeros (<A HREF="timath.html#POSITIVE_ZERO">POSITIVE_ZERO</A> and
<A HREF="timath.html#NEGATIVE_ZERO">NEGATIVE_ZERO</A>) are represented as
fractions +0/1 and -0/1.
<BR><BR>
Variable names are stored exactly like strings without terminating <A HREF="#STR_TAG">STR_TAG</A> (i.e. it is a
sequence of letters bounded with two zero bytes), so "variable" tag is just a zero byte.
There is an exception: one-letter variables have unique one-byte tags (see
<A HREF="#Tags">Tags</A> for more info. Also, note that variable names are always
stored with lowercase letters. Variables whose names ends with an underscore are assumed
to be complex, and variables whose names starts with an underscore are assumed to
represent physical units.
<BR><BR>
Expressions are stored in RPN (Reverse Polish Notation) form (also known as postfix form).
So, function calls like <I>func</I>(<I>arg1</I>,<I>arg2</I>,...<I>argn</I>) are stored as sequence
<BR><BR>
<I>argn</I> ... <I>arg2</I> <I>arg1</I> <I>func_tag</I>
<BR><BR>
and terms like <I>arg1</I>&nbsp;<I>operator</I>&nbsp;<I>arg2</I> are stored as
<I>arg1</I>&nbsp;<I>arg2</I>&nbsp;<I>operator_tag</I> or
<I>arg2</I>&nbsp;<I>arg1</I>&nbsp;<I>operator_tag</I>, depending on the concrete operator.
The situation is analogous for unary operators.
Note that a "pointer to an expression" is a pointer to the <B>last byte</B> of the expression!
When a function (or operator) has variable number of arguments, <A HREF="#END_TAG">END_TAG</A> is used to indicate "no more arguments".
See <A HREF="#Tags">Tags</A> for complete list of various tags. This will be illustrated with
some examples:
<BR><BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP">Algebraic form:</TD>
<TD>integrate (e^(x^2), x, 1, 2)</TD></TR>
<TR><TD VALIGN="TOP">RPN form:</TD>
<TD>2 1 x 2 x ^ e ^ integrate</TD></TR>
<TR><TD VALIGN="TOP">Sequence&nbsp;of&nbsp;bytes:&nbsp;&nbsp;&nbsp;</TD>
<TD>[02 01 1F] [01 01 1F] [08] [02 01 1F] [08] [93] [25] [93] [C4]
</TD></TR></TABLE>
<BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP">Algebraic form:</TD>
<TD>sum (sqrt (1 + x), x, 0, a) (where <I>sum</I> is actually the capital sigma)</TD></TR>
<TR><TD VALIGN="TOP">RPN form:</TD>
<TD>a 0 x x 1 + sqrt sum</TD></TR>
<TR><TD VALIGN="TOP">Sequence&nbsp;of&nbsp;bytes:&nbsp;&nbsp;&nbsp;</TD>
<TD>[0B] [00 1F] [08] [08] [01 01 1F] [8B] [51] [BA]
</TD></TR></TABLE>
<BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP">Algebraic form:</TD>
<TD>a + b + a - b + (a + b) * (a - b) -&gt; a</TD></TR>
<TR><TD VALIGN="TOP">RPN form:</TD>
<TD>a b + a + b - a b + a b - * + a -&gt;</TD></TR>
<TR><TD VALIGN="TOP">Sequence&nbsp;of&nbsp;bytes:&nbsp;&nbsp;&nbsp;</TD>
<TD>[0B] [0C] [8B] [0B] [8B] [0C] [8D] [0B] [0C] [8B] [0B] [0C] [8D] [8F] [8B] [0B] [80]
</TD></TR></TABLE>
<BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP">Algebraic form:</TD>
<TD>{{1, 2}, {3, 4}}</TD></TR>
<TR><TD VALIGN="TOP">RPN form:</TD>
<TD>END_TAG END_TAG 4 3 LIST_TAG END_TAG 2 1 LIST_TAG LIST_TAG</TD></TR>
<TR><TD VALIGN="TOP">Sequence&nbsp;of&nbsp;bytes:&nbsp;&nbsp;&nbsp;</TD>
<TD>[E5] [E5] [04 01 1F] [03 01 1F] [D9] [E5] [02 01 1F] [01 01 1F] [D9] [D9]
</TD></TR></TABLE>
<BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP">Algebraic form:</TD>
<TD>my_func (a, b, c)</TD></TR>
<TR><TD VALIGN="TOP">RPN form:</TD>
<TD>END_TAG c b a my_func USERFUNC_TAG</TD></TR>
<TR><TD VALIGN="TOP">Sequence&nbsp;of&nbsp;bytes:&nbsp;&nbsp;&nbsp;</TD>
<TD>[E5] [0D] [0C] [0B] [00 6D 79 5F 66 75 6E 63 00] [DA]
</TD></TR></TABLE>
<BR>
To perform some algebraic transformations on more unique way, expressions should be
transformed into an equivalent form called "internal canonic form". In such form,
for example, all constants are always in front of variables, e.g. <CODE>'x*3'</CODE> and
<CODE>'x+3'</CODE> becomes <CODE>'3*x'</CODE> and <CODE>'3+x'</CODE> (although
the second example will be printed as <CODE>'x+3'</CODE>). Also, expressions like <CODE>'x/y'</CODE> or
<CODE>'x-y'</CODE> in internal canonic form do not contain subtractions and divisions.
As the parameter list (when the program is called from TI-Basic) is always in internal
canonic form, such expressions will never be observed as-is in parameter lists
etc. because they will be converted before passing them to the program. A lot of functions
for algebraic manipulations automatically convert the expression in the internal canonic form,
but when this is not true, you can always force the conversion using explicit call to
<A HREF="#push_internal_simplify">push_internal_simplify</A> function. Note that the reverse conversion
(i.e. back from the canonic form into a regular form) is performed anytime when you try to
print out the expression. Here is the list of the most common transformations which appears
during the transformation into the internal canonic form:
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR><TD>Expression</TD><TD>Standard canonic form</TD></TR>
<TR><TD>-x</TD><TD>(-1)*x</TD></TR>
<TR><TD>x-y</TD><TD>x+y*(-1)</TD></TR>
<TR><TD>x/y</TD><TD>x*y^(-1)</TD></TR>
<TR><TD VALIGN="TOP">e^x</TD><TD>exp(x)</TD></TR>
<TR><TD VALIGN="TOP">x^y</TD><TD>exp(ln(x)*y)<BR>[ <I>except when "y" is an integer or a fraction</I> ]</TD></TR>
<TR><TD VALIGN="TOP">e</TD><TD>exp(1)</TD></TR>
<TR><TD>sqrt(x)</TD><TD>x^(1/2)</TD></TR>
<TR><TD>log(x)</TD><TD>ln(x)*(ln(10)^(-1))</TD></TR>
<TR><TD VALIGN="TOP">sin(x)</TD><TD>trig(x,0)<BR>[ <I>assuming "radian" mode; for "trig" function, see <A HREF="#SINCOS_TAG">SINCOS_TAG</A></I> ]</TD></TR>
<TR><TD>cos(x)</TD><TD>trig(x,1)</TD></TR>
<TR><TD>tan(x)</TD><TD>trig(x,0)*trig(x,1)^(-1)</TD></TR>
<TR><TD>sinh(x)</TD><TD>exp(x)*(1/2)+exp(x)^(-1)*(-1/2)</TD></TR>
<TR><TD>cosh(x)</TD><TD>exp(x)*(1/2)+exp(x)^(-1)*(1/2)</TD></TR>
<TR><TD>tanh(x)</TD><TD>(exp(x)^2+1)^(-1)*(exp(x)^2+(-1))</TD></TR>
<TR><TD>x xor y</TD><TD>(not x and y) or (x and not y)</TD></TR>
</TABLE>
<BR>
Mode dependent calculations are performed by converting expressions to a specific format,
i.e. for trigonometric functions all values are converted to radians before passing them to
radian trigonometric functions.
<BR><BR>
A variable may consist of multiple expressions, these are separated by several
special quanta: <A HREF="#NEXTEXPR_TAG">NEXTEXPR_TAG</A> and <A HREF="#NEWLINE_TAG">NEWLINE_TAG</A>.
The last expression is marked with <A HREF="#ENDSTACK_TAG">ENDSTACK_TAG</A>.
See <A HREF="#MULTI_EXPR">MULTI_EXPR</A>.
<BR><BR>
If everything mentioned above is not so clear for you, compile and run the following example
(called "Print EStack"):</P>
<PRE>// Print bottom_estack and top_estack

#define USE_TI89              // Compile for TI-89
#define USE_TI92PLUS          // Compile for TI-92 Plus
#define USE_V200              // Compile for V200

#define MIN_AMS 100           // Compile for AMS 1.00 or higher
#define SAVE_SCREEN           // Save/Restore LCD Contents

#include &lt;tigcclib.h&gt;         // Include All Header Files

// Main Function
void _main(void)
{
  ClrScr ();
  printf_xy (0, 40, &quot;Bottom = 0x%lp&quot;, bottom_estack);
  printf_xy (0, 50, &quot;Top = 0x%lp&quot;, top_estack);
  ngetchx ();
}
</PRE>
<P>Run this program in VTI and pass to it parameters as you want. top_estack will be shown
on the screen. During waiting for a keypress, enter the debugger and look at the addresses
shown, to see how parameters are stored.</P>

<P>See also: <A HREF="#bottom_estack">bottom_estack</A>, <A HREF="#estack_max_index">estack_max_index</A></P>
<HR>
<H3><A NAME="NULL_INDEX"><U>NULL_INDEX</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> NULL_INDEX ((<A HREF="#CESI">CESI</A>) 0)</TD></TR></TABLE></P>
<P><B>Describes an empty expression stack index.</B></P>

<P>NULL_INDEX is an expression stack index (<A HREF="#ESI">ESI</A>)
equivalent to <A HREF="alloc.html#NULL">NULL</A>. It can be used as a
function argument in cases where the argument is optional.</P>

<HR>
<H3><A NAME="CESI_Callback_t"><U>CESI_Callback_t</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <A HREF="gnuexts.html#SEC85">CALLBACK</A> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> (*CESI_Callback_t) (<A HREF="#CESI">CESI</A>);</TD></TR></TABLE></P>
<P><B>Represents a pointer to a CESI callback function.</B></P>

<P>CESI_Callback_t is a pointer to a function taking a <A HREF="#CESI">CESI</A>
(expression stack index with constant data) as a parameter and returning an integer.
It is used in <A HREF="#all_tail">all_tail</A> and <A HREF="#any_tail">any_tail</A>.</P>

<HR>
<H3><A NAME="CESI"><U>CESI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#const">const</A></B> <A HREF="#ESQ">ESQ</A> *CESI;</TD></TR></TABLE></P>
<P><B>Represents a pointer to a constant expression.</B></P>

<P>The type CESI acts like <A HREF="#ESI">ESI</A>, but the value pointed
to by it may have to be constant.  For example, it may be a <A HREF="#SYM_STR">SYM_STR</A>
whose contents are stored at a fixed place in the program.</P>

<HR>
<H3><A NAME="cmd_info"><U>cmd_info</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#struct">struct</A></B> {
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_version;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> min_max_args; <I>/* 4 MSB for minimal number of arguments, 4 LSB for maximal number of arguments */</I><BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> proc_args;<BR>
<B><A HREF="keywords.html#void">void</A></B> (* <A HREF="gnuexts.html#SEC85">CALLBACK</A> arg_simp) (<A HREF="#ESI">ESI</A>);<BR>
<B><A HREF="keywords.html#void">void</A></B> (* CALLBACK cmd_proc)(); <I>/* routine that handles the tag */</I><BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> tag_str; <I>/* Pointer to string data on AMS 1.xx, string ID suitable for XR_stringPtr on later AMS versions */</I><BR>
</TD></TR></TABLE>
} cmd_info;</TD></TR></TABLE></P>
<P><B>Structure containing information about AMS EStack command tags (<A HREF="#InstructionTags">InstructionTags</A>).</B></P>

<HR>
<H3><A NAME="ESI_Callback_Int_t"><U>ESI_Callback_Int_t</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <A HREF="gnuexts.html#SEC85">CALLBACK</A> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> (*ESI_Callback_Int_t) (<A HREF="#ESI">ESI</A>, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B>);</TD></TR></TABLE></P>
<P><B>Represents a pointer to an ESI callback function with integer extensions.</B></P>

<P>ESI_Callback_Int_t is a pointer to a function taking an <A HREF="#ESI">ESI</A>
(expression stack index) and an integer as a parameter and returning an integer.
It is used in <A HREF="#map_tail_Int">map_tail_Int</A>.</P>

<HR>
<H3><A NAME="ESI_Callback_t"><U>ESI_Callback_t</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <A HREF="gnuexts.html#SEC85">CALLBACK</A> <B><A HREF="keywords.html#void">void</A></B> (*ESI_Callback_t) (<A HREF="#ESI">ESI</A>);</TD></TR></TABLE></P>
<P><B>Represents a pointer to an ESI callback function.</B></P>

<P>ESI_Callback_t is a pointer to a function taking an <A HREF="#ESI">ESI</A>
(expression stack index) as a parameter and returning nothing.
It is used in <A HREF="#map_tail">map_tail</A> and <A HREF="#map_unary_over_comparison">map_unary_over_comparison</A>.</P>

<HR>
<H3><A NAME="ESI"><U>ESI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <A HREF="#ESQ">ESQ</A> *ESI;</TD></TR></TABLE></P>
<P><B>Represents an index of a value on the TIOS expression stack.</B></P>

<P>The type ESI is an "expression stack index", which is, in fact,
a pointer to a tag byte on the TIOS expression stack.
<BR><BR>
See <A HREF="#top_estack">top_estack</A> and <A HREF="#Tags">Tags</A>
for more info about the expression stack.</P>

<HR>
<H3><A NAME="ESQ"><U>ESQ</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> ESQ;</TD></TR></TABLE></P>
<P><B>Represents a quantum within an expression.</B></P>

<P>ESQ represents a quantum (the smallest meaningful unit) of an expression.
It can be a tag from the <A HREF="#Tags">Tags</A> enum, or any other
byte value.</P>

<HR>
<H3><A NAME="EStackDisplacement"><U>EStackDisplacement</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> EStackDisplacement;</TD></TR></TABLE></P>
<P><B>Type used for representing difference of two <A HREF="#ESI">ESI</A> pointers.</B></P>

<HR>
<H3><A NAME="EStackIndex"><U>EStackIndex</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> EStackIndex <A HREF="#ESI">ESI</A></TD></TR></TABLE></P>
<P><B>Represents an index of a value on the TIOS expression stack.</B></P>

<P>EStackIndex is a synonym for <A HREF="#ESI">ESI</A>.</P>

<HR>
<H3><A NAME="ExtTags"><U>ExtTags</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> ExtTags {...};</TD></TR></TABLE></P>
<P><B>An enumeration to describe extra types of entries on the expression stack.</B></P>

<P>If the tag of an entry on the expression stack is <A HREF="#EXT_TAG">EXT_TAG</A> (0xE3), then the
byte below it is the extra TI-Basic function tag. ExtTags is enumerated type for describing
such extended entries (see <A HREF="#top_estack">top_estack</A> for more info about how entries
on the expression stack are organized). This enum is quite big, and here is a complete list of
extended function tags defined in it (all values are in hex), with their meaning (used notation
is RPN):
<BR><BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP" WIDTH="30">01</TD><TD VALIGN="TOP"><A NAME="INDIR_TAG">INDIR_TAG</A></TD><TD VALIGN="TOP"><I>string_expr</I> <B>#</B> (indirection)</TD></TR>
<TR><TD VALIGN="TOP">02</TD><TD VALIGN="TOP"><A NAME="GETKEY_TAG">GETKEY_TAG</A></TD><TD VALIGN="TOP">[] <B>getKey</B></TD></TR>
<TR><TD VALIGN="TOP">03</TD><TD VALIGN="TOP"><A NAME="GETFOLD_TAG">GETFOLD_TAG</A></TD><TD VALIGN="TOP">[] <B>getFold</B></TD></TR>
<TR><TD VALIGN="TOP">04</TD><TD VALIGN="TOP"><A NAME="SWITCH_TAG">SWITCH_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>switch</B></TD></TR>
<TR><TD VALIGN="TOP">05</TD><TD VALIGN="TOP"><A NAME="UNITCONV_TAG">UNITCONV_TAG</A></TD><TD VALIGN="TOP"><I>unit1</I> <I>unit2</I> <B>&gt;</B> (unit conversion, <I>unit1</I> <B>|&gt;</B> <I>unit2</I>)</TD></TR>
<TR><TD VALIGN="TOP">06</TD><TD VALIGN="TOP"><A NAME="ORD_TAG">ORD_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <B>ord</B></TD></TR>
<TR><TD VALIGN="TOP">07</TD><TD VALIGN="TOP"><A NAME="EXPR_TAG">EXPR_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <B>expr</B></TD></TR>
<TR><TD VALIGN="TOP">08</TD><TD VALIGN="TOP"><A NAME="CHAR_TAG">CHAR_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>char</B></TD></TR>
<TR><TD VALIGN="TOP">09</TD><TD VALIGN="TOP"><A NAME="STRING_TAG">STRING_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>string</B></TD></TR>
<TR><TD VALIGN="TOP">0A</TD><TD VALIGN="TOP"><A NAME="GETTYPE_TAG">GETTYPE_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>getType</B></TD></TR>
<TR><TD VALIGN="TOP">0B</TD><TD VALIGN="TOP"><A NAME="GETMODE_TAG">GETMODE_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <B>getMode</B></TD></TR>
<TR><TD VALIGN="TOP">0C</TD><TD VALIGN="TOP"><A NAME="SETFOLD_TAG">SETFOLD_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>setFold</B></TD></TR>
<TR><TD VALIGN="TOP">0D</TD><TD VALIGN="TOP"><A NAME="PTTEST_TAG">PTTEST_TAG</A></TD><TD VALIGN="TOP"><I>y</I> <I>x</I> <B>ptTest</B></TD></TR>
<TR><TD VALIGN="TOP">0E</TD><TD VALIGN="TOP"><A NAME="PXLTEST_TAG">PXLTEST_TAG</A></TD><TD VALIGN="TOP"><I>column</I> <I>row</I> <B>pxlTest</B></TD></TR>
<TR><TD VALIGN="TOP">0F</TD><TD VALIGN="TOP"><A NAME="SETGRAPH_TAG">SETGRAPH_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <I>string</I> <B>setGraph</B></TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD VALIGN="TOP"><A NAME="SETTABLE_TAG">SETTABLE_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <I>string</I> <B>setTable</B></TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD VALIGN="TOP"><A NAME="SETMODE_TAG">SETMODE_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <I>string</I> <B>setMode</B> / <I>list</I> <B>setMode</B></TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD VALIGN="TOP"><A NAME="FORMAT_TAG">FORMAT_TAG</A></TD><TD VALIGN="TOP">[<I>string</I>] <I>expr</I> <B>format</B></TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD VALIGN="TOP"><A NAME="INSTRING_TAG">INSTRING_TAG</A></TD><TD VALIGN="TOP">[<I>start</I>] <I>substring</I> <I>search-string</I> <B>inString</B></TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD VALIGN="TOP"><A NAME="APPEND_TAG">APPEND_TAG</A></TD><TD VALIGN="TOP"><I>string1</I> <I>string2</I> <B>&amp;</B> (append)</TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD VALIGN="TOP"><A NAME="DD_TAG">DD_TAG</A></TD><TD VALIGN="TOP"><I>dmsnumber</I> <B>&gt;DD</B></TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD VALIGN="TOP"><A NAME="EXPR2DMS_TAG">EXPR2DMS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>&gt;DMS</B></TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD VALIGN="TOP"><A NAME="VEC2RECT_TAG">VEC2RECT_TAG</A></TD><TD VALIGN="TOP"><I>vec</I> <B>&gt;Rect</B></TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD VALIGN="TOP"><A NAME="VEC2POLAR_TAG">VEC2POLAR_TAG</A></TD><TD VALIGN="TOP"><I>vec</I> <B>&gt;Polar</B></TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD VALIGN="TOP"><A NAME="VEC2CYLIND_TAG">VEC2CYLIND_TAG</A></TD><TD VALIGN="TOP"><I>vec</I> <B>&gt;Cylind</B></TD></TR>
<TR><TD VALIGN="TOP">1A</TD><TD VALIGN="TOP"><A NAME="VEC2SPHERE_TAG">VEC2SPHERE_TAG</A></TD><TD VALIGN="TOP"><I>vec</I> <B>&gt;Sphere</B></TD></TR>
<TR><TD VALIGN="TOP">1B</TD><TD VALIGN="TOP"><A NAME="PARENTH_START_TAG">PARENTH_START_TAG</A></TD><TD VALIGN="TOP"><B>(</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">1C</TD><TD VALIGN="TOP"><A NAME="PARENTH_END_TAG">PARENTH_END_TAG</A></TD><TD VALIGN="TOP"><B>)</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">1D</TD><TD VALIGN="TOP"><A NAME="MAT_START_TAG">MAT_START_TAG</A></TD><TD VALIGN="TOP"><B>[</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">1E</TD><TD VALIGN="TOP"><A NAME="MAT_END_TAG">MAT_END_TAG</A></TD><TD VALIGN="TOP"><B>]</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">1F</TD><TD VALIGN="TOP"><A NAME="LIST_START_TAG">LIST_START_TAG</A></TD><TD VALIGN="TOP"><B>{</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD VALIGN="TOP"><A NAME="LIST_END_TAG">LIST_END_TAG</A></TD><TD VALIGN="TOP"><B>}</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">21</TD><TD VALIGN="TOP"><A NAME="COMMA_TAG">COMMA_TAG</A></TD><TD VALIGN="TOP"><B>,</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">22</TD><TD VALIGN="TOP"><A NAME="SEMICOLON_TAG">SEMICOLON_TAG</A></TD><TD VALIGN="TOP"><B>;</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">23</TD><TD VALIGN="TOP"><A NAME="COMPLEX_ANGLE_TAG">COMPLEX_ANGLE_TAG</A>&nbsp;&nbsp;&nbsp;</TD><TD VALIGN="TOP"><B>/_</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">24</TD><TD VALIGN="TOP"><A NAME="SINGLE_QUOTE_TAG">SINGLE_QUOTE_TAG</A></TD><TD VALIGN="TOP"><B>'</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">25</TD><TD VALIGN="TOP"><A NAME="QUOTE_TAG">QUOTE_TAG</A></TD><TD VALIGN="TOP"><B>"</B>&nbsp;&nbsp;&nbsp;(used only internally for the parser, not in expressions)</TD></TR>
<TR><TD VALIGN="TOP">26</TD><TD VALIGN="TOP"><A NAME="POLCPLX_TAG">POLCPLX_TAG</A></TD><TD VALIGN="TOP"><I>magnitude</I> <I>angle</I> <B>/_</B>&nbsp;&nbsp;&nbsp;&nbsp;(polar complex number)</TD></TR>
<TR><TD VALIGN="TOP">27</TD><TD VALIGN="TOP"><A NAME="TMPCNV_TAG">TMPCNV_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>tmpCnv</B></TD></TR>
<TR><TD VALIGN="TOP">28</TD><TD VALIGN="TOP"><A NAME="DELTA_TMPCNV_TAG">DELTA_TMPCNV_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B><FONT FACE="Symbol">D</FONT>tmpCnv</B></TD></TR>
<TR><TD VALIGN="TOP">29</TD><TD VALIGN="TOP"><A NAME="GETUNITS_TAG">GETUNITS_TAG</A></TD><TD VALIGN="TOP">[] <B>getUnits</B></TD></TR>
<TR><TD VALIGN="TOP">2A</TD><TD VALIGN="TOP"><A NAME="SETUNITS_TAG">SETUNITS_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>setUnits</B></TD></TR>
<TR><TD VALIGN="TOP">2B</TD><TD VALIGN="TOP"><A NAME="BIN_TAG">BIN_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>0b</B>&nbsp;&nbsp;&nbsp;(i.e. <B>0b</B><I>int</I>)</TD></TR>
<TR><TD VALIGN="TOP">2C</TD><TD VALIGN="TOP"><A NAME="HEX_TAG">HEX_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>0h</B>&nbsp;&nbsp;&nbsp;(i.e. <B>0h</B><I>expr</I>)</TD></TR>
<TR><TD VALIGN="TOP">2D</TD><TD VALIGN="TOP"><A NAME="INT2BIN_TAG">INT2BIN_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>&gt;Bin</B></TD></TR>
<TR><TD VALIGN="TOP">2E</TD><TD VALIGN="TOP"><A NAME="INT2DEC_TAG">INT2DEC_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>&gt;Dec</B></TD></TR>
<TR><TD VALIGN="TOP">2F</TD><TD VALIGN="TOP"><A NAME="INT2HEX_TAG">INT2HEX_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>&gt;Hex</B></TD></TR>
<TR><TD VALIGN="TOP">30</TD><TD VALIGN="TOP"><A NAME="DET_TOL_TAG">DET_TOL_TAG</A></TD><TD VALIGN="TOP"><I>tol</I> <I>mat</I> <B>det</B></TD></TR>
<TR><TD VALIGN="TOP">31</TD><TD VALIGN="TOP"><A NAME="REF_TOL_TAG">REF_TOL_TAG</A></TD><TD VALIGN="TOP"><I>tol</I> <I>mat</I> <B>ref</B></TD></TR>
<TR><TD VALIGN="TOP">32</TD><TD VALIGN="TOP"><A NAME="RREF_TOL_TAG">RREF_TOL_TAG</A></TD><TD VALIGN="TOP"><I>tol</I> <I>mat</I> <B>rref</B></TD></TR>
<TR><TD VALIGN="TOP">33</TD><TD VALIGN="TOP"><A NAME="SIMULT_TOL_TAG">SIMULT_TOL_TAG</A></TD><TD VALIGN="TOP"><I>tol</I> <I>vec</I> <I>mat</I> <B>simult</B></TD></TR>
<TR><TD VALIGN="TOP">34</TD><TD VALIGN="TOP"><A NAME="GETCONFG_TAG">GETCONFG_TAG</A></TD><TD VALIGN="TOP">[] <B>getConfg</B></TD></TR>
<TR><TD VALIGN="TOP">35</TD><TD VALIGN="TOP"><A NAME="V_AUGMENT_TAG">V_AUGMENT_TAG</A></TD><TD VALIGN="TOP"><I>mat2</I> <B>;</B> <I>mat1</I> <B>augment</B></TD></TR>
<TR><TD VALIGN="TOP">36</TD><TD VALIGN="TOP"><A NAME="MEAN_TWOARG_TAG">MEAN_TWOARG_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <I>list</I> <B>mean</B> (AMS 2.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">37</TD><TD VALIGN="TOP"><A NAME="PRODUCT_TWOARG_TAG">PRODUCT_TWOARG_TAG</A></TD><TD VALIGN="TOP">[<I>end</I>] <I>start</I> <I>list</I> <B>product</B> (AMS 2.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">38</TD><TD VALIGN="TOP"><A NAME="STDDEV_TWOARG_TAG">STDDEV_TWOARG_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <I>list</I> <B>stdDev</B> (AMS 2.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">39</TD><TD VALIGN="TOP"><A NAME="SUM_TWOARG_TAG">SUM_TWOARG_TAG</A></TD><TD VALIGN="TOP">[<I>end</I>] <I>start</I> <I>list</I> <B>sum</B> (AMS 2.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">3A</TD><TD VALIGN="TOP"><A NAME="VARIANCE_TWOARG_TAG">VARIANCE_TWOARG_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <I>list</I> <B>variance</B> (AMS 2.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">3B</TD><TD VALIGN="TOP"><A NAME="DELTA_LIST_TAG">DELTA_LIST_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B><FONT FACE="Symbol">D</FONT>list</B> (AMS 2.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">46</TD><TD VALIGN="TOP"><A NAME="ISCLKON_TAG">ISCLKON_TAG</A></TD><TD VALIGN="TOP">[] <B>isClkOn</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">47</TD><TD VALIGN="TOP"><A NAME="GETDATE_TAG">GETDATE_TAG</A></TD><TD VALIGN="TOP">[] <B>getDate</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">48</TD><TD VALIGN="TOP"><A NAME="GETTIME_TAG">GETTIME_TAG</A></TD><TD VALIGN="TOP">[] <B>getTime</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">49</TD><TD VALIGN="TOP"><A NAME="GETTMZN_TAG">GETTMZN_TAG</A></TD><TD VALIGN="TOP">[] <B>getTmZn</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4A</TD><TD VALIGN="TOP"><A NAME="SETDATE_TAG">SETDATE_TAG</A></TD><TD VALIGN="TOP">[] <I>d</I> <I>mo</I> <I>y</I> <B>setDate</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4B</TD><TD VALIGN="TOP"><A NAME="SETTIME_TAG">SETTIME_TAG</A></TD><TD VALIGN="TOP">[] <I>s</I> <I>min</I> <I>h</I> <B>setTime</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4C</TD><TD VALIGN="TOP"><A NAME="SETTMZN_TAG">SETTMZN_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>setTmZn</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4D</TD><TD VALIGN="TOP"><A NAME="DAYOFWK_TAG">DAYOFWK_TAG</A></TD><TD VALIGN="TOP">[] <I>d</I> <I>mo</I> <I>y</I> <B>dayOfWk</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4E</TD><TD VALIGN="TOP"><A NAME="STARTTMR_TAG">STARTTMR_TAG</A></TD><TD VALIGN="TOP">[] <B>startTmr</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4F</TD><TD VALIGN="TOP"><A NAME="CHECKTMR_TAG">CHECKTMR_TAG</A></TD><TD VALIGN="TOP"><I>seconds</I> <B>checkTmr</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">50</TD><TD VALIGN="TOP"><A NAME="TIMECNV_TAG">TIMECNV_TAG</A></TD><TD VALIGN="TOP"><I>seconds</I> <B>timeCnv</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">51</TD><TD VALIGN="TOP"><A NAME="GETDTFMT_TAG">GETDTFMT_TAG</A></TD><TD VALIGN="TOP">[] <B>getDtFmt</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">52</TD><TD VALIGN="TOP"><A NAME="GETTMFMT_TAG">GETTMFMT_TAG</A></TD><TD VALIGN="TOP">[] <B>getTmFmt</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">53</TD><TD VALIGN="TOP"><A NAME="GETDTSTR_TAG">GETDTSTR_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>getDtStr</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">54</TD><TD VALIGN="TOP"><A NAME="GETTMSTR_TAG">GETTMSTR_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>getTmStr</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">55</TD><TD VALIGN="TOP"><A NAME="SETDTFMT_TAG">SETDTFMT_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>setDtFmt</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">56</TD><TD VALIGN="TOP"><A NAME="SETTMFMT_TAG">SETTMFMT_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>setTmFmt</B> (AMS 2.07 or higher)</TD></TR>

<TR><TD VALIGN="TOP">57</TD><TD VALIGN="TOP"><A NAME="ROOT_TAG">ROOT_TAG</A></TD><TD VALIGN="TOP"><I>nthOrder</I> <I>expr</I> <B>root</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">58</TD><TD VALIGN="TOP"><A NAME="EXPRIO_TAG">EXPRIO_TAG</A></TD><TD VALIGN="TOP"><I>string</I> <B>exprIO</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">59</TD><TD VALIGN="TOP"><A NAME="IMPDIF_TAG">IMPDIF_TAG</A></TD><TD VALIGN="TOP">[<I>order</I>] <I>dependentVar</I> <I>independentVar</I> <I>equation</I> <B>impDif</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">5A</TD><TD VALIGN="TOP"><A NAME="STDEVPOP_TAG">STDEVPOP_TAG</A></TD><TD VALIGN="TOP">[<I>arg2</I>] <I>arg1</I> <B>stDevPop</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">5B</TD><TD VALIGN="TOP"><A NAME="ISVAR_TAG">ISVAR_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>isVar</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">5C</TD><TD VALIGN="TOP"><A NAME="ISLOCKED_TAG">ISLOCKED_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>isLocked</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">5D</TD><TD VALIGN="TOP"><A NAME="ISARCHIV_TAG">ISARCHIV_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>isArchiv</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">5E</TD><TD VALIGN="TOP"><A NAME="GRAD_TAG">GRAD_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B><SUP>G</SUP></B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">5F</TD><TD VALIGN="TOP"><A NAME="TO_GRAD_TAG">TO_GRAD_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>&gt;Grad</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">60</TD><TD VALIGN="TOP"><A NAME="TO_RAD_TAG">TO_RAD_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>&gt;Rad</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">61</TD><TD VALIGN="TOP"><A NAME="TO_LN_TAG">TO_LN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>&gt;ln</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">62</TD><TD VALIGN="TOP"><A NAME="TO_LOGBASE_TAG">TO_LOGBASE_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <I>expr</I> <B>&gt;logbase</B> (AMS 3.10 or higher)</TD></TR>

</TABLE>
<BR>
<B>Note:</B> An empty list [] of optional arguments means the function does not take any optional arguments, but an END_TAG is needed nonetheless.
<BR><BR>
<B>Note:</B> For compatibility with TI's compiler, their tag names are also supported.</P>

<HR>
<H3><A NAME="FLOATTABIndexes"><U>FLOATTABIndexes</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> FLOATTABIndexes {
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
FPI_TWOPI=0, FPI_ONEPI, FPI_PIDIV2, FPI_PIDIV4, FPI_360, FPI_180, FPI_90, FPI_45, FPI_180DIVPI, FPI_PIDIV180, FPI_0, FPI_PT001, FPI_PT1, FPI_PIDIV24, FPI_PT5, FPI_PT9, FPI_1, FPI_MINUS1, FPI_SQRRT2, FPI_2, FPI_3, FPI_2PI12, FPI_10, FPI_MINUS10, FPI_12, FPI_14, FPI_20, FPI_70, FPI_BIGGEST, FPI_NEGBIGGEST, FPI_16000, FPI_MINUS16000, FPI_32767, FPI_MINUS32768, FPI_65535, FPI_1E14, FPI_INVALID, FPI_LOGE, FPI_POS0, FPI_NEG0, FPI_POSINF, FPI_NEGINF, FPI_UNSINF</TD></TR></TABLE>
};</TD></TR></TABLE></P>
<P><B>An enumeration for describing the valid indexes for <A HREF="#FLOATTAB">FLOATTAB</A>.</B></P>

<P>See also: <A HREF="#FLOATTAB">FLOATTAB</A></P>
<HR>
<H3><A NAME="InstructionTags"><U>InstructionTags</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> InstructionTags {...};</TD></TR></TABLE></P>
<P><B>An enumeration to describe types of instructions on the expression stack.</B></P>

<P>If the tag of an entry on the expression stack is <A HREF="#EXT_INSTR_TAG">EXT_INSTR_TAG</A> (0xE4), then the
byte below it is the tag of a TI-Basic command token. Although TI-Basic tokens are not interesting
for programming, they are defined in enumerated type InstructionTags, due to completeness. This
enum is quite big, and here is a complete list of TI-Basic instruction token tags defined in it
(all values are in hex), with their meaning (used notation is RPN):
<BR><BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP" WIDTH="30">01</TD><TD VALIGN="TOP"><A NAME="CLRDRAW_ITAG">CLRDRAW_ITAG</A></TD><TD VALIGN="TOP"><B>ClrDraw</B></TD></TR>
<TR><TD VALIGN="TOP">02</TD><TD VALIGN="TOP"><A NAME="CLRGRAPH_ITAG">CLRGRAPH_ITAG</A></TD><TD VALIGN="TOP"><B>ClrGraph</B></TD></TR>
<TR><TD VALIGN="TOP">03</TD><TD VALIGN="TOP"><A NAME="CLRHOME_ITAG">CLRHOME_ITAG</A></TD><TD VALIGN="TOP"><B>ClrHome</B></TD></TR>
<TR><TD VALIGN="TOP">04</TD><TD VALIGN="TOP"><A NAME="CLRIO_ITAG">CLRIO_ITAG</A></TD><TD VALIGN="TOP"><B>ClrIO</B></TD></TR>
<TR><TD VALIGN="TOP">05</TD><TD VALIGN="TOP"><A NAME="CLRTABLE_ITAG">CLRTABLE_ITAG</A></TD><TD VALIGN="TOP"><B>ClrTable</B></TD></TR>
<TR><TD VALIGN="TOP">06</TD><TD VALIGN="TOP"><A NAME="CUSTOM_ITAG">CUSTOM_ITAG</A></TD><TD VALIGN="TOP"><B>Custom</B></TD></TR>
<TR><TD VALIGN="TOP">07</TD><TD VALIGN="TOP"><A NAME="CYCLE_ITAG">CYCLE_ITAG</A></TD><TD VALIGN="TOP"><I>displacement</I> <B>Cycle</B> (displacement towards the instruction ending the loop)</TD></TR>
<TR><TD VALIGN="TOP">08</TD><TD VALIGN="TOP"><A NAME="DIALOG_ITAG">DIALOG_ITAG</A></TD><TD VALIGN="TOP"><B>Dialog</B></TD></TR>
<TR><TD VALIGN="TOP">09</TD><TD VALIGN="TOP"><A NAME="DISPG_ITAG">DISPG_ITAG</A></TD><TD VALIGN="TOP"><B>DispG</B></TD></TR>
<TR><TD VALIGN="TOP">0A</TD><TD VALIGN="TOP"><A NAME="DISPTBL_ITAG">DISPTBL_ITAG</A></TD><TD VALIGN="TOP"><B>DispTbl</B></TD></TR>
<TR><TD VALIGN="TOP">0B</TD><TD VALIGN="TOP"><A NAME="ELSE_ITAG">ELSE_ITAG</A></TD><TD VALIGN="TOP"><B>Else</B> (in If...EndIf statement)</TD></TR>
<TR><TD VALIGN="TOP">0C</TD><TD VALIGN="TOP"><A NAME="ENDCUSTM_ITAG">ENDCUSTM_ITAG</A></TD><TD VALIGN="TOP"><B>EndCustm</B></TD></TR>
<TR><TD VALIGN="TOP">0D</TD><TD VALIGN="TOP"><A NAME="ENDDLOG_ITAG">ENDDLOG_ITAG</A></TD><TD VALIGN="TOP"><B>EndDlog</B></TD></TR>
<TR><TD VALIGN="TOP">0E</TD><TD VALIGN="TOP"><A NAME="ENDFOR_ITAG">ENDFOR_ITAG</A></TD><TD VALIGN="TOP"><I>displacement</I> <B>EndFor</B></TD></TR>
<TR><TD VALIGN="TOP">0F</TD><TD VALIGN="TOP"><A NAME="ENDFUNC_ITAG">ENDFUNC_ITAG</A></TD><TD VALIGN="TOP"><B>EndFunc</B></TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD VALIGN="TOP"><A NAME="ENDIF_ITAG">ENDIF_ITAG</A></TD><TD VALIGN="TOP"><B>EndIf</B></TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD VALIGN="TOP"><A NAME="ENDLOOP_ITAG">ENDLOOP_ITAG</A></TD><TD VALIGN="TOP"><I>displacement</I> <B>EndLoop</B></TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD VALIGN="TOP"><A NAME="ENDPRGM_ITAG">ENDPRGM_ITAG</A></TD><TD VALIGN="TOP"><B>EndPrgm</B></TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD VALIGN="TOP"><A NAME="ENDTBAR_ITAG">ENDTBAR_ITAG</A></TD><TD VALIGN="TOP"><B>EndTBar</B></TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD VALIGN="TOP"><A NAME="ENDTRY_ITAG">ENDTRY_ITAG</A></TD><TD VALIGN="TOP"><B>EndTry</B></TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD VALIGN="TOP"><A NAME="ENDWHILE_ITAG">ENDWHILE_ITAG</A></TD><TD VALIGN="TOP"><I>displacement</I> <B>EndWhile</B></TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD VALIGN="TOP"><A NAME="EXIT_ITAG">EXIT_ITAG</A></TD><TD VALIGN="TOP"><I>displacement</I> <B>Exit</B> (displacement towards the end of the loop, i.e. the instruction following the loop ending instruction)</TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD VALIGN="TOP"><A NAME="FUNC_ITAG">FUNC_ITAG</A></TD><TD VALIGN="TOP"><B>Func</B></TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD VALIGN="TOP"><A NAME="LOOP_ITAG">LOOP_ITAG</A></TD><TD VALIGN="TOP"><B>Loop</B></TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD VALIGN="TOP"><A NAME="PRGM_ITAG">PRGM_ITAG</A></TD><TD VALIGN="TOP"><B>Prgm</B></TD></TR>
<TR><TD VALIGN="TOP">1A</TD><TD VALIGN="TOP"><A NAME="SHOWSTAT_ITAG">SHOWSTAT_ITAG</A></TD><TD VALIGN="TOP"><B>ShowStat</B></TD></TR>
<TR><TD VALIGN="TOP">1B</TD><TD VALIGN="TOP"><A NAME="STOP_ITAG">STOP_ITAG</A></TD><TD VALIGN="TOP"><B>Stop</B></TD></TR>
<TR><TD VALIGN="TOP">1C</TD><TD VALIGN="TOP"><A NAME="THEN_ITAG">THEN_ITAG</A></TD><TD VALIGN="TOP"><B>Then</B></TD></TR>
<TR><TD VALIGN="TOP">1D</TD><TD VALIGN="TOP"><A NAME="TOOLBAR_ITAG">TOOLBAR_ITAG</A></TD><TD VALIGN="TOP"><B>Toolbar</B></TD></TR>
<TR><TD VALIGN="TOP">1E</TD><TD VALIGN="TOP"><A NAME="TRACE_ITAG">TRACE_ITAG</A></TD><TD VALIGN="TOP"><B>Trace</B></TD></TR>
<TR><TD VALIGN="TOP">1F</TD><TD VALIGN="TOP"><A NAME="TRY_ITAG">TRY_ITAG</A></TD><TD VALIGN="TOP"><B>Try</B></TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD VALIGN="TOP"><A NAME="ZOOMBOX_ITAG">ZOOMBOX_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomBox</B></TD></TR>
<TR><TD VALIGN="TOP">21</TD><TD VALIGN="TOP"><A NAME="ZOOMDATA_ITAG">ZOOMDATA_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomData</B></TD></TR>
<TR><TD VALIGN="TOP">22</TD><TD VALIGN="TOP"><A NAME="ZOOMDEC_ITAG">ZOOMDEC_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomDec</B></TD></TR>
<TR><TD VALIGN="TOP">23</TD><TD VALIGN="TOP"><A NAME="ZOOMFIT_ITAG">ZOOMFIT_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomFit</B></TD></TR>
<TR><TD VALIGN="TOP">24</TD><TD VALIGN="TOP"><A NAME="ZOOMIN_ITAG">ZOOMIN_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomIn</B></TD></TR>
<TR><TD VALIGN="TOP">25</TD><TD VALIGN="TOP"><A NAME="ZOOMINT_ITAG">ZOOMINT_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomInt</B></TD></TR>
<TR><TD VALIGN="TOP">26</TD><TD VALIGN="TOP"><A NAME="ZOOMOUT_ITAG">ZOOMOUT_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomOut</B></TD></TR>
<TR><TD VALIGN="TOP">27</TD><TD VALIGN="TOP"><A NAME="ZOOMPREV_ITAG">ZOOMPREV_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomPrev</B></TD></TR>
<TR><TD VALIGN="TOP">28</TD><TD VALIGN="TOP"><A NAME="ZOOMRCL_ITAG">ZOOMRCL_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomRcl</B></TD></TR>
<TR><TD VALIGN="TOP">29</TD><TD VALIGN="TOP"><A NAME="ZOOMSQR_ITAG">ZOOMSQR_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomSqr</B></TD></TR>
<TR><TD VALIGN="TOP">2A</TD><TD VALIGN="TOP"><A NAME="ZOOMSTD_ITAG">ZOOMSTD_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomStd</B></TD></TR>
<TR><TD VALIGN="TOP">2B</TD><TD VALIGN="TOP"><A NAME="ZOOMSTO_ITAG">ZOOMSTO_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomSto</B></TD></TR>
<TR><TD VALIGN="TOP">2C</TD><TD VALIGN="TOP"><A NAME="ZOOMTRIG_ITAG">ZOOMTRIG_ITAG</A></TD><TD VALIGN="TOP"><B>ZoomTrig</B></TD></TR>
<TR><TD VALIGN="TOP">2D</TD><TD VALIGN="TOP"><A NAME="DRAWFUNC_ITAG">DRAWFUNC_ITAG</A>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD VALIGN="TOP"><I>expr</I> <B>DrawFunc</B></TD></TR>
<TR><TD VALIGN="TOP">2E</TD><TD VALIGN="TOP"><A NAME="DRAWINV_ITAG">DRAWINV_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>DrawInv</B></TD></TR>
<TR><TD VALIGN="TOP">2F</TD><TD VALIGN="TOP"><A NAME="GOTO_ITAG">GOTO_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>Goto</B> (<I>Expr</I> = LABEL)</TD></TR>
<TR><TD VALIGN="TOP">30</TD><TD VALIGN="TOP"><A NAME="LBL_ITAG">LBL_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>Lbl</B> (<I>Expr</I> = LABEL)</TD></TR>
<TR><TD VALIGN="TOP">31</TD><TD VALIGN="TOP"><A NAME="GET_ITAG">GET_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>Get</B></TD></TR>
<TR><TD VALIGN="TOP">32</TD><TD VALIGN="TOP"><A NAME="SEND_ITAG">SEND_ITAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>Send</B></TD></TR>
<TR><TD VALIGN="TOP">33</TD><TD VALIGN="TOP"><A NAME="GETCALC_ITAG">GETCALC_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>GetCalc</B></TD></TR>
<TR><TD VALIGN="TOP">34</TD><TD VALIGN="TOP"><A NAME="SENDCALC_ITAG">SENDCALC_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>SendCalc</B></TD></TR>
<TR><TD VALIGN="TOP">35</TD><TD VALIGN="TOP"><A NAME="NEWFOLD_ITAG">NEWFOLD_ITAG</A></TD><TD VALIGN="TOP"><I>foldername</I> <B>NewFold</B></TD></TR>
<TR><TD VALIGN="TOP">36</TD><TD VALIGN="TOP"><A NAME="PRINTOBJ_ITAG">PRINTOBJ_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>PrintObj</B></TD></TR>
<TR><TD VALIGN="TOP">37</TD><TD VALIGN="TOP"><A NAME="RCLGDB_ITAG">RCLGDB_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>RclGDB</B></TD></TR>
<TR><TD VALIGN="TOP">38</TD><TD VALIGN="TOP"><A NAME="STOGDB_ITAG">STOGDB_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>StoGDB</B></TD></TR>
<TR><TD VALIGN="TOP">39</TD><TD VALIGN="TOP"><A NAME="ELSEIF_ITAG">ELSEIF_ITAG</A></TD><TD VALIGN="TOP"><I>condition</I> <B>ElseIf</B></TD></TR>
<TR><TD VALIGN="TOP">3A</TD><TD VALIGN="TOP"><A NAME="IF_ITAG">IF_ITAG</A></TD><TD VALIGN="TOP"><I>condition</I> <B>If</B> (simple variant)</TD></TR>
<TR><TD VALIGN="TOP">3B</TD><TD VALIGN="TOP"><A NAME="IFTHEN_ITAG">IFTHEN_ITAG</A></TD><TD VALIGN="TOP"><I>condition</I> <B>If...Then</B> (If <I>condition</I> Then)</TD></TR>
<TR><TD VALIGN="TOP">3C</TD><TD VALIGN="TOP"><A NAME="RANDSEED_ITAG">RANDSEED_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>RandSeed</B></TD></TR>
<TR><TD VALIGN="TOP">3D</TD><TD VALIGN="TOP"><A NAME="WHILE_ITAG">WHILE_ITAG</A></TD><TD VALIGN="TOP"><I>condition</I> <B>While</B></TD></TR>
<TR><TD VALIGN="TOP">3E</TD><TD VALIGN="TOP"><A NAME="LINETAN_ITAG">LINETAN_ITAG</A></TD><TD VALIGN="TOP"><I>point</I> <I>expr</I> <B>LineTan</B></TD></TR>
<TR><TD VALIGN="TOP">3F</TD><TD VALIGN="TOP"><A NAME="COPYVAR_ITAG">COPYVAR_ITAG</A></TD><TD VALIGN="TOP"><I>var2</I> <I>var1</I> <B>CopyVar</B></TD></TR>
<TR><TD VALIGN="TOP">40</TD><TD VALIGN="TOP"><A NAME="RENAME_ITAG">RENAME_ITAG</A></TD><TD VALIGN="TOP"><I>newname</I> <I>oldname</I> <B>Rename</B></TD></TR>
<TR><TD VALIGN="TOP">41</TD><TD VALIGN="TOP"><A NAME="STYLE_ITAG">STYLE_ITAG</A></TD><TD VALIGN="TOP"><I>string</I> <I>expr</I> <B>Style</B></TD></TR>
<TR><TD VALIGN="TOP">42</TD><TD VALIGN="TOP"><A NAME="FILL_ITAG">FILL_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>expr</I> <B>Fill</B></TD></TR>
<TR><TD VALIGN="TOP">43</TD><TD VALIGN="TOP"><A NAME="REQUEST_ITAG">REQUEST_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>string</I> <B>Request</B></TD></TR>
<TR><TD VALIGN="TOP">44</TD><TD VALIGN="TOP"><A NAME="POPUP_ITAG">POPUP_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>itemlist</I> <B>PopUp</B></TD></TR>
<TR><TD VALIGN="TOP">45</TD><TD VALIGN="TOP"><A NAME="PTCHG_ITAG">PTCHG_ITAG</A></TD><TD VALIGN="TOP"><I>y</I> <I>x</I> <B>PtChg</B></TD></TR>
<TR><TD VALIGN="TOP">46</TD><TD VALIGN="TOP"><A NAME="PTOFF_ITAG">PTOFF_ITAG</A></TD><TD VALIGN="TOP"><I>y</I> <I>x</I> <B>PtOff</B></TD></TR>
<TR><TD VALIGN="TOP">47</TD><TD VALIGN="TOP"><A NAME="PTON_ITAG">PTON_ITAG</A></TD><TD VALIGN="TOP"><I>y</I> <I>x</I> <B>PtOn</B></TD></TR>
<TR><TD VALIGN="TOP">48</TD><TD VALIGN="TOP"><A NAME="PXLCHG_ITAG">PXLCHG_ITAG</A></TD><TD VALIGN="TOP"><I>column</I> <I>row</I> <B>PxlChg</B></TD></TR>
<TR><TD VALIGN="TOP">49</TD><TD VALIGN="TOP"><A NAME="PXLOFF_ITAG">PXLOFF_ITAG</A></TD><TD VALIGN="TOP"><I>column</I> <I>row</I> <B>PxlOff</B></TD></TR>
<TR><TD VALIGN="TOP">4A</TD><TD VALIGN="TOP"><A NAME="PXLON_ITAG">PXLON_ITAG</A></TD><TD VALIGN="TOP"><I>column</I> <I>row</I> <B>PxlOn</B></TD></TR>
<TR><TD VALIGN="TOP">4B</TD><TD VALIGN="TOP"><A NAME="MOVEVAR_ITAG">MOVEVAR_ITAG</A></TD><TD VALIGN="TOP"><I>newfolder</I> <I>oldfolder</I> <I>var</I> <B>MoveVar</B></TD></TR>
<TR><TD VALIGN="TOP">4C</TD><TD VALIGN="TOP"><A NAME="DROPDOWN_ITAG">DROPDOWN_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>list</I> <I>title_string</I> <B>DropDown</B></TD></TR>
<TR><TD VALIGN="TOP">4D</TD><TD VALIGN="TOP"><A NAME="OUTPUT_ITAG">OUTPUT_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <I>column</I> <I>row</I> <B>Output</B></TD></TR>
<TR><TD VALIGN="TOP">4E</TD><TD VALIGN="TOP"><A NAME="PTTEXT_ITAG">PTTEXT_ITAG</A></TD><TD VALIGN="TOP"><I>y</I> <I>x</I> <I>string</I> <B>PtText</B></TD></TR>
<TR><TD VALIGN="TOP">4F</TD><TD VALIGN="TOP"><A NAME="PXLTEXT_ITAG">PXLTEXT_ITAG</A></TD><TD VALIGN="TOP"><I>column</I> <I>row</I> <I>string</I> <B>PxlText</B></TD></TR>
<TR><TD VALIGN="TOP">50</TD><TD VALIGN="TOP"><A NAME="DRAWSLP_ITAG">DRAWSLP_ITAG</A></TD><TD VALIGN="TOP"><I>slope</I> <I>y</I> <I>x</I> <B>DrawSlp</B></TD></TR>
<TR><TD VALIGN="TOP">51</TD><TD VALIGN="TOP"><A NAME="PAUSE_ITAG">PAUSE_ITAG</A></TD><TD VALIGN="TOP">[<I>expr</I>] <B>Pause</B></TD></TR>
<TR><TD VALIGN="TOP">52</TD><TD VALIGN="TOP"><A NAME="RETURN_ITAG">RETURN_ITAG</A></TD><TD VALIGN="TOP">[<I>expr</I>] <B>Return</B></TD></TR>
<TR><TD VALIGN="TOP">53</TD><TD VALIGN="TOP"><A NAME="INPUT_ITAG">INPUT_ITAG</A></TD><TD VALIGN="TOP">[<I>var</I> [<I>string</I>]] <B>Input</B></TD></TR>
<TR><TD VALIGN="TOP">54</TD><TD VALIGN="TOP"><A NAME="PLOTSOFF_ITAG">PLOTSOFF_ITAG</A></TD><TD VALIGN="TOP">[<I>9</I>] <B>...</B> [<I>2</I>] [<I>1</I>] <B>PlotsOff</B></TD></TR>
<TR><TD VALIGN="TOP">55</TD><TD VALIGN="TOP"><A NAME="PLOTSON_ITAG">PLOTSON_ITAG</A></TD><TD VALIGN="TOP">[<I>9</I>] <B>...</B> [<I>2</I>] [<I>1</I>] <B>PlotsOn</B></TD></TR>
<TR><TD VALIGN="TOP">56</TD><TD VALIGN="TOP"><A NAME="TITLE_ITAG">TITLE_ITAG</A></TD><TD VALIGN="TOP">[<I>label</I>] <I>string</I> <B>Title</B></TD></TR>
<TR><TD VALIGN="TOP">57</TD><TD VALIGN="TOP"><A NAME="ITEM_ITAG">ITEM_ITAG</A></TD><TD VALIGN="TOP">[<I>label</I>] <I>string</I> <B>Item</B></TD></TR>
<TR><TD VALIGN="TOP">58</TD><TD VALIGN="TOP"><A NAME="INPUTSTR_ITAG">INPUTSTR_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> [<I>string</I>] <B>InputStr</B></TD></TR>
<TR><TD VALIGN="TOP">59</TD><TD VALIGN="TOP"><A NAME="LINEHORZ_ITAG">LINEHORZ_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>y</I> <B>LineHorz</B></TD></TR>
<TR><TD VALIGN="TOP">5A</TD><TD VALIGN="TOP"><A NAME="LINEVERT_ITAG">LINEVERT_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>x</I> <B>LineVert</B></TD></TR>
<TR><TD VALIGN="TOP">5B</TD><TD VALIGN="TOP"><A NAME="PXLHORZ_ITAG">PXLHORZ_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>row</I> <B>PxlHorz</B></TD></TR>
<TR><TD VALIGN="TOP">5C</TD><TD VALIGN="TOP"><A NAME="PXLVERT_ITAG">PXLVERT_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>column</I> <B>PxlVert</B></TD></TR>
<TR><TD VALIGN="TOP">5D</TD><TD VALIGN="TOP"><A NAME="ANDPIC_ITAG">ANDPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>pxlcol</I> <I>pxlrow</I>] <I>picvar</I> <B>AndPic</B></TD></TR>
<TR><TD VALIGN="TOP">5E</TD><TD VALIGN="TOP"><A NAME="RCLPIC_ITAG">RCLPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>pxlcol</I> <I>pxlrow</I>] <I>picvar</I> <B>RclPic</B></TD></TR>
<TR><TD VALIGN="TOP">5F</TD><TD VALIGN="TOP"><A NAME="RPLCPIC_ITAG">RPLCPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>pxlcol</I> <I>pxlrow</I>] <I>picvar</I> <B>RplcPic</B></TD></TR>
<TR><TD VALIGN="TOP">60</TD><TD VALIGN="TOP"><A NAME="XORPIC_ITAG">XORPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>pxlcol</I> <I>pxlrow</I>] <I>picvar</I> <B>XorPic</B></TD></TR>
<TR><TD VALIGN="TOP">61</TD><TD VALIGN="TOP"><A NAME="DRAWPOL_ITAG">DRAWPOL_ITAG</A></TD><TD VALIGN="TOP">[<FONT FACE="Symbol">q</FONT><I>step</I>] [<FONT FACE="Symbol">q</FONT><I>max</I>] [<FONT FACE="Symbol">q</FONT><I>min</I>] <B>DrawPol</B></TD></TR>
<TR><TD VALIGN="TOP">62</TD><TD VALIGN="TOP"><A NAME="TEXT_ITAG">TEXT_ITAG</A></TD><TD VALIGN="TOP">[] <I>string</I> <B>Text</B></TD></TR>
<TR><TD VALIGN="TOP">63</TD><TD VALIGN="TOP"><A NAME="ONEVAR_ITAG">ONEVAR_ITAG</A></TD><TD VALIGN="TOP">[<I>L4</I>] [<I>L3</I>] [<I>L2</I>] [<I>L1</I>] <B>OneVar</B></TD></TR>
<TR><TD VALIGN="TOP">64</TD><TD VALIGN="TOP"><A NAME="STOPIC_ITAG">STOPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>height</I> <I>width</I>] [<I>pxlcol</I> <I>pxlrow</I>] <I>var</I> <B>StoPic</B></TD></TR>
<TR><TD VALIGN="TOP">65</TD><TD VALIGN="TOP"><A NAME="GRAPH_ITAG">GRAPH_ITAG</A></TD><TD VALIGN="TOP">[<I>var2</I>] [<I>var1</I>] [<I>expr2</I>] <I>expr1</I> <B>Graph</B></TD></TR>
<TR><TD VALIGN="TOP">66</TD><TD VALIGN="TOP"><A NAME="TABLE_ITAG">TABLE_ITAG</A></TD><TD VALIGN="TOP">[<I>var</I>] [<I>expr2</I>] <I>expr1</I> <B>Table</B></TD></TR>
<TR><TD VALIGN="TOP">67</TD><TD VALIGN="TOP"><A NAME="NEWPIC_ITAG">NEWPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>maxcol</I>] [<I>maxrow</I>] <I>picvar</I> <I>mat</I> <B>NewPic</B></TD></TR>
<TR><TD VALIGN="TOP">68</TD><TD VALIGN="TOP"><A NAME="DRAWPARM_ITAG">DRAWPARM_ITAG</A></TD><TD VALIGN="TOP">[<I>tstep</I>] [<I>tmax</I>] [<I>tmin</I>] <I>expr2</I> <I>expr1</I> <B>DrawParm</B></TD></TR>
<TR><TD VALIGN="TOP">69</TD><TD VALIGN="TOP"><A NAME="CYCLEPIC_ITAG">CYCLEPIC_ITAG</A></TD><TD VALIGN="TOP">[<I>direction</I>] [<I>cycle</I>] [<I>wait</I>] <I>N</I> <I>picname_string</I> <B>CyclePic</B></TD></TR>
<TR><TD VALIGN="TOP">6A</TD><TD VALIGN="TOP"><A NAME="CUBICREG_ITAG">CUBICREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>CubicReg</B></TD></TR>
<TR><TD VALIGN="TOP">6B</TD><TD VALIGN="TOP"><A NAME="EXPREG_ITAG">EXPREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>ExpReg</B></TD></TR>
<TR><TD VALIGN="TOP">6C</TD><TD VALIGN="TOP"><A NAME="LINREG_ITAG">LINREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>LinReg</B></TD></TR>
<TR><TD VALIGN="TOP">6D</TD><TD VALIGN="TOP"><A NAME="LNREG_ITAG">LNREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>LnReg</B></TD></TR>
<TR><TD VALIGN="TOP">6E</TD><TD VALIGN="TOP"><A NAME="MEDMED_ITAG">MEDMED_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>MedMed</B></TD></TR>
<TR><TD VALIGN="TOP">6F</TD><TD VALIGN="TOP"><A NAME="POWERREG_ITAG">POWERREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>PowerReg</B></TD></TR>
<TR><TD VALIGN="TOP">70</TD><TD VALIGN="TOP"><A NAME="QUADREG_ITAG">QUADREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>QuadReg</B></TD></TR>
<TR><TD VALIGN="TOP">71</TD><TD VALIGN="TOP"><A NAME="QUARTREG_ITAG">QUARTREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>QuartReg</B></TD></TR>
<TR><TD VALIGN="TOP">72</TD><TD VALIGN="TOP"><A NAME="TWOVAR_ITAG">TWOVAR_ITAG</A></TD><TD VALIGN="TOP">[[<I>L5</I> <I>L4</I>] [<I>L3</I>]] <I>L2</I> <I>L1</I> <B>TwoVar</B></TD></TR>
<TR><TD VALIGN="TOP">73</TD><TD VALIGN="TOP"><A NAME="SHADE_ITAG">SHADE_ITAG</A></TD><TD VALIGN="TOP">[<I>patres</I>] [<I>pat</I>] [<I>xhigh</I>] [<I>xlow</I>] <I>expr2</I> <I>expr1</I> <B>Shade</B></TD></TR>
<TR><TD VALIGN="TOP">74</TD><TD VALIGN="TOP"><A NAME="FOR_ITAG">FOR_ITAG</A></TD><TD VALIGN="TOP">[<I>step</I>] <I>high</I> <I>low</I> <I>var</I> <B>For</B></TD></TR>
<TR><TD VALIGN="TOP">75</TD><TD VALIGN="TOP"><A NAME="CIRCLE_ITAG">CIRCLE_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>r</I> <I>y</I> <I>x</I> <B>Circle</B></TD></TR>
<TR><TD VALIGN="TOP">76</TD><TD VALIGN="TOP"><A NAME="PXLCRCL_ITAG">PXLCRCL_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>r</I> <I>col</I> <I>row</I> <B>PxlCrcl</B></TD></TR>
<TR><TD VALIGN="TOP">77</TD><TD VALIGN="TOP"><A NAME="NEWPLOT_ITAG">NEWPLOT_ITAG</A></TD><TD VALIGN="TOP">[<I>bucket</I>] [<I>mark</I>] [<I>inc</I>] [<I>cat</I>] [<I>frq</I>] [<I>ylist</I>] <I>xlist</I> <I>type</I> <I>N</I> <B>NewPlot</B></TD></TR>
<TR><TD VALIGN="TOP">78</TD><TD VALIGN="TOP"><A NAME="LINE_ITAG">LINE_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>yend</I> <I>xend</I> <I>ystart</I> <I>xstart</I> <B>Line</B></TD></TR>
<TR><TD VALIGN="TOP">79</TD><TD VALIGN="TOP"><A NAME="PXLLINE_ITAG">PXLLINE_ITAG</A></TD><TD VALIGN="TOP">[<I>drawmode</I>] <I>colend</I> <I>rowend</I> <I>colstart</I> <I>rowstart</I> <B>PxlLine</B></TD></TR>
<TR><TD VALIGN="TOP">7A</TD><TD VALIGN="TOP"><A NAME="DISP_ITAG">DISP_ITAG</A></TD><TD VALIGN="TOP">[[<B>...</B>] <I>expr1</I>] <B>Disp</B></TD></TR>
<TR><TD VALIGN="TOP">7B</TD><TD VALIGN="TOP"><A NAME="FNOFF_ITAG">FNOFF_ITAG</A></TD><TD VALIGN="TOP">[<I>99</I>] <B>...</B> [<I>2</I>] [<I>1</I>] <B>FnOff</B></TD></TR>
<TR><TD VALIGN="TOP">7C</TD><TD VALIGN="TOP"><A NAME="FNON_ITAG">FNON_ITAG</A></TD><TD VALIGN="TOP">[<I>99</I>] <B>...</B> [<I>2</I>] [<I>1</I>] <B>FnOn</B></TD></TR>
<TR><TD VALIGN="TOP">7D</TD><TD VALIGN="TOP"><A NAME="LOCAL_ITAG">LOCAL_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>Local</B></TD></TR>
<TR><TD VALIGN="TOP">7E</TD><TD VALIGN="TOP"><A NAME="DELFOLD_ITAG">DELFOLD_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>DelFold</B></TD></TR>
<TR><TD VALIGN="TOP">7F</TD><TD VALIGN="TOP"><A NAME="DELVAR_ITAG">DELVAR_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>DelVar</B></TD></TR>
<TR><TD VALIGN="TOP">80</TD><TD VALIGN="TOP"><A NAME="LOCK_ITAG">LOCK_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>Lock</B></TD></TR>
<TR><TD VALIGN="TOP">81</TD><TD VALIGN="TOP"><A NAME="PROMPT_ITAG">PROMPT_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>Prompt</B></TD></TR>
<TR><TD VALIGN="TOP">82</TD><TD VALIGN="TOP"><A NAME="SORTA_ITAG">SORTA_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>list1</I> <B>SortA</B></TD></TR>
<TR><TD VALIGN="TOP">83</TD><TD VALIGN="TOP"><A NAME="SORTD_ITAG">SORTD_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>list1</I> <B>SortD</B></TD></TR>
<TR><TD VALIGN="TOP">84</TD><TD VALIGN="TOP"><A NAME="UNLOCK_ITAG">UNLOCK_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>UnLock</B></TD></TR>
<TR><TD VALIGN="TOP">85</TD><TD VALIGN="TOP"><A NAME="NEWDATA_ITAG">NEWDATA_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>list1</I> <I>datavar</I> <B>NewData</B></TD></TR>
<TR><TD VALIGN="TOP">86</TD><TD VALIGN="TOP"><A NAME="DEFINE_ITAG">DEFINE_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <I>var|userfunc</I> <B>Define</B></TD></TR>
<TR><TD VALIGN="TOP">87</TD><TD VALIGN="TOP"><A NAME="ELSE_TRY_ITAG">ELSE_TRY_ITAG</A></TD><TD VALIGN="TOP"><B>Else</B> (in Try...EndTry statement)</TD></TR>
<TR><TD VALIGN="TOP">88</TD><TD VALIGN="TOP"><A NAME="CLRERR_ITAG">CLRERR_ITAG</A></TD><TD VALIGN="TOP"><B>ClrErr</B></TD></TR>
<TR><TD VALIGN="TOP">89</TD><TD VALIGN="TOP"><A NAME="PASSERR_ITAG">PASSERR_ITAG</A></TD><TD VALIGN="TOP"><B>PassErr</B></TD></TR>
<TR><TD VALIGN="TOP">8A</TD><TD VALIGN="TOP"><A NAME="DISPHOME_ITAG">DISPHOME_ITAG</A></TD><TD VALIGN="TOP"><B>DispHome</B></TD></TR>
<TR><TD VALIGN="TOP">8B</TD><TD VALIGN="TOP"><A NAME="EXEC_ITAG">EXEC_ITAG</A></TD><TD VALIGN="TOP">[[<B>...</B>] <I>expr</I>] <I>string</I> <B>Exec</B></TD></TR>
<TR><TD VALIGN="TOP">8C</TD><TD VALIGN="TOP"><A NAME="ARCHIVE_ITAG">ARCHIVE_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>Archive</B></TD></TR>
<TR><TD VALIGN="TOP">8D</TD><TD VALIGN="TOP"><A NAME="UNARCHIV_ITAG">UNARCHIV_ITAG</A></TD><TD VALIGN="TOP">[<B>...</B>] <I>var1</I> <B>Unarchiv</B></TD></TR>
<TR><TD VALIGN="TOP">8E</TD><TD VALIGN="TOP"><A NAME="LU_ITAG">LU_ITAG</A></TD><TD VALIGN="TOP">[<I>tol</I>] <I>pvar</I> <I>uvar</I> <I>lvar</I> <I>mat</I> <B>LU</B></TD></TR>
<TR><TD VALIGN="TOP">8F</TD><TD VALIGN="TOP"><A NAME="QR_ITAG">QR_ITAG</A></TD><TD VALIGN="TOP">[<I>tol</I>] <I>rvar</I> <I>qvar</I> <I>mat</I> <B>QR</B></TD></TR>
<TR><TD VALIGN="TOP">90</TD><TD VALIGN="TOP"><A NAME="BLDDATA_ITAG">BLDDATA_ITAG</A></TD><TD VALIGN="TOP"><I>var</I>|<I>sysdata</I> <B>BldData</B></TD></TR>
<TR><TD VALIGN="TOP">91</TD><TD VALIGN="TOP"><A NAME="DRWCTOUR_ITAG">DRWCTOUR_ITAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>DrwCtour</B></TD></TR>
<TR><TD VALIGN="TOP">92</TD><TD VALIGN="TOP"><A NAME="NEWPROB_ITAG">NEWPROB_ITAG</A></TD><TD VALIGN="TOP"><B>NewProb</B></TD></TR>
<TR><TD VALIGN="TOP">93</TD><TD VALIGN="TOP"><A NAME="SINREG_ITAG">SINREG_ITAG</A></TD><TD VALIGN="TOP">[[<I>L4</I> <I>L3</I>] [<I>period</I>] [<I>iter</I>]] <I>L2</I> <I>L1</I> <B>SinReg</B></TD></TR>
<TR><TD VALIGN="TOP">94</TD><TD VALIGN="TOP"><A NAME="LOGISTIC_ITAG">LOGISTIC_ITAG</A></TD><TD VALIGN="TOP">[[<I>L4</I> <I>L3</I>] [<I>period</I>] [<I>iter</I>]] <I>L2</I> <I>L1</I> <B>Logistic</B></TD></TR>
<TR><TD VALIGN="TOP">95</TD><TD VALIGN="TOP"><A NAME="CUSTMON_ITAG">CUSTMON_ITAG</A></TD><TD VALIGN="TOP"><B>CustmOn</B></TD></TR>
<TR><TD VALIGN="TOP">96</TD><TD VALIGN="TOP"><A NAME="CUSTMOFF_ITAG">CUSTMOFF_ITAG</A></TD><TD VALIGN="TOP"><B>CustmOff</B></TD></TR>
<TR><TD VALIGN="TOP">97</TD><TD VALIGN="TOP"><A NAME="SENDCHAT_ITAG">SENDCHAT_ITAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>SendChat</B></TD></TR>
<TR><TD VALIGN="TOP">99</TD><TD VALIGN="TOP"><A NAME="REQUEST_THREEARG_ITAG">REQUEST_THREEARG_ITAG</A></TD><TD VALIGN="TOP">[] <I>alphalock</I> <I>var</I> <I>string</I> <B>Request</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">9A</TD><TD VALIGN="TOP"><A NAME="CLOCKON_ITAG">CLOCKON_ITAG</A></TD><TD VALIGN="TOP"><B>ClockOn</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">9B</TD><TD VALIGN="TOP"><A NAME="CLOCKOFF_ITAG">CLOCKOFF_ITAG</A></TD><TD VALIGN="TOP"><B>ClockOff</B> (AMS 2.07 or higher)</TD></TR>
<TR><TD VALIGN="TOP">9C</TD><TD VALIGN="TOP"><A NAME="SENDCALC_TWOARG_ITAG">SENDCALC_TWOARG_ITAG</A></TD><TD VALIGN="TOP"><I>port</I> <I>var</I> <B>SendCalc</B> (AMS 3.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">9D</TD><TD VALIGN="TOP"><A NAME="GETCALC_TWOARG_ITAG">GETCALC_TWOARG_ITAG</A></TD><TD VALIGN="TOP"><I>port</I> <I>var</I> <B>GetCalc</B> (AMS 3.00 or higher)</TD></TR>
<TR><TD VALIGN="TOP">9E</TD><TD VALIGN="TOP"><A NAME="DELTYPE_ITAG">DELTYPE_ITAG</A></TD><TD VALIGN="TOP"><I>varTypeStr</I> <B>DelType</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">9F</TD><TD VALIGN="TOP"><A NAME="DATA2MAT_ITAG">DATA2MAT_ITAG</A></TD><TD VALIGN="TOP">[<I>col2</I>] [<I>row2</I>] [<I>col1</I>] [<I>row1</I>] <I>matVar</I> <I>dataVar</I> <B>Data&gt;Mat</B> (AMS 3.10 or higher)</TD></TR>
<TR><TD VALIGN="TOP">A0</TD><TD VALIGN="TOP"><A NAME="MAT2DATA_ITAG">MAT2DATA_ITAG</A></TD><TD VALIGN="TOP">[<I>col2</I>] [<I>row2</I>] [<I>col1</I>] [<I>row1</I>] <I>dataVar</I> <I>matVar</I> <B>Mat&gt;Data</B> (AMS 3.10 or higher)</TD></TR>

</TABLE>
<BR>
<B>Note:</B> Displacements for jumps are 2 byte quantities in little endian format. Displacements in front of loop ending instructions are towards the beginning of the loop.<BR>
<BR>
<B>Note:</B> An empty list [] of optional arguments means the instruction does not take any optional arguments, but an END_TAG is needed nonetheless.
<BR><BR>
<B>Note:</B> For compatibility with TI's compiler, their tag names are also supported.</P>

<HR>
<H3><A NAME="MULTI_EXPR"><U>MULTI_EXPR</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#struct">struct</A></B> {
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> Size;<BR>
<A HREF="#ESQ">ESQ</A> Expr[];<BR>
</TD></TR></TABLE>
} MULTI_EXPR;</TD></TR></TABLE></P>
<P><B>Describes a multi-expression, which is processed as a separate expression stack.</B></P>

<P>MULTI_EXPR is a structure describing a multi-expression. It can be applied to the
contents of every VAT symbol, because all symbols contain size bytes at the
beginning. It can also be used to describe a multi-expression passed to
<A HREF="#Parse2DMultiExpr">Parse2DMultiExpr</A>, or used by the FIFO
elements in <A HREF="homescr.html">homescr.h</A>.
<BR><BR>
The <I>Size</I> field contains the size of the data in <I>Expr</I>, in bytes
(but note that <A HREF="#ESQ">ESQ</A> is one byte large). For real
multi-expressions, <I>Expr</I> should start with
<A HREF="#ENDSTACK_TAG">ENDSTACK_TAG</A>, followed by the actual expressions.
These expressions are processed from the end to the beginning, as usual
(using the <I>Size</I> field to find the end). So the last quantum needs to
be a tag from the <A HREF="#Tags">Tags</A> enum.
<BR><BR>
Multiple expressions are separated with
<A HREF="#NEXTEXPR_TAG">NEXTEXPR_TAG</A>, or with
<A HREF="#NEWLINE_TAG">NEWLINE_TAG</A> (only in TI-Basic programs and
functions).
<BR><BR>
If you have a handle to a MULTI_EXPR structure, you can use the
<A HREF="#HToESI">HToESI</A> function to get a pointer to the last
quantum (i.e. the tag).</P>

<P>See also: <A HREF="#top_estack">top_estack</A>, <A HREF="#HToESI">HToESI</A>, <A HREF="#Parse2DMultiExpr">Parse2DMultiExpr</A>, <A HREF="homescr.html">homescr.h</A></P>
<HR>
<H3><A NAME="Quantum"><U>Quantum</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> Quantum <A HREF="#ESQ">ESQ</A></TD></TR></TABLE></P>
<P><B>Represents a quantum within an expression.</B></P>

<P>Quantum is a synonym for <A HREF="#ESQ">ESQ</A>.</P>

<HR>
<H3><A NAME="SYM_STR"><U>SYM_STR</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <A HREF="#CESI">CESI</A> SYM_STR;</TD></TR></TABLE></P>
<P><B>Represents a pointer to the terminating zero byte of a string.</B></P>

<P>The type SYM_STR is in fact the same as <A HREF="#CESI">CESI</A>.
It represents a string created with the <A HREF="vat.html#SYMSTR">SYMSTR</A> macro.
This type of string is usually used in expressions on the expression stack,
or in functions from <A HREF="vat.html">vat.h</A> or <A HREF="bascmd.html">bascmd.h</A>.</P>

<HR>
<H3><A NAME="sysvar_info"><U>sysvar_info</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#struct">struct</A></B> {
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_type_1;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_type_2;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_type_3;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_type_4;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> tag_str; <I>/* Pointer to string data on AMS 1.xx, string ID suitable for XR_stringPtr on later AMS versions */</I><BR>
</TD></TR></TABLE>
} sysvar_info;</TD></TR></TABLE></P>
<P><B>Structure containing information about AMS EStack tags (<A HREF="#SysvarTags">SysvarTags</A>).</B></P>

<HR>
<H3><A NAME="SysvarTags"><U>SysvarTags</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> SysvarTags {...};</TD></TR></TABLE></P>
<P><B>An enumeration to describe types of system variable entries on the expression stack.</B></P>

<P>If the tag of an entry on the expression stack is <A HREF="#EXT_SYSTEM_TAG">EXT_SYSTEM_TAG</A> (0x1C), then the
byte below it is the tag of a TI-Basic system variable. SysvarTags is enumerated type for describing
such extended entries (see <A HREF="#top_estack">top_estack</A> for more info about how entries
on the expression stack are organized). This enum is quite big, and here is a complete list of
system variables tags defined in it (all values are in hex), with their meaning:
<BR><BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP" WIDTH="30">01</TD><TD VALIGN="TOP"><A NAME="X_BAR_TAG">X_BAR_TAG</A></TD><TD VALIGN="TOP"><B>x</B> mean</TD></TR>
<TR><TD VALIGN="TOP">02</TD><TD VALIGN="TOP"><A NAME="Y_BAR_TAG">Y_BAR_TAG</A></TD><TD VALIGN="TOP"><B>y</B> mean</TD></TR>
<TR><TD VALIGN="TOP">03</TD><TD VALIGN="TOP"><A NAME="SIGMA_X_TAG">SIGMA_X_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">S</FONT>x</B></TD></TR>
<TR><TD VALIGN="TOP">04</TD><TD VALIGN="TOP"><A NAME="SIGMA_X2_TAG">SIGMA_X2_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">S</FONT>x<SUP>2</SUP></B></TD></TR>
<TR><TD VALIGN="TOP">05</TD><TD VALIGN="TOP"><A NAME="SIGMA_Y_TAG">SIGMA_Y_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">S</FONT>y</B></TD></TR>
<TR><TD VALIGN="TOP">06</TD><TD VALIGN="TOP"><A NAME="SIGMA_Y2_TAG">SIGMA_Y2_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">S</FONT>y<SUP>2</SUP></B></TD></TR>
<TR><TD VALIGN="TOP">07</TD><TD VALIGN="TOP"><A NAME="SIGMA_XY_TAG">SIGMA_XY_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">S</FONT>xy</B></TD></TR>
<TR><TD VALIGN="TOP">08</TD><TD VALIGN="TOP"><A NAME="SX_TAG">SX_TAG</A></TD><TD VALIGN="TOP"><B>Sx</B></TD></TR>
<TR><TD VALIGN="TOP">09</TD><TD VALIGN="TOP"><A NAME="SY_TAG">SY_TAG</A></TD><TD VALIGN="TOP"><B>Sy</B></TD></TR>
<TR><TD VALIGN="TOP">0A</TD><TD VALIGN="TOP"><A NAME="SMLSIGMA_X_TAG">SMLSIGMA_X_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">s</FONT>x</B></TD></TR>
<TR><TD VALIGN="TOP">0B</TD><TD VALIGN="TOP"><A NAME="SMLSIGMA_Y_TAG">SMLSIGMA_Y_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">s</FONT>y</B></TD></TR>
<TR><TD VALIGN="TOP">0C</TD><TD VALIGN="TOP"><A NAME="NSTAT_TAG">NSTAT_TAG</A></TD><TD VALIGN="TOP"><B>nStat</B></TD></TR>
<TR><TD VALIGN="TOP">0D</TD><TD VALIGN="TOP"><A NAME="MINX_TAG">MINX_TAG</A></TD><TD VALIGN="TOP"><B>minX</B></TD></TR>
<TR><TD VALIGN="TOP">0E</TD><TD VALIGN="TOP"><A NAME="MINY_TAG">MINY_TAG</A></TD><TD VALIGN="TOP"><B>minY</B></TD></TR>
<TR><TD VALIGN="TOP">0F</TD><TD VALIGN="TOP"><A NAME="Q1_TAG">Q1_TAG</A></TD><TD VALIGN="TOP"><B>q1</B></TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD VALIGN="TOP"><A NAME="MEDSTAT_TAG">MEDSTAT_TAG</A></TD><TD VALIGN="TOP"><B>medStat</B></TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD VALIGN="TOP"><A NAME="Q3_TAG">Q3_TAG</A></TD><TD VALIGN="TOP"><B>q3</B></TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD VALIGN="TOP"><A NAME="MAXX_TAG">MAXX_TAG</A></TD><TD VALIGN="TOP"><B>maxX</B></TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD VALIGN="TOP"><A NAME="MAXY_TAG">MAXY_TAG</A></TD><TD VALIGN="TOP"><B>maxY</B></TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD VALIGN="TOP"><A NAME="CORR_TAG">CORR_TAG</A></TD><TD VALIGN="TOP"><B>corr</B></TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD VALIGN="TOP"><A NAME="R2_TAG">R2_TAG</A></TD><TD VALIGN="TOP"><B>R<SUP>2</SUP></B></TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD VALIGN="TOP"><A NAME="MEDX1_TAG">MEDX1_TAG</A></TD><TD VALIGN="TOP"><B>medx1</B></TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD VALIGN="TOP"><A NAME="MEDX2_TAG">MEDX2_TAG</A></TD><TD VALIGN="TOP"><B>medx2</B></TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD VALIGN="TOP"><A NAME="MEDX3_TAG">MEDX3_TAG</A></TD><TD VALIGN="TOP"><B>medx3</B></TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD VALIGN="TOP"><A NAME="MEDY1_TAG">MEDY1_TAG</A></TD><TD VALIGN="TOP"><B>medy1</B></TD></TR>
<TR><TD VALIGN="TOP">1A</TD><TD VALIGN="TOP"><A NAME="MEDY2_TAG">MEDY2_TAG</A></TD><TD VALIGN="TOP"><B>medy2</B></TD></TR>
<TR><TD VALIGN="TOP">1B</TD><TD VALIGN="TOP"><A NAME="MEDY3_TAG">MEDY3_TAG</A></TD><TD VALIGN="TOP"><B>medy3</B></TD></TR>
<TR><TD VALIGN="TOP">1C</TD><TD VALIGN="TOP"><A NAME="XC_TAG">XC_TAG</A></TD><TD VALIGN="TOP"><B>xc</B></TD></TR>
<TR><TD VALIGN="TOP">1D</TD><TD VALIGN="TOP"><A NAME="YC_TAG">YC_TAG</A></TD><TD VALIGN="TOP"><B>yc</B></TD></TR>
<TR><TD VALIGN="TOP">1E</TD><TD VALIGN="TOP"><A NAME="ZC_TAG">ZC_TAG</A></TD><TD VALIGN="TOP"><B>zc</B></TD></TR>
<TR><TD VALIGN="TOP">1F</TD><TD VALIGN="TOP"><A NAME="TC_TAG">TC_TAG</A></TD><TD VALIGN="TOP"><B>tc</B></TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD VALIGN="TOP"><A NAME="RC_TAG">RC_TAG</A></TD><TD VALIGN="TOP"><B>rc</B></TD></TR>
<TR><TD VALIGN="TOP">21</TD><TD VALIGN="TOP"><A NAME="THETA_C_TAG">THETA_C_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">q</FONT>c</B></TD></TR>
<TR><TD VALIGN="TOP">22</TD><TD VALIGN="TOP"><A NAME="NC_TAG">NC_TAG</A></TD><TD VALIGN="TOP"><B>nc</B></TD></TR>
<TR><TD VALIGN="TOP">23</TD><TD VALIGN="TOP"><A NAME="XFACT_TAG">XFACT_TAG</A></TD><TD VALIGN="TOP"><B>xfact</B></TD></TR>
<TR><TD VALIGN="TOP">24</TD><TD VALIGN="TOP"><A NAME="YFACT_TAG">YFACT_TAG</A></TD><TD VALIGN="TOP"><B>yfact</B></TD></TR>
<TR><TD VALIGN="TOP">25</TD><TD VALIGN="TOP"><A NAME="ZFACT_TAG">ZFACT_TAG</A></TD><TD VALIGN="TOP"><B>zfact</B></TD></TR>
<TR><TD VALIGN="TOP">26</TD><TD VALIGN="TOP"><A NAME="XMIN_TAG">XMIN_TAG</A></TD><TD VALIGN="TOP"><B>xmin</B></TD></TR>
<TR><TD VALIGN="TOP">27</TD><TD VALIGN="TOP"><A NAME="XMAX_TAG">XMAX_TAG</A></TD><TD VALIGN="TOP"><B>xmax</B></TD></TR>
<TR><TD VALIGN="TOP">28</TD><TD VALIGN="TOP"><A NAME="XSCL_TAG">XSCL_TAG</A></TD><TD VALIGN="TOP"><B>xscl</B></TD></TR>
<TR><TD VALIGN="TOP">29</TD><TD VALIGN="TOP"><A NAME="YMIN_TAG">YMIN_TAG</A></TD><TD VALIGN="TOP"><B>ymin</B></TD></TR>
<TR><TD VALIGN="TOP">2A</TD><TD VALIGN="TOP"><A NAME="YMAX_TAG">YMAX_TAG</A></TD><TD VALIGN="TOP"><B>ymax</B></TD></TR>
<TR><TD VALIGN="TOP">2B</TD><TD VALIGN="TOP"><A NAME="YSCL_TAG">YSCL_TAG</A></TD><TD VALIGN="TOP"><B>yscl</B></TD></TR>
<TR><TD VALIGN="TOP">2C</TD><TD VALIGN="TOP"><A NAME="DELTA_X_TAG">DELTA_X_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">D</FONT>x</B></TD></TR>
<TR><TD VALIGN="TOP">2D</TD><TD VALIGN="TOP"><A NAME="DELTA_Y_TAG">DELTA_Y_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">D</FONT>y</B></TD></TR>
<TR><TD VALIGN="TOP">2E</TD><TD VALIGN="TOP"><A NAME="XRES_TAG">XRES_TAG</A></TD><TD VALIGN="TOP"><B>xres</B></TD></TR>
<TR><TD VALIGN="TOP">2F</TD><TD VALIGN="TOP"><A NAME="XGRID_TAG">XGRID_TAG</A></TD><TD VALIGN="TOP"><B>xgrid</B></TD></TR>
<TR><TD VALIGN="TOP">30</TD><TD VALIGN="TOP"><A NAME="YGRID_TAG">YGRID_TAG</A></TD><TD VALIGN="TOP"><B>ygrid</B></TD></TR>
<TR><TD VALIGN="TOP">31</TD><TD VALIGN="TOP"><A NAME="ZMIN_TAG">ZMIN_TAG</A></TD><TD VALIGN="TOP"><B>zmin</B></TD></TR>
<TR><TD VALIGN="TOP">32</TD><TD VALIGN="TOP"><A NAME="ZMAX_TAG">ZMAX_TAG</A></TD><TD VALIGN="TOP"><B>zmax</B></TD></TR>
<TR><TD VALIGN="TOP">33</TD><TD VALIGN="TOP"><A NAME="ZSCL_TAG">ZSCL_TAG</A></TD><TD VALIGN="TOP"><B>zscl</B></TD></TR>
<TR><TD VALIGN="TOP">34</TD><TD VALIGN="TOP"><A NAME="EYE_THETA_TAG">EYE_THETA_TAG</A></TD><TD VALIGN="TOP"><B>eye<FONT FACE="Symbol">q</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">35</TD><TD VALIGN="TOP"><A NAME="EYE_PHI_TAG">EYE_PHI_TAG</A></TD><TD VALIGN="TOP"><B>eye<FONT FACE="Symbol">F</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">36</TD><TD VALIGN="TOP"><A NAME="THETA_MIN_TAG">THETA_MIN_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">q</FONT>min</B></TD></TR>
<TR><TD VALIGN="TOP">37</TD><TD VALIGN="TOP"><A NAME="THETA_MAX_TAG">THETA_MAX_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">q</FONT>max</B></TD></TR>
<TR><TD VALIGN="TOP">38</TD><TD VALIGN="TOP"><A NAME="THETA_STEP_TAG">THETA_STEP_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">q</FONT>step</B></TD></TR>
<TR><TD VALIGN="TOP">39</TD><TD VALIGN="TOP"><A NAME="TMIN_TAG">TMIN_TAG</A></TD><TD VALIGN="TOP"><B>tmin</B></TD></TR>
<TR><TD VALIGN="TOP">3A</TD><TD VALIGN="TOP"><A NAME="TMAX_TAG">TMAX_TAG</A></TD><TD VALIGN="TOP"><B>tmax</B></TD></TR>
<TR><TD VALIGN="TOP">3B</TD><TD VALIGN="TOP"><A NAME="TSTEP_TAG">TSTEP_TAG</A></TD><TD VALIGN="TOP"><B>tstep</B></TD></TR>
<TR><TD VALIGN="TOP">3C</TD><TD VALIGN="TOP"><A NAME="NMIN_TAG">NMIN_TAG</A></TD><TD VALIGN="TOP"><B>nmin</B></TD></TR>
<TR><TD VALIGN="TOP">3D</TD><TD VALIGN="TOP"><A NAME="NMAX_TAG">NMAX_TAG</A></TD><TD VALIGN="TOP"><B>nmax</B></TD></TR>
<TR><TD VALIGN="TOP">3E</TD><TD VALIGN="TOP"><A NAME="PLOTSTRT_TAG">PLOTSTRT_TAG</A></TD><TD VALIGN="TOP"><B>plotStrt</B></TD></TR>
<TR><TD VALIGN="TOP">3F</TD><TD VALIGN="TOP"><A NAME="PLOTSTEP_TAG">PLOTSTEP_TAG</A></TD><TD VALIGN="TOP"><B>plotStep</B></TD></TR>
<TR><TD VALIGN="TOP">40</TD><TD VALIGN="TOP"><A NAME="ZXMIN_TAG">ZXMIN_TAG</A></TD><TD VALIGN="TOP"><B>zxmin</B></TD></TR>
<TR><TD VALIGN="TOP">41</TD><TD VALIGN="TOP"><A NAME="ZXMAX_TAG">ZXMAX_TAG</A></TD><TD VALIGN="TOP"><B>zxmax</B></TD></TR>
<TR><TD VALIGN="TOP">42</TD><TD VALIGN="TOP"><A NAME="ZXSCL_TAG">ZXSCL_TAG</A></TD><TD VALIGN="TOP"><B>zxscl</B></TD></TR>
<TR><TD VALIGN="TOP">43</TD><TD VALIGN="TOP"><A NAME="ZYMIN_TAG">ZYMIN_TAG</A></TD><TD VALIGN="TOP"><B>zymin</B></TD></TR>
<TR><TD VALIGN="TOP">44</TD><TD VALIGN="TOP"><A NAME="ZYMAX_TAG">ZYMAX_TAG</A></TD><TD VALIGN="TOP"><B>zymax</B></TD></TR>
<TR><TD VALIGN="TOP">45</TD><TD VALIGN="TOP"><A NAME="ZYSCL_TAG">ZYSCL_TAG</A></TD><TD VALIGN="TOP"><B>zyscl</B></TD></TR>
<TR><TD VALIGN="TOP">46</TD><TD VALIGN="TOP"><A NAME="ZXRES_TAG">ZXRES_TAG</A></TD><TD VALIGN="TOP"><B>zxres</B></TD></TR>
<TR><TD VALIGN="TOP">47</TD><TD VALIGN="TOP"><A NAME="Z_THETA_MIN_TAG">Z_THETA_MIN_TAG</A></TD><TD VALIGN="TOP"><B>z<FONT FACE="Symbol">q</FONT>min</B></TD></TR>
<TR><TD VALIGN="TOP">48</TD><TD VALIGN="TOP"><A NAME="Z_THETA_MAX_TAG">Z_THETA_MAX_TAG</A></TD><TD VALIGN="TOP"><B>z<FONT FACE="Symbol">q</FONT>max</B></TD></TR>
<TR><TD VALIGN="TOP">49</TD><TD VALIGN="TOP"><A NAME="Z_THETA_STEP_TAG">Z_THETA_STEP_TAG</A>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD VALIGN="TOP"><B>z<FONT FACE="Symbol">q</FONT>step</B></TD></TR>
<TR><TD VALIGN="TOP">4A</TD><TD VALIGN="TOP"><A NAME="ZTMIN_TAG">ZTMIN_TAG</A></TD><TD VALIGN="TOP"><B>ztmin</B></TD></TR>
<TR><TD VALIGN="TOP">4B</TD><TD VALIGN="TOP"><A NAME="ZTMAX_TAG">ZTMAX_TAG</A></TD><TD VALIGN="TOP"><B>ztmax</B></TD></TR>
<TR><TD VALIGN="TOP">4C</TD><TD VALIGN="TOP"><A NAME="ZTSTEP_TAG">ZTSTEP_TAG</A></TD><TD VALIGN="TOP"><B>ztstep</B></TD></TR>
<TR><TD VALIGN="TOP">4D</TD><TD VALIGN="TOP"><A NAME="ZXGRID_TAG">ZXGRID_TAG</A></TD><TD VALIGN="TOP"><B>zxgrid</B></TD></TR>
<TR><TD VALIGN="TOP">4E</TD><TD VALIGN="TOP"><A NAME="ZYGRID_TAG">ZYGRID_TAG</A></TD><TD VALIGN="TOP"><B>zygrid</B></TD></TR>
<TR><TD VALIGN="TOP">4F</TD><TD VALIGN="TOP"><A NAME="ZZMIN_TAG">ZZMIN_TAG</A></TD><TD VALIGN="TOP"><B>zzmin</B></TD></TR>
<TR><TD VALIGN="TOP">50</TD><TD VALIGN="TOP"><A NAME="ZZMAX_TAG">ZZMAX_TAG</A></TD><TD VALIGN="TOP"><B>zzmax</B></TD></TR>
<TR><TD VALIGN="TOP">51</TD><TD VALIGN="TOP"><A NAME="ZZSCL_TAG">ZZSCL_TAG</A></TD><TD VALIGN="TOP"><B>zzscl</B></TD></TR>
<TR><TD VALIGN="TOP">52</TD><TD VALIGN="TOP"><A NAME="ZEYE_THETA_TAG">ZEYE_THETA_TAG</A></TD><TD VALIGN="TOP"><B>zeye<FONT FACE="Symbol">q</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">53</TD><TD VALIGN="TOP"><A NAME="ZEYE_PHI_TAG">ZEYE_PHI_TAG</A></TD><TD VALIGN="TOP"><B>zeye<FONT FACE="Symbol">F</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">54</TD><TD VALIGN="TOP"><A NAME="ZNMIN_TAG">ZNMIN_TAG</A></TD><TD VALIGN="TOP"><B>znmin</B></TD></TR>
<TR><TD VALIGN="TOP">55</TD><TD VALIGN="TOP"><A NAME="ZNMAX_TAG">ZNMAX_TAG</A></TD><TD VALIGN="TOP"><B>znmax</B></TD></TR>
<TR><TD VALIGN="TOP">56</TD><TD VALIGN="TOP"><A NAME="ZPLTSTEP_TAG">ZPLTSTEP_TAG</A></TD><TD VALIGN="TOP"><B>zpltstep</B></TD></TR>
<TR><TD VALIGN="TOP">57</TD><TD VALIGN="TOP"><A NAME="ZPLTSTRT_TAG">ZPLTSTRT_TAG</A></TD><TD VALIGN="TOP"><B>zpltstrt</B></TD></TR>
<TR><TD VALIGN="TOP">58</TD><TD VALIGN="TOP"><A NAME="SEED1_TAG">SEED1_TAG</A></TD><TD VALIGN="TOP"><B>seed1</B></TD></TR>
<TR><TD VALIGN="TOP">59</TD><TD VALIGN="TOP"><A NAME="SEED2_TAG">SEED2_TAG</A></TD><TD VALIGN="TOP"><B>seed2</B></TD></TR>
<TR><TD VALIGN="TOP">5A</TD><TD VALIGN="TOP"><A NAME="OK_TAG">OK_TAG</A></TD><TD VALIGN="TOP"><B>ok</B></TD></TR>
<TR><TD VALIGN="TOP">5B</TD><TD VALIGN="TOP"><A NAME="ERRORNUM_TAG">ERRORNUM_TAG</A></TD><TD VALIGN="TOP"><B>errornum</B></TD></TR>
<TR><TD VALIGN="TOP">5C</TD><TD VALIGN="TOP"><A NAME="SYSMATH_TAG">SYSMATH_TAG</A></TD><TD VALIGN="TOP"><B>sysMath</B></TD></TR>
<TR><TD VALIGN="TOP">5D</TD><TD VALIGN="TOP"><A NAME="SYSDATA_TAG">SYSDATA_TAG</A></TD><TD VALIGN="TOP"><B>sysData</B></TD></TR>
<TR><TD VALIGN="TOP">5E</TD><TD VALIGN="TOP"><A NAME="REGEQ_TAG">REGEQ_TAG</A></TD><TD VALIGN="TOP"><B>regEq</B> (Name = null)</TD></TR>
<TR><TD VALIGN="TOP">5F</TD><TD VALIGN="TOP"><A NAME="REGCOEF_TAG">REGCOEF_TAG</A></TD><TD VALIGN="TOP"><B>regCoef</B></TD></TR>
<TR><TD VALIGN="TOP">60</TD><TD VALIGN="TOP"><A NAME="TBLINPUT_TAG">TBLINPUT_TAG</A></TD><TD VALIGN="TOP"><B>tblInput</B></TD></TR>
<TR><TD VALIGN="TOP">61</TD><TD VALIGN="TOP"><A NAME="TBLSTART_TAG">TBLSTART_TAG</A></TD><TD VALIGN="TOP"><B>tblStart</B></TD></TR>
<TR><TD VALIGN="TOP">62</TD><TD VALIGN="TOP"><A NAME="DELTA_TBL_TAG">DELTA_TBL_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">D</FONT>tbl</B></TD></TR>
<TR><TD VALIGN="TOP">63</TD><TD VALIGN="TOP"><A NAME="FLDPIC_TAG">FLDPIC_TAG</A></TD><TD VALIGN="TOP"><B>fldpic</B> (this tag is suspicious)</TD></TR>
<TR><TD VALIGN="TOP">64</TD><TD VALIGN="TOP"><A NAME="EYE_PSI_TAG">EYE_PSI_TAG</A></TD><TD VALIGN="TOP"><B>eye<FONT FACE="Symbol">Y</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">65</TD><TD VALIGN="TOP"><A NAME="TPLOT_TAG">TPLOT_TAG</A></TD><TD VALIGN="TOP"><B>tplot</B></TD></TR>
<TR><TD VALIGN="TOP">66</TD><TD VALIGN="TOP"><A NAME="DIFTOL_TAG">DIFTOL_TAG</A></TD><TD VALIGN="TOP"><B>diftol</B></TD></TR>
<TR><TD VALIGN="TOP">67</TD><TD VALIGN="TOP"><A NAME="ZEYE_PSI_TAG">ZEYE_PSI_TAG</A></TD><TD VALIGN="TOP"><B>zeye<FONT FACE="Symbol">Y</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">68</TD><TD VALIGN="TOP"><A NAME="T0_TAG">T0_TAG</A></TD><TD VALIGN="TOP"><B>t0</B></TD></TR>
<TR><TD VALIGN="TOP">69</TD><TD VALIGN="TOP"><A NAME="DTIME_TAG">DTIME_TAG</A></TD><TD VALIGN="TOP"><B>dtime</B></TD></TR>
<TR><TD VALIGN="TOP">6A</TD><TD VALIGN="TOP"><A NAME="NCURVES_TAG">NCURVES_TAG</A></TD><TD VALIGN="TOP"><B>ncurves</B></TD></TR>
<TR><TD VALIGN="TOP">6B</TD><TD VALIGN="TOP"><A NAME="FLDRES_TAG">FLDRES_TAG</A></TD><TD VALIGN="TOP"><B>fldres</B></TD></TR>
<TR><TD VALIGN="TOP">6C</TD><TD VALIGN="TOP"><A NAME="ESTEP_TAG">ESTEP_TAG</A></TD><TD VALIGN="TOP"><B>Estep</B></TD></TR>
<TR><TD VALIGN="TOP">6D</TD><TD VALIGN="TOP"><A NAME="ZT0DE_TAG">ZT0DE_TAG</A></TD><TD VALIGN="TOP"><B>zt0de</B></TD></TR>
<TR><TD VALIGN="TOP">6E</TD><TD VALIGN="TOP"><A NAME="ZTMAXDE_TAG">ZTMAXDE_TAG</A></TD><TD VALIGN="TOP"><B>ztmaxde</B> (Name = ztmax)</TD></TR>
<TR><TD VALIGN="TOP">6F</TD><TD VALIGN="TOP"><A NAME="ZTSTEPDE_TAG">ZTSTEPDE_TAG</A></TD><TD VALIGN="TOP"><B>ztstepde</B> (Name = ztstep)</TD></TR>
<TR><TD VALIGN="TOP">70</TD><TD VALIGN="TOP"><A NAME="ZTPLOTDE_TAG">ZTPLOTDE_TAG</A></TD><TD VALIGN="TOP"><B>ztplotde</B></TD></TR>
<TR><TD VALIGN="TOP">71</TD><TD VALIGN="TOP"><A NAME="NCONTOUR_TAG">NCONTOUR_TAG</A></TD><TD VALIGN="TOP"><B>ncontour</B></TD></TR>
</TABLE></P>

<HR>
<H3><A NAME="tag_info"><U>tag_info</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#struct">struct</A></B> {
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_order;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> tag_version;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> min_max_args; <I>/* 4 MSB for minimal number of arguments, 4 LSB for maximal number of arguments */</I><BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#int">char</A></B> proc_args;<BR>
<B><A HREF="keywords.html#void">void</A></B> (*<A HREF="gnuexts.html#SEC85">CALLBACK</A> tag_proc) (); <I>/* routine that handles the tag */</I><BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> tag_str; <I>/* Pointer to string data on AMS 1.xx, string ID suitable for XR_stringPtr on later AMS versions */</I><BR>
</TD></TR></TABLE>
} tag_info;</TD></TR></TABLE></P>
<P><B>Structure containing information about AMS EStack tags (<A HREF="#Tags">Tags</A>, <A HREF="#ExtTags">ExtTags</A>).</B></P>

<HR>
<H3><A NAME="Tags"><U>Tags</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> Tags {...};</TD></TR></TABLE></P>
<P><B>An enumeration to describe types of entries on the expression stack.</B></P>

<P>This enum is very large, as there are a lot of various entries.
See <A HREF="#top_estack">top_estack</A> for more info about how entries on the
expression stack are organized.
Here is a complete list of tags with their values in hexadecimal notation, along with their meaning written in RPN:
<BR><BR>
<TABLE CLASS="NOBORDER">
<TR><TD VALIGN="TOP" WIDTH="30">00</TD><TD VALIGN="TOP"><A NAME="VAR_NAME_TAG">VAR_NAME_TAG</A></TD><TD VALIGN="TOP">variable name (with more than one letter): <B>'\0'</B> <I>var_name</I> <B>'\0'</B></TD></TR>
<TR><TD VALIGN="TOP">01</TD><TD VALIGN="TOP"><A NAME="_VAR_Q_TAG">_VAR_Q_TAG</A></TD><TD VALIGN="TOP">variable <B>q</B> (but not used - 1B is used normally)</TD></TR>
<TR><TD VALIGN="TOP">02</TD><TD VALIGN="TOP"><A NAME="VAR_R_TAG">VAR_R_TAG</A></TD><TD VALIGN="TOP">variable <B>r</B></TD></TR>
<TR><TD VALIGN="TOP">03</TD><TD VALIGN="TOP"><A NAME="VAR_S_TAG">VAR_S_TAG</A></TD><TD VALIGN="TOP">variable <B>s</B></TD></TR>
<TR><TD VALIGN="TOP">04</TD><TD VALIGN="TOP"><A NAME="VAR_T_TAG">VAR_T_TAG</A></TD><TD VALIGN="TOP">variable <B>t</B></TD></TR>
<TR><TD VALIGN="TOP">05</TD><TD VALIGN="TOP"><A NAME="VAR_U_TAG">VAR_U_TAG</A></TD><TD VALIGN="TOP">variable <B>u</B></TD></TR>
<TR><TD VALIGN="TOP">06</TD><TD VALIGN="TOP"><A NAME="VAR_V_TAG">VAR_V_TAG</A></TD><TD VALIGN="TOP">variable <B>v</B></TD></TR>
<TR><TD VALIGN="TOP">07</TD><TD VALIGN="TOP"><A NAME="VAR_W_TAG">VAR_W_TAG</A></TD><TD VALIGN="TOP">variable <B>w</B></TD></TR>
<TR><TD VALIGN="TOP">08</TD><TD VALIGN="TOP"><A NAME="VAR_X_TAG">VAR_X_TAG</A></TD><TD VALIGN="TOP">variable <B>x</B></TD></TR>
<TR><TD VALIGN="TOP">09</TD><TD VALIGN="TOP"><A NAME="VAR_Y_TAG">VAR_Y_TAG</A></TD><TD VALIGN="TOP">variable <B>y</B></TD></TR>
<TR><TD VALIGN="TOP">0A</TD><TD VALIGN="TOP"><A NAME="VAR_Z_TAG">VAR_Z_TAG</A></TD><TD VALIGN="TOP">variable <B>z</B></TD></TR>
<TR><TD VALIGN="TOP">0B</TD><TD VALIGN="TOP"><A NAME="VAR_A_TAG">VAR_A_TAG</A></TD><TD VALIGN="TOP">variable <B>a</B></TD></TR>
<TR><TD VALIGN="TOP">0C</TD><TD VALIGN="TOP"><A NAME="VAR_B_TAG">VAR_B_TAG</A></TD><TD VALIGN="TOP">variable <B>b</B></TD></TR>
<TR><TD VALIGN="TOP">0D</TD><TD VALIGN="TOP"><A NAME="VAR_C_TAG">VAR_C_TAG</A></TD><TD VALIGN="TOP">variable <B>c</B></TD></TR>
<TR><TD VALIGN="TOP">0E</TD><TD VALIGN="TOP"><A NAME="VAR_D_TAG">VAR_D_TAG</A></TD><TD VALIGN="TOP">variable <B>d</B></TD></TR>
<TR><TD VALIGN="TOP">0F</TD><TD VALIGN="TOP"><A NAME="VAR_E_TAG">VAR_E_TAG</A></TD><TD VALIGN="TOP">variable <B>e</B></TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD VALIGN="TOP"><A NAME="VAR_F_TAG">VAR_F_TAG</A></TD><TD VALIGN="TOP">variable <B>f</B></TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD VALIGN="TOP"><A NAME="VAR_G_TAG">VAR_G_TAG</A></TD><TD VALIGN="TOP">variable <B>g</B></TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD VALIGN="TOP"><A NAME="VAR_H_TAG">VAR_H_TAG</A></TD><TD VALIGN="TOP">variable <B>h</B></TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD VALIGN="TOP"><A NAME="VAR_I_TAG">VAR_I_TAG</A></TD><TD VALIGN="TOP">variable <B>i</B></TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD VALIGN="TOP"><A NAME="VAR_J_TAG">VAR_J_TAG</A></TD><TD VALIGN="TOP">variable <B>j</B></TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD VALIGN="TOP"><A NAME="VAR_K_TAG">VAR_K_TAG</A></TD><TD VALIGN="TOP">variable <B>k</B></TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD VALIGN="TOP"><A NAME="VAR_L_TAG">VAR_L_TAG</A></TD><TD VALIGN="TOP">variable <B>l</B></TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD VALIGN="TOP"><A NAME="VAR_M_TAG">VAR_M_TAG</A></TD><TD VALIGN="TOP">variable <B>m</B></TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD VALIGN="TOP"><A NAME="VAR_N_TAG">VAR_N_TAG</A></TD><TD VALIGN="TOP">variable <B>n</B></TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD VALIGN="TOP"><A NAME="VAR_O_TAG">VAR_O_TAG</A></TD><TD VALIGN="TOP">variable <B>o</B></TD></TR>
<TR><TD VALIGN="TOP">1A</TD><TD VALIGN="TOP"><A NAME="VAR_P_TAG">VAR_P_TAG</A></TD><TD VALIGN="TOP">variable <B>p</B></TD></TR>
<TR><TD VALIGN="TOP">1B</TD><TD VALIGN="TOP"><A NAME="VAR_Q_TAG">VAR_Q_TAG</A></TD><TD VALIGN="TOP">variable <B>q</B></TD></TR>
<TR><TD VALIGN="TOP">1C</TD><TD VALIGN="TOP"><A NAME="EXT_SYSTEM_TAG">EXT_SYSTEM_TAG</A></TD><TD VALIGN="TOP">system token (a byte before the tag identifies a system variable, see <A HREF="#SysvarTags">SysvarTags</A>)</TD></TR>
<TR><TD VALIGN="TOP">1D</TD><TD VALIGN="TOP"><A NAME="ARB_REAL_TAG">ARB_REAL_TAG</A></TD><TD VALIGN="TOP">arbitrary real number <B>@<I>xxx</I></B> (byte before the tag determines <I>xxx</I>)</TD></TR>
<TR><TD VALIGN="TOP">1E</TD><TD VALIGN="TOP"><A NAME="ARB_INT_TAG">ARB_INT_TAG</A></TD><TD VALIGN="TOP">arbitrary integer number <B>@n<I>xxx</I></B> (byte before the tag determines <I>xxx</I>)</TD></TR>
<TR><TD VALIGN="TOP">1F</TD><TD VALIGN="TOP"><A NAME="POSINT_TAG">POSINT_TAG</A></TD><TD VALIGN="TOP">positive integer tag</TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD VALIGN="TOP"><A NAME="NEGINT_TAG">NEGINT_TAG</A></TD><TD VALIGN="TOP">negative integer tag</TD></TR>
<TR><TD VALIGN="TOP">21</TD><TD VALIGN="TOP"><A NAME="POSFRAC_TAG">POSFRAC_TAG</A></TD><TD VALIGN="TOP">positive fraction tag</TD></TR>
<TR><TD VALIGN="TOP">22</TD><TD VALIGN="TOP"><A NAME="NEGFRAC_TAG">NEGFRAC_TAG</A></TD><TD VALIGN="TOP">negative fraction tag</TD></TR>
<TR><TD VALIGN="TOP">23</TD><TD VALIGN="TOP"><A NAME="FLOAT_TAG">FLOAT_TAG</A></TD><TD VALIGN="TOP">floating point tag</TD></TR>
<TR><TD VALIGN="TOP">23</TD><TD VALIGN="TOP"><A NAME="BCD_TAG">BCD_TAG</A></TD><TD VALIGN="TOP">floating point tag (alias tag name)</TD></TR>
<TR><TD VALIGN="TOP">24</TD><TD VALIGN="TOP"><A NAME="PI_TAG">PI_TAG</A></TD><TD VALIGN="TOP">constant <B><FONT FACE="Symbol">p</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">25</TD><TD VALIGN="TOP"><A NAME="EXP_TAG">EXP_TAG</A></TD><TD VALIGN="TOP">constant <B><I>e</I></B></TD></TR>
<TR><TD VALIGN="TOP">26</TD><TD VALIGN="TOP"><A NAME="IM_TAG">IM_TAG</A></TD><TD VALIGN="TOP">constant <B><I>i</I></B></TD></TR>
<TR><TD VALIGN="TOP">27</TD><TD VALIGN="TOP"><A NAME="NEGINFINITY_TAG">NEGINFINITY_TAG</A></TD><TD VALIGN="TOP">-<B><FONT FACE="Symbol">&#165;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">28</TD><TD VALIGN="TOP"><A NAME="INFINITY_TAG">INFINITY_TAG</A></TD><TD VALIGN="TOP"><B><FONT FACE="Symbol">&#165;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">29</TD><TD VALIGN="TOP"><A NAME="PN_INFINITY_TAG">PN_INFINITY_TAG</A></TD><TD VALIGN="TOP"><B>+/- <FONT FACE="Symbol">&#165;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">2A</TD><TD VALIGN="TOP"><A NAME="UNDEF_TAG">UNDEF_TAG</A></TD><TD VALIGN="TOP"><B>undef</B></TD></TR>
<TR><TD VALIGN="TOP">2B</TD><TD VALIGN="TOP"><A NAME="FALSE_TAG">FALSE_TAG</A></TD><TD VALIGN="TOP"><B>false</B></TD></TR>
<TR><TD VALIGN="TOP">2C</TD><TD VALIGN="TOP"><A NAME="TRUE_TAG">TRUE_TAG</A></TD><TD VALIGN="TOP"><B>true</B></TD></TR>
<TR><TD VALIGN="TOP">2D</TD><TD VALIGN="TOP"><A NAME="STR_TAG">STR_TAG</A></TD><TD VALIGN="TOP">string tag: <B>'\0'</B> <I>string</I> <B>'\0'</B> <B>STR_TAG</B></TD></TR>
<TR><TD VALIGN="TOP">2E</TD><TD VALIGN="TOP"><A NAME="NOTHING_TAG">NOTHING_TAG</A></TD><TD VALIGN="TOP">allows missing terms in expressions</TD></TR>
<TR><TD VALIGN="TOP">2F</TD><TD VALIGN="TOP"><A NAME="ACOSH_TAG">ACOSH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>acosh</B></TD></TR>
<TR><TD VALIGN="TOP">30</TD><TD VALIGN="TOP"><A NAME="ASINH_TAG">ASINH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>asinh</B></TD></TR>
<TR><TD VALIGN="TOP">31</TD><TD VALIGN="TOP"><A NAME="ATANH_TAG">ATANH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>atanh</B></TD></TR>
<TR><TD VALIGN="TOP">32</TD><TD VALIGN="TOP"><A NAME="ASECH_TAG">ASECH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>asech</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">33</TD><TD VALIGN="TOP"><A NAME="ACSCH_TAG">ACSCH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>acsch</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">34</TD><TD VALIGN="TOP"><A NAME="ACOTH_TAG">ACOTH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>acoth</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">35</TD><TD VALIGN="TOP"><A NAME="COSH_TAG">COSH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>cosh</B></TD></TR>
<TR><TD VALIGN="TOP">36</TD><TD VALIGN="TOP"><A NAME="SINH_TAG">SINH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>sinh</B></TD></TR>
<TR><TD VALIGN="TOP">37</TD><TD VALIGN="TOP"><A NAME="TANH_TAG">TANH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>tanh</B></TD></TR>
<TR><TD VALIGN="TOP">38</TD><TD VALIGN="TOP"><A NAME="SECH_TAG">SECH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>sech</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">39</TD><TD VALIGN="TOP"><A NAME="CSCH_TAG">CSCH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>csch</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">3A</TD><TD VALIGN="TOP"><A NAME="COTH_TAG">COTH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>coth</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">3B</TD><TD VALIGN="TOP"><A NAME="ACOS_TAG">ACOS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>acos</B></TD></TR>
<TR><TD VALIGN="TOP">3C</TD><TD VALIGN="TOP"><A NAME="ASIN_TAG">ASIN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>asin</B></TD></TR>
<TR><TD VALIGN="TOP">3D</TD><TD VALIGN="TOP"><A NAME="ATAN_TAG">ATAN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>atan</B></TD></TR>
<TR><TD VALIGN="TOP">3E</TD><TD VALIGN="TOP"><A NAME="ASEC_TAG">ASEC_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>asec</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">3F</TD><TD VALIGN="TOP"><A NAME="ACSC_TAG">ACSC_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>acsc</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">40</TD><TD VALIGN="TOP"><A NAME="ACOT_TAG">ACOT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>acot</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">41</TD><TD VALIGN="TOP"><A NAME="RACOS_TAG">RACOS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>arcos</B> (used only internally)</TD></TR>
<TR><TD VALIGN="TOP">42</TD><TD VALIGN="TOP"><A NAME="RASIN_TAG">RASIN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>arsin</B> (used only internally)</TD></TR>
<TR><TD VALIGN="TOP">43</TD><TD VALIGN="TOP"><A NAME="RATAN_TAG">RATAN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>artan</B> (used only internally)</TD></TR>
<TR><TD VALIGN="TOP">44</TD><TD VALIGN="TOP"><A NAME="COS_TAG">COS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>cos</B></TD></TR>
<TR><TD VALIGN="TOP">45</TD><TD VALIGN="TOP"><A NAME="SIN_TAG">SIN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>sin</B></TD></TR>
<TR><TD VALIGN="TOP">46</TD><TD VALIGN="TOP"><A NAME="TAN_TAG">TAN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>tan</B></TD></TR>
<TR><TD VALIGN="TOP">47</TD><TD VALIGN="TOP"><A NAME="SEC_TAG">SEC_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>sec</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">48</TD><TD VALIGN="TOP"><A NAME="CSC_TAG">CSC_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>csc</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">49</TD><TD VALIGN="TOP"><A NAME="COT_TAG">COT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>cot</B> (AMS 2.08 or higher)</TD></TR>
<TR><TD VALIGN="TOP">4A</TD><TD VALIGN="TOP"><A NAME="ITAN_TAG">ITAN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>tan</B> (used only internally)</TD></TR>
<TR><TD VALIGN="TOP">4B</TD><TD VALIGN="TOP"><A NAME="ABS_TAG">ABS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>abs</B></TD></TR>
<TR><TD VALIGN="TOP">4C</TD><TD VALIGN="TOP"><A NAME="ANGLE_TAG">ANGLE_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>angle</B></TD></TR>
<TR><TD VALIGN="TOP">4D</TD><TD VALIGN="TOP"><A NAME="CEILING_TAG">CEILING_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>ceiling</B></TD></TR>
<TR><TD VALIGN="TOP">4E</TD><TD VALIGN="TOP"><A NAME="FLOOR_TAG">FLOOR_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>floor</B></TD></TR>
<TR><TD VALIGN="TOP">4F</TD><TD VALIGN="TOP"><A NAME="INT_TAG">INT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>int</B></TD></TR>
<TR><TD VALIGN="TOP">50</TD><TD VALIGN="TOP"><A NAME="SIGN_TAG">SIGN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>sign</B></TD></TR>
<TR><TD VALIGN="TOP">51</TD><TD VALIGN="TOP"><A NAME="SQRT_TAG">SQRT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B><FONT FACE="Symbol">&#214;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">52</TD><TD VALIGN="TOP"><A NAME="EXPF_TAG">EXPF_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B><I>e</I>^</B></TD></TR>
<TR><TD VALIGN="TOP">53</TD><TD VALIGN="TOP"><A NAME="LN_TAG">LN_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>ln</B></TD></TR>
<TR><TD VALIGN="TOP">54</TD><TD VALIGN="TOP"><A NAME="LOG_TAG">LOG_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>log</B></TD></TR>
<TR><TD VALIGN="TOP">55</TD><TD VALIGN="TOP"><A NAME="FPART_TAG">FPART_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>fPart</B></TD></TR>
<TR><TD VALIGN="TOP">56</TD><TD VALIGN="TOP"><A NAME="IPART_TAG">IPART_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>iPart</B></TD></TR>
<TR><TD VALIGN="TOP">57</TD><TD VALIGN="TOP"><A NAME="CONJ_TAG">CONJ_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>conj</B></TD></TR>
<TR><TD VALIGN="TOP">58</TD><TD VALIGN="TOP"><A NAME="IMAG_TAG">IMAG_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>imag</B></TD></TR>
<TR><TD VALIGN="TOP">59</TD><TD VALIGN="TOP"><A NAME="REAL_TAG">REAL_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>real</B></TD></TR>
<TR><TD VALIGN="TOP">5A</TD><TD VALIGN="TOP"><A NAME="APPROX_TAG">APPROX_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>approx</B></TD></TR>
<TR><TD VALIGN="TOP">5B</TD><TD VALIGN="TOP"><A NAME="TEXPAND_TAG">TEXPAND_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>tExpand</B></TD></TR>
<TR><TD VALIGN="TOP">5C</TD><TD VALIGN="TOP"><A NAME="TCOLLECT_TAG">TCOLLECT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>tCollect</B></TD></TR>
<TR><TD VALIGN="TOP">5D</TD><TD VALIGN="TOP"><A NAME="GETDENOM_TAG">GETDENOM_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>getDenom</B></TD></TR>
<TR><TD VALIGN="TOP">5E</TD><TD VALIGN="TOP"><A NAME="GETNUM_TAG">GETNUM_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>getNum</B></TD></TR>
<TR><TD VALIGN="TOP">5F</TD><TD VALIGN="TOP"><A NAME="ERROR_TAG">ERROR_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>_ERROR_</B> (used only internally)</TD></TR>
<TR><TD VALIGN="TOP">60</TD><TD VALIGN="TOP"><A NAME="CUMSUM_TAG">CUMSUM_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>cumSum</B></TD></TR>
<TR><TD VALIGN="TOP">61</TD><TD VALIGN="TOP"><A NAME="DET_TAG">DET_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>det</B></TD></TR>
<TR><TD VALIGN="TOP">62</TD><TD VALIGN="TOP"><A NAME="COLNORM_TAG">COLNORM_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>colNorm</B></TD></TR>
<TR><TD VALIGN="TOP">63</TD><TD VALIGN="TOP"><A NAME="ROWNORM_TAG">ROWNORM_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>rowNorm</B></TD></TR>
<TR><TD VALIGN="TOP">64</TD><TD VALIGN="TOP"><A NAME="NORM_TAG">NORM_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>norm</B></TD></TR>
<TR><TD VALIGN="TOP">65</TD><TD VALIGN="TOP"><A NAME="MEAN_TAG">MEAN_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>mean</B></TD></TR>
<TR><TD VALIGN="TOP">66</TD><TD VALIGN="TOP"><A NAME="MEDIAN_TAG">MEDIAN_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>median</B></TD></TR>
<TR><TD VALIGN="TOP">67</TD><TD VALIGN="TOP"><A NAME="PRODUCT_TAG">PRODUCT_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>product</B></TD></TR>
<TR><TD VALIGN="TOP">68</TD><TD VALIGN="TOP"><A NAME="STDDEV_TAG">STDDEV_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>stdDev</B></TD></TR>
<TR><TD VALIGN="TOP">69</TD><TD VALIGN="TOP"><A NAME="SUM_TAG">SUM_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>sum</B></TD></TR>
<TR><TD VALIGN="TOP">6A</TD><TD VALIGN="TOP"><A NAME="VARIANCE_TAG">VARIANCE_TAG</A></TD><TD VALIGN="TOP"><I>list</I> <B>variance</B></TD></TR>
<TR><TD VALIGN="TOP">6B</TD><TD VALIGN="TOP"><A NAME="UNITV_TAG">UNITV_TAG</A></TD><TD VALIGN="TOP"><I>vec</I> <B>unitV</B></TD></TR>
<TR><TD VALIGN="TOP">6C</TD><TD VALIGN="TOP"><A NAME="DIM_TAG">DIM_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>dim</B></TD></TR>
<TR><TD VALIGN="TOP">6D</TD><TD VALIGN="TOP"><A NAME="MAT2LIST_TAG">MAT2LIST_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>mat&gt;list</B></TD></TR>
<TR><TD VALIGN="TOP">6E</TD><TD VALIGN="TOP"><A NAME="NEWLIST_TAG">NEWLIST_TAG</A></TD><TD VALIGN="TOP"><I>no_of_elements</I> <B>newList</B></TD></TR>
<TR><TD VALIGN="TOP">6F</TD><TD VALIGN="TOP"><A NAME="RREF_TAG">RREF_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>rref</B></TD></TR>
<TR><TD VALIGN="TOP">70</TD><TD VALIGN="TOP"><A NAME="REF_TAG">REF_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>ref</B></TD></TR>
<TR><TD VALIGN="TOP">71</TD><TD VALIGN="TOP"><A NAME="IDENTITY_TAG">IDENTITY_TAG</A></TD><TD VALIGN="TOP"><I>integer</I> <B>identity</B></TD></TR>
<TR><TD VALIGN="TOP">72</TD><TD VALIGN="TOP"><A NAME="DIAG_TAG">DIAG_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>diag</B></TD></TR>
<TR><TD VALIGN="TOP">73</TD><TD VALIGN="TOP"><A NAME="COLDIM_TAG">COLDIM_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>colDim</B></TD></TR>
<TR><TD VALIGN="TOP">74</TD><TD VALIGN="TOP"><A NAME="ROWDIM_TAG">ROWDIM_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>rowDim</B></TD></TR>
<TR><TD VALIGN="TOP">75</TD><TD VALIGN="TOP"><A NAME="TRANSPOSE_TAG">TRANSPOSE_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B><SUP>T</SUP></B></TD></TR>
<TR><TD VALIGN="TOP">76</TD><TD VALIGN="TOP"><A NAME="FACTORIAL_TAG">FACTORIAL_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>!</B></TD></TR>
<TR><TD VALIGN="TOP">77</TD><TD VALIGN="TOP"><A NAME="PERCENT_TAG">PERCENT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>%</B></TD></TR>
<TR><TD VALIGN="TOP">78</TD><TD VALIGN="TOP"><A NAME="RADIANS_TAG">RADIANS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B><SUP>r</SUP></B></TD></TR>
<TR><TD VALIGN="TOP">79</TD><TD VALIGN="TOP"><A NAME="NOT_TAG">NOT_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>not</B></TD></TR>
<TR><TD VALIGN="TOP">7A</TD><TD VALIGN="TOP"><A NAME="MINUS_TAG">MINUS_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>_negative_</B></TD></TR>
<TR><TD VALIGN="TOP">7B</TD><TD VALIGN="TOP"><A NAME="VEC_POLAR_TAG">VEC_POLAR_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>_polar_vector_</B> (<I>mat</I> is assumed to be [[r,<FONT FACE="Symbol">q</FONT>]])</TD></TR>
<TR><TD VALIGN="TOP">7C</TD><TD VALIGN="TOP"><A NAME="VEC_CYLIND_TAG">VEC_CYLIND_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>_cylind_vector_</B> (<I>mat</I> is assumed to be [[r,<FONT FACE="Symbol">q</FONT>,z]])</TD></TR>
<TR><TD VALIGN="TOP">7D</TD><TD VALIGN="TOP"><A NAME="VEC_SPHERE_TAG">VEC_SPHERE_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>_sphere_vector_</B> (<I>mat</I> is assumed to be [[r,<FONT FACE="Symbol">q</FONT>,<FONT FACE="Symbol">F</FONT>]])</TD></TR>
<TR><TD VALIGN="TOP">7E</TD><TD VALIGN="TOP"><A NAME="START_TAG">START_TAG</A></TD><TD VALIGN="TOP"><B>(</B> (used only internally, don't use it)</TD></TR>
<TR><TD VALIGN="TOP">7F</TD><TD VALIGN="TOP"><A NAME="ISTORE_TAG">ISTORE_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <I>var</I> <B>-&gt;</B> (internal version: don't use)</TD></TR>
<TR><TD VALIGN="TOP">80</TD><TD VALIGN="TOP"><A NAME="STORE_TAG">STORE_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <I>var</I> <B>-&gt;</B></TD></TR>
<TR><TD VALIGN="TOP">81</TD><TD VALIGN="TOP"><A NAME="WITH_TAG">WITH_TAG</A></TD><TD VALIGN="TOP"><I>condition</I> <I>expr</I> <B>|</B></TD></TR>
<TR><TD VALIGN="TOP">82</TD><TD VALIGN="TOP"><A NAME="XOR_TAG">XOR_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>xor</B></TD></TR>
<TR><TD VALIGN="TOP">83</TD><TD VALIGN="TOP"><A NAME="OR_TAG">OR_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>or</B></TD></TR>
<TR><TD VALIGN="TOP">84</TD><TD VALIGN="TOP"><A NAME="AND_TAG">AND_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>and</B></TD></TR>
<TR><TD VALIGN="TOP">85</TD><TD VALIGN="TOP"><A NAME="LT_TAG">LT_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>&lt;</B></TD></TR>
<TR><TD VALIGN="TOP">86</TD><TD VALIGN="TOP"><A NAME="LE_TAG">LE_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>&lt;=</B></TD></TR>
<TR><TD VALIGN="TOP">87</TD><TD VALIGN="TOP"><A NAME="EQ_TAG">EQ_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>=</B></TD></TR>
<TR><TD VALIGN="TOP">88</TD><TD VALIGN="TOP"><A NAME="GE_TAG">GE_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>&gt;=</B></TD></TR>
<TR><TD VALIGN="TOP">89</TD><TD VALIGN="TOP"><A NAME="GT_TAG">GT_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>&gt;</B></TD></TR>
<TR><TD VALIGN="TOP">8A</TD><TD VALIGN="TOP"><A NAME="NE_TAG">NE_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>/=</B></TD></TR>
<TR><TD VALIGN="TOP">8B</TD><TD VALIGN="TOP"><A NAME="ADD_TAG">ADD_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>+</B></TD></TR>
<TR><TD VALIGN="TOP">8C</TD><TD VALIGN="TOP"><A NAME="ADDELT_TAG">ADDELT_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>.+</B></TD></TR>
<TR><TD VALIGN="TOP">8D</TD><TD VALIGN="TOP"><A NAME="SUB_TAG">SUB_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>-</B></TD></TR>
<TR><TD VALIGN="TOP">8E</TD><TD VALIGN="TOP"><A NAME="SUBELT_TAG">SUBELT_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>.-</B></TD></TR>
<TR><TD VALIGN="TOP">8F</TD><TD VALIGN="TOP"><A NAME="MUL_TAG">MUL_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>*</B></TD></TR>
<TR><TD VALIGN="TOP">90</TD><TD VALIGN="TOP"><A NAME="MULELT_TAG">MULELT_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>.*</B></TD></TR>
<TR><TD VALIGN="TOP">91</TD><TD VALIGN="TOP"><A NAME="DIV_TAG">DIV_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>/</B></TD></TR>
<TR><TD VALIGN="TOP">92</TD><TD VALIGN="TOP"><A NAME="DIVELT_TAG">DIVELT_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>./</B></TD></TR>
<TR><TD VALIGN="TOP">93</TD><TD VALIGN="TOP"><A NAME="POW_TAG">POW_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>^</B></TD></TR>
<TR><TD VALIGN="TOP">94</TD><TD VALIGN="TOP"><A NAME="POWELT_TAG">POWELT_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>.^</B></TD></TR>
<TR><TD VALIGN="TOP">95</TD><TD VALIGN="TOP"><A NAME="SINCOS_TAG">SINCOS_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <I>expr</I> <B>trig</B> (where trig(<I>expr</I>,<I>int</I>)=cos(<I>expr</I>+(<I>int</I>-1)*pi/2))</TD></TR>
<TR><TD VALIGN="TOP">96</TD><TD VALIGN="TOP"><A NAME="SOLVE_TAG">SOLVE_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>equation</I> <B>solve</B></TD></TR>
<TR><TD VALIGN="TOP">97</TD><TD VALIGN="TOP"><A NAME="CSOLVE_TAG">CSOLVE_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>equation</I> <B>cSolve</B></TD></TR>
<TR><TD VALIGN="TOP">98</TD><TD VALIGN="TOP"><A NAME="NSOLVE_TAG">NSOLVE_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>equation</I> <B>nSolve</B></TD></TR>
<TR><TD VALIGN="TOP">99</TD><TD VALIGN="TOP"><A NAME="ZEROS_TAG">ZEROS_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>expr_in_var</I> <B>zeros</B></TD></TR>
<TR><TD VALIGN="TOP">9A</TD><TD VALIGN="TOP"><A NAME="CZEROS_TAG">CZEROS_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>expr_in_var</I> <B>cZeros</B></TD></TR>
<TR><TD VALIGN="TOP">9B</TD><TD VALIGN="TOP"><A NAME="FMIN_TAG">FMIN_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>expr_in_var</I> <B>fMin</B></TD></TR>
<TR><TD VALIGN="TOP">9C</TD><TD VALIGN="TOP"><A NAME="FMAX_TAG">FMAX_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>expr_in_var</I> <B>fMax</B></TD></TR>
<TR><TD VALIGN="TOP">9D</TD><TD VALIGN="TOP"><A NAME="COMPLEX_TAG">COMPLEX_TAG</A></TD><TD VALIGN="TOP">complex number</TD></TR>
<TR><TD VALIGN="TOP">9E</TD><TD VALIGN="TOP"><A NAME="POLYEVAL_TAG">POLYEVAL_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <I>list</I> <B>polyEval</B></TD></TR>
<TR><TD VALIGN="TOP">9F</TD><TD VALIGN="TOP"><A NAME="RANDPOLY_TAG">RANDPOLY_TAG</A></TD><TD VALIGN="TOP"><I>order</I> <I>var</I> <B>randPoly</B></TD></TR>
<TR><TD VALIGN="TOP">A0</TD><TD VALIGN="TOP"><A NAME="CROSSP_TAG">CROSSP_TAG</A></TD><TD VALIGN="TOP"><I>vec2</I> <I>vec1</I> <B>crossP</B></TD></TR>
<TR><TD VALIGN="TOP">A1</TD><TD VALIGN="TOP"><A NAME="DOTP_TAG">DOTP_TAG</A></TD><TD VALIGN="TOP"><I>vec2</I> <I>vec1</I> <B>dotP</B></TD></TR>
<TR><TD VALIGN="TOP">A2</TD><TD VALIGN="TOP"><A NAME="GCD_TAG">GCD_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>gcd</B></TD></TR>
<TR><TD VALIGN="TOP">A3</TD><TD VALIGN="TOP"><A NAME="LCM_TAG">LCM_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>lcm</B></TD></TR>
<TR><TD VALIGN="TOP">A4</TD><TD VALIGN="TOP"><A NAME="MOD_TAG">MOD_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>mod</B></TD></TR>
<TR><TD VALIGN="TOP">A5</TD><TD VALIGN="TOP"><A NAME="INTDIV_TAG">INTDIV_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>intDiv</B></TD></TR>
<TR><TD VALIGN="TOP">A6</TD><TD VALIGN="TOP"><A NAME="REMAIN_TAG">REMAIN_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>remain</B></TD></TR>
<TR><TD VALIGN="TOP">A7</TD><TD VALIGN="TOP"><A NAME="NCR_TAG">NCR_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>nCr</B></TD></TR>
<TR><TD VALIGN="TOP">A8</TD><TD VALIGN="TOP"><A NAME="NPR_TAG">NPR_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>nPr</B></TD></TR>
<TR><TD VALIGN="TOP">A9</TD><TD VALIGN="TOP"><A NAME="P2RX_TAG">P2RX_TAG</A></TD><TD VALIGN="TOP"><FONT FACE="Symbol">q</FONT><I>_expr</I> <I>r_expr</I> <B>P&gt;Rx</B></TD></TR>
<TR><TD VALIGN="TOP">AA</TD><TD VALIGN="TOP"><A NAME="P2RY_TAG">P2RY_TAG</A></TD><TD VALIGN="TOP"><FONT FACE="Symbol">q</FONT><I>_expr</I> <I>r_expr</I> <B>P&gt;Ry</B></TD></TR>
<TR><TD VALIGN="TOP">AB</TD><TD VALIGN="TOP"><A NAME="P2PTHETA_TAG">P2PTHETA_TAG</A></TD><TD VALIGN="TOP"><I>y_expr</I> <I>x_expr</I> <B>R&gt;P<FONT FACE="Symbol">q</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">AC</TD><TD VALIGN="TOP"><A NAME="P2PR_TAG">P2PR_TAG</A></TD><TD VALIGN="TOP"><I>y_expr</I> <I>x_expr</I> <B>R&gt;Pr</B></TD></TR>
<TR><TD VALIGN="TOP">AD</TD><TD VALIGN="TOP"><A NAME="AUGMENT_TAG">AUGMENT_TAG</A></TD><TD VALIGN="TOP"><I>mat2</I> <I>mat1</I> <B>augment</B></TD></TR>
<TR><TD VALIGN="TOP">AE</TD><TD VALIGN="TOP"><A NAME="NEWMAT_TAG">NEWMAT_TAG</A></TD><TD VALIGN="TOP"><I>num_columns</I> <I>num_rows</I> <B>newMat</B></TD></TR>
<TR><TD VALIGN="TOP">AF</TD><TD VALIGN="TOP"><A NAME="RANDMAT_TAG">RANDMAT_TAG</A></TD><TD VALIGN="TOP"><I>num_columns</I> <I>num_rows</I> <B>randMat</B></TD></TR>
<TR><TD VALIGN="TOP">B0</TD><TD VALIGN="TOP"><A NAME="SIMULT_TAG">SIMULT_TAG</A></TD><TD VALIGN="TOP"><I>vec</I> <I>mat</I> <B>simult</B></TD></TR>
<TR><TD VALIGN="TOP">B1</TD><TD VALIGN="TOP"><A NAME="PART_TAG">PART_TAG</A></TD><TD VALIGN="TOP">[<I>#</I>] <I>expr</I> <B>part</B></TD></TR>
<TR><TD VALIGN="TOP">B2</TD><TD VALIGN="TOP"><A NAME="EXP2LIST_TAG">EXP2LIST_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <I>list</I> <B>exp&gt;list</B></TD></TR>
<TR><TD VALIGN="TOP">B3</TD><TD VALIGN="TOP"><A NAME="RANDNORM_TAG">RANDNORM_TAG</A></TD><TD VALIGN="TOP"><I>sd</I> <I>mean</I> <B>randNorm</B></TD></TR>
<TR><TD VALIGN="TOP">B4</TD><TD VALIGN="TOP"><A NAME="MROW_TAG">MROW_TAG</A></TD><TD VALIGN="TOP">[] <I>index</I> <I>mat</I> <I>expr</I> <B>mRow</B></TD></TR>
<TR><TD VALIGN="TOP">B5</TD><TD VALIGN="TOP"><A NAME="ROWADD_TAG">ROWADD_TAG</A></TD><TD VALIGN="TOP">[] <I>index2</I> <I>index1</I> <I>mat</I> <B>rowAdd</B></TD></TR>
<TR><TD VALIGN="TOP">B6</TD><TD VALIGN="TOP"><A NAME="ROWSWAP_TAG">ROWSWAP_TAG</A></TD><TD VALIGN="TOP">[] <I>index2</I> <I>index1</I> <I>mat</I> <B>rowSwap</B></TD></TR>
<TR><TD VALIGN="TOP">B7</TD><TD VALIGN="TOP"><A NAME="ARCLEN_TAG">ARCLEN_TAG</A></TD><TD VALIGN="TOP">[] <I>end</I> <I>start</I> <I>var</I> <I>expr</I> <B>arcLen</B></TD></TR>
<TR><TD VALIGN="TOP">B8</TD><TD VALIGN="TOP"><A NAME="NINT_TAG">NINT_TAG</A></TD><TD VALIGN="TOP">[] <I>up</I> <I>low</I> <I>var</I> <I>expr</I> <B>nInt</B></TD></TR>
<TR><TD VALIGN="TOP">B9</TD><TD VALIGN="TOP"><A NAME="PI_PRODUCT_TAG">PI_PRODUCT_TAG</A></TD><TD VALIGN="TOP">[] <I>high</I> <I>low</I> <I>var</I> <I>expr</I> <B><FONT FACE="Symbol">&#213;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">BA</TD><TD VALIGN="TOP"><A NAME="SIGMA_SUM_TAG">SIGMA_SUM_TAG</A></TD><TD VALIGN="TOP">[] <I>high</I> <I>low</I> <I>var</I> <I>expr</I> <B><FONT FACE="Symbol">&#229;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">BB</TD><TD VALIGN="TOP"><A NAME="MROWADD_TAG">MROWADD_TAG</A></TD><TD VALIGN="TOP">[] <I>index2</I> <I>index1</I> <I>mat</I> <I>expr</I> <B>mRowAdd</B></TD></TR>
<TR><TD VALIGN="TOP">BC</TD><TD VALIGN="TOP"><A NAME="ANS_TAG">ANS_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>ans</B></TD></TR>
<TR><TD VALIGN="TOP">BD</TD><TD VALIGN="TOP"><A NAME="ENTRY_TAG">ENTRY_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>entry</B></TD></TR>
<TR><TD VALIGN="TOP">BE</TD><TD VALIGN="TOP"><A NAME="EXACT_TAG">EXACT_TAG</A></TD><TD VALIGN="TOP">[<I>tol</I>] <I>expr</I> <B>exact</B></TD></TR>
<TR><TD VALIGN="TOP">BF</TD><TD VALIGN="TOP"><A NAME="LOGB_TAG">LOGB_TAG</A></TD><TD VALIGN="TOP"><I>expr2</I> <I>expr1</I> <B>logb</B> (where logb(<I>expr1</I>,<I>expr2</I>)=ln(<I>expr1</I>)/ln(<I>expr2</I>))</TD></TR>
<TR><TD VALIGN="TOP">C0</TD><TD VALIGN="TOP"><A NAME="COMDENOM_TAG">COMDENOM_TAG</A></TD><TD VALIGN="TOP">[<I>var</I>] <I>expr</I> <B>comDenom</B></TD></TR>
<TR><TD VALIGN="TOP">C1</TD><TD VALIGN="TOP"><A NAME="EXPAND_TAG">EXPAND_TAG</A></TD><TD VALIGN="TOP">[<I>var</I>] <I>expr</I> <B>expand</B></TD></TR>
<TR><TD VALIGN="TOP">C2</TD><TD VALIGN="TOP"><A NAME="FACTOR_TAG">FACTOR_TAG</A></TD><TD VALIGN="TOP">[<I>var</I>] <I>expr</I> <B>factor</B></TD></TR>
<TR><TD VALIGN="TOP">C3</TD><TD VALIGN="TOP"><A NAME="CFACTOR_TAG">CFACTOR_TAG</A></TD><TD VALIGN="TOP">[<I>var</I>] <I>expr</I> <B>cFactor</B></TD></TR>
<TR><TD VALIGN="TOP">C4</TD><TD VALIGN="TOP"><A NAME="INTEGRATE_TAG">INTEGRATE_TAG</A></TD><TD VALIGN="TOP">[<I>up</I> <I>low</I>] <I>var</I> <I>expr</I> <B><FONT FACE="Symbol">&#242;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">C5</TD><TD VALIGN="TOP"><A NAME="DIFFERENTIATE_TAG">DIFFERENTIATE_TAG</A>&nbsp;&nbsp;&nbsp;</TD><TD VALIGN="TOP">[<I>order</I>] <I>var</I> <I>expr</I> <B><FONT FACE="Symbol">&#182;</FONT></B></TD></TR>
<TR><TD VALIGN="TOP">C6</TD><TD VALIGN="TOP"><A NAME="AVGRC_TAG">AVGRC_TAG</A></TD><TD VALIGN="TOP">[<I>h</I>] <I>var</I> <I>expr</I> <B>avgRC</B></TD></TR>
<TR><TD VALIGN="TOP">C7</TD><TD VALIGN="TOP"><A NAME="NDERIV_TAG">NDERIV_TAG</A></TD><TD VALIGN="TOP">[<I>h</I>] <I>var</I> <I>expr</I> <B>nDeriv</B></TD></TR>
<TR><TD VALIGN="TOP">C8</TD><TD VALIGN="TOP"><A NAME="TAYLOR_TAG">TAYLOR_TAG</A></TD><TD VALIGN="TOP">[<I>point</I>] <I>order</I> <I>var</I> <I>expr</I> <B>taylor</B></TD></TR>
<TR><TD VALIGN="TOP">C9</TD><TD VALIGN="TOP"><A NAME="LIMIT_TAG">LIMIT_TAG</A></TD><TD VALIGN="TOP">[<I>direction</I>] <I>point</I> <I>var</I> <I>expr</I> <B>limit</B></TD></TR>
<TR><TD VALIGN="TOP">CA</TD><TD VALIGN="TOP"><A NAME="PROPFRAC_TAG">PROPFRAC_TAG</A></TD><TD VALIGN="TOP">[<I>var</I>] <I>expr</I> <B>propFrac</B></TD></TR>
<TR><TD VALIGN="TOP">CB</TD><TD VALIGN="TOP"><A NAME="WHEN_TAG">WHEN_TAG</A></TD><TD VALIGN="TOP">[[<I>undef_val</I>] <I>false_val</I>] <I>true_val</I> <I>condition</I> <B>when</B></TD></TR>
<TR><TD VALIGN="TOP">CC</TD><TD VALIGN="TOP"><A NAME="ROUND_TAG">ROUND_TAG</A></TD><TD VALIGN="TOP">[<I>digits</I>] <I>expr</I> <B>round</B></TD></TR>
<TR><TD VALIGN="TOP">CD</TD><TD VALIGN="TOP"><A NAME="DMS_TAG">DMS_TAG</A></TD><TD VALIGN="TOP">[[<I>ss</I>] <I>mm</I>] <I>dd</I> <B>_DMSNUMBER_</B></TD></TR>
<TR><TD VALIGN="TOP">CE</TD><TD VALIGN="TOP"><A NAME="LEFT_TAG">LEFT_TAG</A></TD><TD VALIGN="TOP">[<I>num</I>] <I>string</I> <B>left</B></TD></TR>
<TR><TD VALIGN="TOP">CF</TD><TD VALIGN="TOP"><A NAME="RIGHT_TAG">RIGHT_TAG</A></TD><TD VALIGN="TOP">[<I>num</I>] <I>string</I> <B>right</B></TD></TR>
<TR><TD VALIGN="TOP">D0</TD><TD VALIGN="TOP"><A NAME="MID_TAG">MID_TAG</A></TD><TD VALIGN="TOP">[<I>count</I>] <I>start</I> <I>string</I> <B>mid</B></TD></TR>
<TR><TD VALIGN="TOP">D1</TD><TD VALIGN="TOP"><A NAME="SHIFT_TAG">SHIFT_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <I>list</I> <B>shift</B></TD></TR>
<TR><TD VALIGN="TOP">D2</TD><TD VALIGN="TOP"><A NAME="SEQ_TAG">SEQ_TAG</A></TD><TD VALIGN="TOP">[<I>step</I>] <I>high</I> <I>low</I> <I>var</I> <I>expr</I> <B>seq</B></TD></TR>
<TR><TD VALIGN="TOP">D3</TD><TD VALIGN="TOP"><A NAME="LIST2MAT_TAG">LIST2MAT_TAG</A></TD><TD VALIGN="TOP">[<I>elements_per_row</I>] <I>list</I> <B>list-&gt;mat</B></TD></TR>
<TR><TD VALIGN="TOP">D4</TD><TD VALIGN="TOP"><A NAME="SUBMAT_TAG">SUBMAT_TAG</A></TD><TD VALIGN="TOP">[[[[<I>col2</I>] <I>row2</I>] <I>col1</I>] <I>row1</I>] <I>mat</I> <B>subMat</B></TD></TR>
<TR><TD VALIGN="TOP">D5</TD><TD VALIGN="TOP"><A NAME="SUBSCRIPT_TAG">SUBSCRIPT_TAG</A></TD><TD VALIGN="TOP">[<I>col</I>] <I>row</I> <I>var</I> <B>_subscript_</B> (i.e. <I>var</I>[<I>row</I>] or <I>var</I>[<I>row</I>,<I>col</I>])</TD></TR>
<TR><TD VALIGN="TOP">D6</TD><TD VALIGN="TOP"><A NAME="RAND_TAG">RAND_TAG</A></TD><TD VALIGN="TOP">[<I>int</I>] <B>rand</B></TD></TR>
<TR><TD VALIGN="TOP">D7</TD><TD VALIGN="TOP"><A NAME="MIN_TAG">MIN_TAG</A></TD><TD VALIGN="TOP">[<I>expr2</I>] <I>list</I>|<I>expr1</I> <B>min</B></TD></TR>
<TR><TD VALIGN="TOP">D8</TD><TD VALIGN="TOP"><A NAME="MAX_TAG">MAX_TAG</A></TD><TD VALIGN="TOP">[<I>expr2</I>] <I>list</I>|<I>expr1</I> <B>max</B></TD></TR>
<TR><TD VALIGN="TOP">D9</TD><TD VALIGN="TOP"><A NAME="LIST_TAG">LIST_TAG</A></TD><TD VALIGN="TOP">list tag, or matrix represented as "list of list"</TD></TR>
<TR><TD VALIGN="TOP">DA</TD><TD VALIGN="TOP"><A NAME="USERFUNC_TAG">USERFUNC_TAG</A></TD><TD VALIGN="TOP">user defined function/program call: [[<B>...</B>] <I>arg1</I>] <B>'\0'</B> <I>fnc_name</I> <B>'\0'</B> <B>USERFUNC_TAG</B></TD></TR>
<TR><TD VALIGN="TOP">DB</TD><TD VALIGN="TOP"><A NAME="MATRIX_TAG">MATRIX_TAG</A></TD><TD VALIGN="TOP">matrix tag (only in data editor)</TD></TR>
<TR><TD VALIGN="TOP">DC</TD><TD VALIGN="TOP"><A NAME="FUNC_TAG">FUNC_TAG</A></TD><TD VALIGN="TOP">program/function tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">DD</TD><TD VALIGN="TOP"><A NAME="DATA_TAG">DATA_TAG</A></TD><TD VALIGN="TOP">data tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">DE</TD><TD VALIGN="TOP"><A NAME="GDB_TAG">GDB_TAG</A></TD><TD VALIGN="TOP">GDB tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">DF</TD><TD VALIGN="TOP"><A NAME="PIC_TAG">PIC_TAG</A></TD><TD VALIGN="TOP">picture tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">E0</TD><TD VALIGN="TOP"><A NAME="TEXT_TAG">TEXT_TAG</A></TD><TD VALIGN="TOP">text tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">E1</TD><TD VALIGN="TOP"><A NAME="FIG_TAG">FIG_TAG</A></TD><TD VALIGN="TOP">figure tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">E2</TD><TD VALIGN="TOP"><A NAME="MAC_TAG">MAC_TAG</A></TD><TD VALIGN="TOP">macro tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">E3</TD><TD VALIGN="TOP"><A NAME="EXT_TAG">EXT_TAG</A></TD><TD VALIGN="TOP">extra TI-Basic function token (see <A HREF="#ExtTags">ExtTags</A>)</TD></TR>
<TR><TD VALIGN="TOP">E4</TD><TD VALIGN="TOP"><A NAME="EXT_INSTR_TAG">EXT_INSTR_TAG</A></TD><TD VALIGN="TOP">TI-Basic command token (not used in expressions, see <A HREF="#InstructionTags">InstructionTags</A>)</TD></TR>
<TR><TD VALIGN="TOP">E5</TD><TD VALIGN="TOP"><A NAME="END_TAG">END_TAG</A></TD><TD VALIGN="TOP">end of the expression or the list</TD></TR>
<TR><TD VALIGN="TOP">E6</TD><TD VALIGN="TOP"><A NAME="COMMENT_TAG">COMMENT_TAG</A></TD><TD VALIGN="TOP">comment (not used in expressions): <B>'\0'</B> <I>string</I> <B>'\0'</B> <I>indentation</I> <B>COMMENT_TAG</B>, where <I>indentation</I> is a single byte indicating the number of spaces between <B>&copy;</B> and the first comment character</TD></TR>
<TR><TD VALIGN="TOP">E7</TD><TD VALIGN="TOP"><A NAME="NEXTEXPR_TAG">NEXTEXPR_TAG</A></TD><TD VALIGN="TOP">"<B>:</B>" between tokens on same line in the program (not used in expressions): <I>indentation</I> <B>NEXTEXPR_TAG</B>, where <I>indentation</I> is a single byte indicating the number of spaces between <B>:</B> and the first character of the next logical line</TD></TR>
<TR><TD VALIGN="TOP">E8</TD><TD VALIGN="TOP"><A NAME="NEWLINE_TAG">NEWLINE_TAG</A></TD><TD VALIGN="TOP">marks end of line in TI-Basic (not used in expressions): <I>indentation</I> <B>NEWLINE_TAG</B>, where <I>indentation</I> is a single byte indicating the number of spaces in front of the first character of the next line</TD></TR>
<TR><TD VALIGN="TOP">E9</TD><TD VALIGN="TOP"><A NAME="ENDSTACK_TAG">ENDSTACK_TAG</A></TD><TD VALIGN="TOP">end of TI-Basic program (not used in expressions), or end of the expression stack</TD></TR>
<TR><TD VALIGN="TOP">EA</TD><TD VALIGN="TOP"><A NAME="PN1_TAG">PN1_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>+/-</B></TD></TR>
<TR><TD VALIGN="TOP">EB</TD><TD VALIGN="TOP"><A NAME="PN2_TAG">PN2_TAG</A></TD><TD VALIGN="TOP"><I>expr1</I> <I>expr2</I> <B>+/-</B></TD></TR>
<TR><TD VALIGN="TOP">EC</TD><TD VALIGN="TOP"><A NAME="ERROR_MSG_TAG">ERROR_MSG_TAG</A></TD><TD VALIGN="TOP"><I>name</I> error_message</TD></TR>
<TR><TD VALIGN="TOP">ED</TD><TD VALIGN="TOP"><A NAME="EIGVC_TAG">EIGVC_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>eigVc</B></TD></TR>
<TR><TD VALIGN="TOP">EE</TD><TD VALIGN="TOP"><A NAME="EIGVL_TAG">EIGVL_TAG</A></TD><TD VALIGN="TOP"><I>mat</I> <B>eigVl</B></TD></TR>
<TR><TD VALIGN="TOP">EF</TD><TD VALIGN="TOP"><A NAME="DASH_TAG">DASH_TAG</A></TD><TD VALIGN="TOP"><I>expr</I> <B>'</B> (prime, i.e. <I>expr</I>')</TD></TR>
<TR><TD VALIGN="TOP">F0</TD><TD VALIGN="TOP"><A NAME="LOCALVAR_TAG">LOCALVAR_TAG</A></TD><TD VALIGN="TOP"><I>var</I> <B>_local_</B> (parameter/local variable reference)</TD></TR>
<TR><TD VALIGN="TOP">F1</TD><TD VALIGN="TOP"><A NAME="DESOLVE_TAG">DESOLVE_TAG</A></TD><TD VALIGN="TOP">[] <I>depend_var</I> <I>indep_var</I> <I>equation</I> <B>deSolve</B></TD></TR>
<TR><TD VALIGN="TOP">F2</TD><TD VALIGN="TOP"><A NAME="FDASH_TAG">FDASH_TAG</A></TD><TD VALIGN="TOP"><I>func_params</I> <I>func_name</I> ' (prime, i.e. <I>func_name</I>'(<I>func_params</I>)</TD></TR>
<TR><TD VALIGN="TOP">F3</TD><TD VALIGN="TOP"><A NAME="ASM_TAG">ASM_TAG</A></TD><TD VALIGN="TOP">ASM program tag (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">F4</TD><TD VALIGN="TOP"><A NAME="ISPRIME_TAG">ISPRIME_TAG</A></TD><TD VALIGN="TOP"><I>int</I> <B>isPrime</B></TD></TR>
<TR><TD VALIGN="TOP">F8</TD><TD VALIGN="TOP"><A NAME="OTH_TAG">OTH_TAG</A></TD><TD VALIGN="TOP">Other file tag, for custom file types (not used in expressions)</TD></TR>
<TR><TD VALIGN="TOP">F9</TD><TD VALIGN="TOP"><A NAME="ROTATE_TAG">ROTATE_TAG</A></TD><TD VALIGN="TOP">[<I>count</I>] <I>list|int|string</I> <B>rotate</B></TD></TR>
</TABLE>
<BR>
<B>Note:</B> An empty list [] of optional arguments means the function does not take any optional arguments, but an END_TAG is needed nonetheless.
<BR><BR>
<B>Note:</B> For compatibility with TI's compiler, their tag names are also supported.</P>

<HR>
<H3><A NAME="TokenizeSymNameFlags"><U>TokenizeSymNameFlags</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> TokenizeSymNameFlags {TSF_FULLY_QUALIFIED = 0x01, TSF_ALLOW_RESERVED = 0x02, TSF_PASS_ERRORS = 0x04};</TD></TR></TABLE></P>
<P><B>Contains flags specifying how a symbol name is tokenized.</B></P>

<P>TokenizeSymNameFlags is an enumeration containing flags used by <A HREF="#TokenizeSymName">TokenizeSymName</A>.</P>

<HR>
<H3><A HREF="index.html">Return to the main index</A></H3>
</BODY>
</HTML>
